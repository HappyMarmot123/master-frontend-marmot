# 주요 정렬 알고리즘: 삽입, 퀵, 병합 정렬

## 1. Insertion Sort (삽입 정렬)

삽입 정렬은 **이미 정렬된 부분**과 **아직 정렬되지 않은 부분**으로 나누어, 정렬되지 않은 부분의 원소를 하나씩 꺼내 이미 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 알고리즘입니다.

### 동작 원리

1. 두 번째 원소부터 시작하여, 현재 원소를 `key` 값으로 설정합니다.
2. `key` 값을 이미 정렬된 배열 부분(key의 왼쪽에 있는 원소들)과 비교합니다.
3. `key` 값보다 큰 원소들을 오른쪽으로 한 칸씩 이동시킵니다.
4. 자신보다 작거나 같은 값을 만나거나, 배열의 맨 앞에 도달하면 그 바로 뒷자리에 `key` 값을 삽입합니다.
5. 배열의 마지막 원소까지 이 과정을 반복합니다.

### 시간 복잡도

- **최선**: `O(n)` - 이미 데이터가 정렬되어 있는 경우, 외부 루프만 한 번 순회합니다.
- **평균**: `O(n²)`
- **최악**: `O(n²)` - 데이터가 역순으로 정렬되어 있는 경우, 모든 원소가 최대 비교 및 이동을 수행합니다.

**안정 정렬(Stable Sort)** 이므로 중복된 값의 순서가 유지됩니다. In-place 정렬이므로 추가적인 메모리 공간이 거의 필요 없고 이미 정렬된 데이터나 거의 정렬된 데이터에 대해서는 매우 효율적입니다. 단, 데이터의 양이 많아질수록 성능이 급격히 저하됩니다.

## 2. Quick Sort (퀵 정렬)

퀵 정렬은 **분할 정복(Divide and Conquer)** 전략을 사용하는 대표적인 정렬 알고리즘입니다. 배열 내에서 하나의 기준점(**피벗, pivot**)을 설정하고, 피벗보다 작은 값들은 왼쪽으로, 큰 값들은 오른쪽으로 분할한 뒤, 분할된 각 부분을 재귀적으로 정렬합니다.

### 동작 원리

1. 배열에서 하나의 원소를 선택하여 `피벗(pivot)`으로 설정합니다.
2. 피벗을 기준으로 배열을 두 개의 부분 배열로 분할(Partition)합니다. 피벗보다 작은 모든 원소는 피벗의 왼쪽으로, 큰 모든 원소는 오른쪽으로 이동시킵니다.
3. 분할된 두 개의 부분 배열에 대해 재귀적으로 퀵 정렬을 수행합니다.
4. 부분 배열의 크기가 0이나 1이 될 때까지 이 과정을 반복합니다.

### 시간 복잡도

- **최선**: `O(n log n)`
- **평균**: `O(n log n)` - 피벗이 배열을 균등하게 분할할 때 가장 이상적인 성능을 보입니다.
- **최악**: `O(n²)` - 이미 정렬된 배열에서 항상 첫 번째 또는 마지막 원소를 피벗으로 선택하는 경우, 분할이 한쪽으로 치우쳐(n-1, 0) 성능이 저하됩니다.

평균적으로 매우 빠른 정렬 속도를 자랑합니다. In-place 정렬이므로 추가적인 메모리 공간이 거의 필요 없습니다. **불안정 정렬(Unstable Sort)**입니다. (중복된 값의 순서가 바뀔 수 있습니다.) 피벗 선택에 따라 성능이 크게 좌우되며, ₩최악의 경우 `O(n²)`의 시간 복잡도를 가집니다.

### 장단점

- ## **장점**:
- ## **단점**:

> 💡 **Tip:** 퀵 정렬의 성능을 최적화하기 위해 피벗을 선택하는 다양한 방법(예: 배열의 중간값 선택, 랜덤 선택, 세 값의 중위값 선택)이 사용됩니다.

---

## 3. Merge Sort (병합 정렬)

병합 정렬 역시 **분할 정복** 전략을 사용하는 알고리즘입니다. 배열을 더 이상 나눌 수 없을 때까지(원소가 하나만 남을 때까지) 계속해서 반으로 분할한 다음, 다시 정렬하면서 병합(Merge)하는 방식으로 동작합니다.

### 동작 원리

1. **분할(Divide)**: 현재 배열을 길이가 같거나 비슷한 두 개의 부분 배열로 나눕니다.
2. **정복(Conquer)**: 각 부분 배열의 크기가 1이 될 때까지 재귀적으로 분할을 반복합니다.
3. **결합(Combine)**: 분할된 두 개의 부분 배열을 **정렬하면서 하나의 배열로 병합**합니다. 이 과정에서 임시 배열이 필요합니다.

### 시간 복잡도

- **최선, 평균, 최악 모두**: `O(n log n)` - 데이터의 분포와 상관없이 항상 일관된 성능을 보장합니다.

### 장단점

- **장점**:
  - **안정 정렬(Stable Sort)**입니다.
  - 최악의 경우에도 `O(n log n)`의 시간 복잡도를 보장하여 성능이 안정적입니다.
- **단점**:
  - 정렬 과정에서 임시 배열을 위한 추가적인 메모리 공간(`O(n)`)이 필요합니다.
  - In-place 방식에 비해 메모리 사용량이 많습니다.

---

## 📊 알고리즘 비교 요약

| 알고리즘      | 시간 복잡도 (평균) | 시간 복잡도 (최악) | 공간 복잡도 | 안정성(Stable) |
| :------------ | :----------------: | :----------------: | :---------: | :------------: |
| **삽입 정렬** |      `O(n²)`       |      `O(n²)`       |   `O(1)`    |       O        |
| **퀵 정렬**   |    `O(n log n)`    |      `O(n²)`       | `O(log n)`  |       X        |
| **병합 정렬** |    `O(n log n)`    |    `O(n log n)`    |   `O(n)`    |       O        |

---

# 4. DFS (Depth First Search, 깊이 우선 탐색)

**DFS**는 그래프의 모든 노드를 탐색하기 위한 알고리즘으로, 이름 그대로 깊이를 우선하여 탐색합니다. 루트 노드(또는 임의의 시작 노드)에서 시작해 자식노드를 계속 따라가며 더 이상 자식노드가 나타나지 않을 때까지 진행하고 더 이상 자녀가 없을 때는 왔던 길을 다시 거슬러 올라가며 탐색하지 않은 다른 노드들을 같은 방법으로 순회하는 알고리즘이다.

### 특징

- **스택(Stack)** 자료구조 또는 **재귀 함수**를 이용하여 구현됩니다. (재귀 호출이 내부적으로 함수 호출 스택을 사용합니다.)
- 현재 경로상의 노드를 모두 방문한 뒤에야 인접한 다른 경로를 탐색하므로, 현재 위치에서 가장 멀리 있는 노드를 먼저 방문합니다.
- 최단 경로를 보장하지 않습니다.

### 동작 원리

1. 탐색을 시작할 노드를 스택에 넣고, 방문 처리합니다.
2. 스택의 최상단에 있는 노드(현재 방문한 노드)를 확인합니다.
3. 해당 노드에 연결된 인접 노드 중 아직 방문하지 않은 노드가 있다면, 그 노드를 스택에 넣고 방문 처리합니다.
4. 만약 방문하지 않은 인접 노드가 없다면, 스택에서 현재 노드를 꺼냅니다(pop).
5. 스택이 비어있을 때까지 2-4번 과정을 반복합니다.

---

### 주요 활용 사례

- **경로 찾기**: 두 노드 사이에 경로가 존재하는지 확인할 수 있습니다.
- **연결 요소(Connected Components) 찾기**: 그래프가 몇 개의 독립적인 부분 그래프로 구성되어 있는지 파악할 수 있습니다.
- **사이클 탐지(Cycle Detection)**: 그래프 내에 순환(사이클)이 존재하는지 확인할 수 있습니다.
- **위상 정렬(Topological Sort)**: 작업의 선후 관계가 있는 그래프에서 작업 순서를 결정할 때 사용됩니다.

---

# 5. BFS (Breadth-First Search, 너비 우선 탐색)

**BFS**는 그래프의 모든 노드를 탐색하기 위한 알고리즘으로, 이름 그대로 너비를 우선하여 탐색합니다. 루트 노드(또는 임의의 시작 노드)에서 시작하여, 가까운 노드를 먼저 방문하고 더 멀리 있는 노드를 나중에 방문하는 방식입니다. 더 작은 문제를 먼저 해결함으로 큰 문제를 해결합니다.

### 특징

- **큐(Queue)** 자료구조를 이용하여 구현됩니다. (FIFO: First-In, First-Out)
- 시작 노드에서부터 거리가 가까운 순서대로, 즉 레벨(level) 순으로 노드를 탐색합니다.
- **가중치가 없는 그래프**에서 두 노드 간의 최단 경로를 찾는 데 사용될 수 있습니다.

### 동작 원리

1. 탐색을 시작할 노드를 큐에 넣고, 방문 처리합니다.
2. 큐가 비어있을 때까지 다음 과정을 반복합니다.
3. 큐에서 노드를 하나 꺼냅니다(dequeue).
4. 해당 노드에 연결된 인접 노드 중 아직 방문하지 않은 모든 노드를 큐에 넣고(enqueue), 방문 처리합니다.

---

# 6. DP (Dynamic Programming, 동적 계획법)

동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 여러 개의 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법입니다. DP를 적용하려면 문제가 다음 두 가지 속성을 만족해야 합니다.

1. **겹치는 하위 문제 (Overlapping Subproblems)**: 동일한 하위 문제가 반복적으로 나타나야 합니다. DP는 이 반복 계산을 줄이기 위해 한 번 계산한 결과를 저장(캐싱)해두었다가 재사용합니다.
2. **최적 부분 구조 (Optimal Substructure)**: 전체 문제의 최적해가 그 하위 문제들의 최적해로부터 구해질 수 있어야 합니다.

DP는 주로 두 가지 방식으로 구현됩니다.

### 1. 하향식 (Top-Down)

**하향식**은 가장 큰 문제에서 시작하여 하위 문제로 점차 쪼개 나가는 **재귀(Recursion)** 기반의 방식입니다. 이 과정에서 한 번 해결한 하위 문제의 결과는 메모리(배열이나 해시맵 등)에 저장(Memoization)해두고, 나중에 동일한 하위 문제가 다시 나타나면 저장된 값을 그대로 가져와 사용합니다.

- **장점**: 재귀를 사용하므로 문제의 점화식을 코드로 직관적으로 옮기기 쉽고, 필요한 하위 문제만 계산합니다.
- **단점**: 재귀 호출로 인한 스택 오버플로우가 발생할 수 있고, 함수 호출 오버헤드가 있습니다.

### 2. 상향식 (Bottom-Up)

**상향식**은 가장 작은 하위 문제부터 시작하여 차례차례 정답을 쌓아 올려 최종적으로 가장 큰 문제의 해를 구하는 **반복문(Loop)** 기반의 방식입니다. 모든 하위 문제의 결과를 **테이블(Table)**에 순서대로 저장해 나간다고 해서 **타뷸레이션**이라고도 부릅니다.

- **장점**: 반복문을 사용하므로 재귀 방식보다 빠르고 스택 오버플로우 위험이 없습니다.
- **단점**: 문제에 따라서는 불필요한 하위 문제까지 모두 계산해야 할 수 있습니다.

---

### 예시: 피보나치 수열로 DP 이해하기

#### 피보나치 수열이란?

피보나치 수열은 **이전 두 항의 합이 다음 항이 되는 수열**을 말합니다. 점화식으로는 `F(n) = F(n-1) + F(n-2)` 로 표현되며, 일반적으로 `F(0)=0`과 `F(1)=1`을 초기값으로 설정합니다.

> (0, 1, 1, 2, 3, 5, 8, 13, 21, ...)

이 수열은 간단한 규칙을 가지면서도, 재귀적으로 계산할 때 동일한 계산이 반복적으로 발생하여 동적 계획법(DP)의 원리를 설명하는 대표적인 예제로 사용됩니다.

#### naïve 한 재귀 방식의 문제점

```javascript
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
```

`fib(5)`를 호출하면 `fib(4)`와 `fib(3)`을 호출하고, `fib(4)`는 다시 `fib(3)`과 `fib(2)`를 호출합니다. 여기서 **`fib(3)`이 중복 계산**되는 것을 볼 수 있습니다. `n`이 커질수록 이런 중복 호출은 기하급수적으로 늘어나 시간 복잡도가 `O(2^n)`에 달하게 됩니다.

#### 1. 하향식 (Top-Down) DP 적용

문제를 재귀적으로 해결하되, 계산 결과를 `memo` 배열에 저장하여 중복 계산을 피합니다.

```javascript
// memo 배열을 -1과 같은 값으로 초기화했다고 가정
let memo = Array(n + 1).fill(-1);

function fib_memo(n) {
  // 이미 계산한 값이면 바로 반환
  if (memo[n] !== -1) return memo[n];

  if (n <= 1) {
    memo[n] = n;
    return n;
  }

  // 계산한 적 없으면 계산 후 memo에 저장
  memo[n] = fib_memo(n - 1) + fib_memo(n - 2);
  return memo[n];
}
```

`fib_memo(3)`은 최초 한 번만 계산되고, 이후에는 `memo[3]`에 저장된 값을 즉시 반환합니다. 모든 하위 문제는 한 번씩만 계산되므로 시간 복잡도는 **`O(n)`**으로 개선됩니다.

#### 2. 상향식 (Bottom-Up) DP 적용

가장 작은 문제인 `F(0)`와 `F(1)`부터 시작하여 테이블(`dp` 배열)을 채워 나갑니다.

```javascript
function fib_tab(n) {
  if (n <= 1) return n;

  // 테이블(dp 배열) 생성
  let dp = Array(n + 1);

  // 베이스 케이스(가장 작은 문제) 초기화
  dp[0] = 0;
  dp[1] = 1;

  // 반복문을 통해 테이블을 채워나감
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  // 최종 문제의 해답 반환
  return dp[n];
}
```

반복문을 통해 `dp[2]`, `dp[3]`, ... 순서로 `dp[n]`까지 계산합니다. 이 방식 역시 시간 복잡도는 **`O(n)`**입니다.
