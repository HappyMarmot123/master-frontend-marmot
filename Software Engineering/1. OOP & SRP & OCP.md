# 객체 지향 프로그래밍 (Object-Oriented Programming)

## 📖 개요

현대 소프트웨어 개발의 핵심 패러다임 중 하나입니다. 데이터와 그 데이터를 조작하는 메서드를 하나의 단위(객체)로 묶어 프로그램을 구성하는 방식으로, 코드의 재사용성, 유지보수성, 확장성을 크게 향상시킵니다.

**클래스**는 객체를 생성하기 위한 일종의 템플릿으로, 객체가 가져야 할 속성(데이터)과 메서드(동작)를 정의합니다.

**객체**는 클래스의 인스턴스로, 실제로 메모리에 할당되어 동작하는 실체입니다.

## 🔍 객체 지향의 4대 원칙

#### 캡슐화(Encapsulation)

- **정보 은닉**: 데이터와 메서드를 객체 안에 묶어 외부에서 직접 접근하지 못하도록 보호합니다.
- **접근 제어**: `public`, `private`, `protected`와 같은 접근 제한자를 사용하여 외부 노출 수준을 제어합니다.

#### 상속(Inheritance)

- **코드 재사용**: 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용함으로써 코드 중복을 줄입니다.

#### 다형성(Polymorphism)

- **다형성:** 동일한 이름의 메서드가 다른 클래스 또는 다른 컨텍스트에서 다양한 방식으로 구현될 수 있음을 의미합니다.
- **오버라이딩**: 자식 클래스에서 부모 클래스의 메서드를 재정의하여 다른 동작을 구현합니다.
- **오버로딩**: 동일한 이름의 메서드를 다른 매개변수로 여러 번 정의하여 다양한 입력을 처리합니다.

#### 추상화(Abstraction)

- **복잡성 감소**: 복잡한 시스템의 내부 구현을 숨기고, 사용자가 필요로 하는 핵심적인 기능이나 정보만을 노출하는 과정입니다.
- **구현 분리**: 추상화된 인터페이스와 구체적인 구현을 분리하여 시스템의 유연성을 높입니다.

## 🎯 SRP (Single Responsibility Principle)

SRP는 단일 책임 원칙으로, 하나의 클래스는 하나의 책임만 가져야 한다는 원칙입니다. 즉, 클래스를 변경해야 하는 이유는 단 하나여야 합니다.

### 왜 중요한가?

- 코드의 응집도를 높이고 결합도를 낮춥니다.
- 변경 사유가 명확해져 유지보수가 쉬워집니다.
- 테스트가 용이해지고 재사용성이 향상됩니다.

### 냄새 나는 설계(나쁜 예)

하나의 클래스가 여러 책임을 가지고 있는 경우입니다.

```javascript
// 사용자 관리, 이메일 발송, 로깅을 모두 담당하는 클래스 (SRP 위반)
class UserManager {
  constructor() {
    this.users = [];
  }

  addUser(user) {
    this.users.push(user);
    this.sendWelcomeEmail(user); // 이메일 발송 책임
    this.logUserCreation(user); // 로깅 책임
  }

  sendWelcomeEmail(user) {
    // 이메일 발송 로직
    console.log(`Welcome email sent to ${user.email}`);
  }

  logUserCreation(user) {
    // 로깅 로직
    console.log(`User ${user.name} created at ${new Date()}`);
  }
}
```

### SRP 준수(좋은 예)

각 클래스가 하나의 책임만 가지도록 분리합니다.

```javascript
// 사용자 관리만 담당
class UserManager {
  constructor() {
    this.users = [];
  }

  addUser(user) {
    this.users.push(user);
  }

  getUsers() {
    return this.users;
  }
}

// 이메일 발송만 담당
class EmailService {
  sendWelcomeEmail(user) {
    console.log(`Welcome email sent to ${user.email}`);
  }
}

// 로깅만 담당
class Logger {
  logUserCreation(user) {
    console.log(`User ${user.name} created at ${new Date()}`);
  }
}

// 사용: 각 서비스를 조합하여 사용
class UserService {
  constructor(userManager, emailService, logger) {
    this.userManager = userManager;
    this.emailService = emailService;
    this.logger = logger;
  }

  createUser(user) {
    this.userManager.addUser(user);
    this.emailService.sendWelcomeEmail(user);
    this.logger.logUserCreation(user);
  }
}

// 사용 예시
const userManager = new UserManager();
const emailService = new EmailService();
const logger = new Logger();
const userService = new UserService(userManager, emailService, logger);

userService.createUser({ name: "John", email: "john@example.com" });
```

### 적용 가이드

- **규칙**: 클래스를 변경해야 하는 이유가 오직 하나인지 확인하세요.
- **분리 기준**: 기능적으로 응집도가 높은 메서드들을 하나의 클래스로 묶으세요.
- **의존성**: 각 클래스는 필요한 최소한의 의존성만 가져야 합니다.

### 안티패턴

- **거대 클래스(God Class):** 너무 많은 책임을 가진 클래스
- **다목적 클래스:** 서로 관련 없는 여러 기능을 수행하는 클래스
- **잦은 변경:** 다양한 이유로 자주 수정되어야 하는 클래스

## 🧱 OCP (Open-Closed Principle)

OCP는 소프트웨어 개체(클래스, 모듈, 함수 등)가 **확장에는 열려 있고(Open for extension), 변경에는 닫혀 있어야(Closed for modification)** 한다는 원칙입니다. 즉, 기존 코드를 수정하지 않고도 새로운 기능을 추가(확장)할 수 있어야 합니다.

### 왜 중요한가?

- 변경 범위를 최소화하여 예기치 않은 버그(회귀 버그)를 줄입니다.
- 공통 규약(추상화)에 의존함으로써 기능을 플러그인처럼 교체하거나 추가할 수 있습니다.
- 테스트 용이성 및 유지보수성이 향상됩니다.

### 냄새 나는 설계(나쁜 예)

새로운 요구사항이 추가될 때마다 기존 코드를 직접 수정해야 하는 구조는 OCP를 위반합니다.

```javascript
// 결제 타입이 늘어날 때마다 이 함수 자체를 수정해야 함 (OCP 위반)
function pay(amount, method) {
  if (method === "card") {
    // ... 카드 결제 로직
  } else if (method === "paypal") {
    // ... 페이팔 결제 로직
  } else if (method === "crypto") {
    // ... 암호화폐 결제 로직
  } else {
    throw new Error("지원하지 않는 결제 방식");
  }
}
```

### 향기로운 설계(OCP 준수)

공통 인터페이스(추상화)에 의존하고, 구체적인 구현 클래스를 새로 추가하여 기능을 확장합니다. 이 경우 기존 코드는 수정할 필요가 없습니다.

```javascript
// 공통 인터페이스(프로토콜)
class PaymentStrategy {
  pay(amount) {
    throw new Error("pay를 구현해야 합니다.");
  }
}

class CardPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[CARD] ${amount}원 결제`);
  }
}

class PaypalPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[PAYPAL] ${amount}원 결제`);
  }
}

// 새로운 방식 추가 시, 기존 코드 수정 없이 클래스만 추가
class CryptoPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[CRYPTO] ${amount}원 결제`);
  }
}

class PaymentProcessor {
  constructor(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }
  setStrategy(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }
  process(amount) {
    this.paymentStrategy.pay(amount);
  }
}

// 사용
const processor = new PaymentProcessor(new CardPayment());
processor.process(10000);
processor.setStrategy(new PaypalPayment());
processor.process(20000);
```

### 적용 가이드

- **규칙**: "변하는 것"과 "변하지 않는 것"을 분리하고, 변하는 부분을 추상화하여 캡슐화합니다.
- **의존성 방향**: 구체적인 구현이 아닌 추상화(인터페이스, 추상 클래스 등)에 의존해야 합니다.

### 안티패턴

- **거대한 if/switch 분기:** 새로운 조건이 추가될 때마다 분기문을 수정해야 하는 경우
- **추상화 없는 구체 클래스 의존:** 구체적인 구현 클래스에 직접 의존하여 유연성이 떨어지는 경우
