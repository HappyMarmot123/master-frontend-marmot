# TDD (Test-Driven Development) & DDD (Domain-Driven Design)

TDD(Test-Driven Development)와 DDD(Domain-Driven Design)는 소프트웨어 개발의 품질과 효율성을 높이는 데 기여하는 중요한 개발 패러다임입니다. TDD는 '테스트 먼저 작성'을 통해 코드 품질을 향상시키고, DDD는 '도메인 모델 중심'으로 복잡한 비즈니스 로직을 효과적으로 관리할 수 있도록 돕습니다.

## 1. TDD (Test-Driven Development - 테스트 주도 개발)

TDD는 '테스트 주도 개발'이라는 이름처럼, 실제 코드를 작성하기 전에 먼저 실패하는 테스트 케이스를 작성하고, 이 테스트를 통과할 수 있는 최소한의 코드를 작성한 후, 코드를 리팩토링하는 과정을 반복하는 개발 방법론입니다.

### 1.1. TDD의 3단계 (Red-Green-Refactor Cycle)

TDD는 다음 세 가지 단계를 작은 주기로 반복하여 진행됩니다.

1.  **Red (빨강): 실패하는 테스트 작성**

    - 구현하고자 하는 기능에 대한 새로운 테스트 코드를 작성합니다. 이 테스트는 아직 기능이 구현되지 않았으므로 '반드시 실패'해야 합니다.
    - 목표는 작고 구체적인 기능을 검증하는 테스트를 만드는 것입니다.

2.  **Green (초록): 테스트를 통과시키는 코드 작성**

    - 작성한 실패 테스트를 통과시키기 위한 '최소한의' 실제 코드를 작성합니다. 불필요한 기능이나 완벽한 코드를 작성하기보다, 오직 테스트를 통과하는 데 집중합니다.
    - 이 단계에서는 코드의 품질이나 디자인보다는 기능 구현에 초점을 맞춥니다.

3.  **Refactor (리팩토링): 코드 개선**
    - 테스트가 모두 통과하는 '초록' 상태가 되면, 코드를 깔끔하고 효율적으로 개선(리팩토링)합니다. 이 과정에서 '기능 변경 없이' 코드의 구조, 가독성, 유지보수성을 향상시킵니다.
    - 리팩토링 후에도 모든 테스트가 통과하는지 확인하여 기존 기능이 손상되지 않았음을 보장합니다.

### 1.2. TDD의 장점

- **버그 감소 및 코드 품질 향상:** 테스트 코드가 존재하므로 버그를 조기에 발견하고, 항상 테스트를 통과하는 코드를 작성하므로 코드의 신뢰성이 높아집니다.
- **설계 개선:** 테스트를 먼저 작성하는 과정에서 기능의 '명세'를 정의하게 되어, 더 나은 설계와 모듈화를 유도합니다.
- **리팩토링 용이:** 안전하게 리팩토링할 수 있는 기반을 제공합니다. 테스트가 있으므로 코드 변경 후에도 기능이 정상 작동하는지 즉시 확인할 수 있습니다.
- **문서화 역할:** 테스트 코드는 그 자체가 해당 기능의 사용 방법과 기대 동작을 설명하는 훌륭한 문서가 됩니다.
- **개발 속도 향상:** 장기적으로는 버그 수정 시간이 줄어들어 전체 개발 속도가 빨라집니다.

### 1.3. TDD의 단점

- **초기 개발 시간 증가:** 테스트 코드를 먼저 작성해야 하므로 초기 개발 시간이 증가할 수 있습니다.
- **테스트 코드 관리:** 테스트 코드 자체도 유지보수가 필요하며, 잘못된 테스트는 오히려 개발에 방해가 될 수 있습니다.
- **모든 상황에 적합하지 않음:** UI/UX 개발, 레거시 코드 수정 등 일부 상황에서는 TDD 적용이 어려울 수 있습니다.

## 2. DDD (Domain-Driven Design - 도메인 주도 설계)

DDD는 '도메인 주도 설계'라는 이름처럼, 복잡한 소프트웨어 시스템을 개발할 때 비즈니스 '도메인'에 대한 깊은 이해를 바탕으로 소프트웨어를 설계하는 접근 방식입니다. 개발자와 도메인 전문가가 함께 '유비쿼터스 언어(Ubiquitous Language)'를 사용하여 도메인 모델을 구축하고, 이 모델을 코드에 직접 반영하는 것을 목표로 합니다.

### 2.1. DDD의 핵심 개념

- **도메인 (Domain):** 소프트웨어가 해결하고자 하는 문제 영역. (예: '주문 관리', '은행 업무')
- **도메인 모델 (Domain Model):** 도메인의 핵심 개념과 비즈니스 로직을 추상화하여 표현한 모델. 이는 단순히 데이터 구조가 아니라 비즈니스 규칙과 행위를 포함합니다.
- **유비쿼터스 언어 (Ubiquitous Language):** 도메인 전문가와 개발자 간에 공유되는 공통 언어. 도메인 모델에 사용되는 용어는 이 언어에서 파생됩니다.
- **바운디드 컨텍스트 (Bounded Context):** 명확한 경계를 가지는 도메인 모델의 특정 부분. 각 바운디드 컨텍스트는 자체적인 유비쿼터스 언어와 도메인 모델을 가질 수 있습니다.
- **엔티티 (Entity):** 고유한 식별자를 가지며, 시간이 지나도 동일성을 유지하는 객체. (예: '주문', '고객')
- **값 객체 (Value Object):** 식별자가 없고, 속성 값으로만 정의되는 객체. (예: '주소', '금액')
- **애그리거트 (Aggregate):** 함께 다루어져야 하는 엔티티와 값 객체의 묶음. 하나의 '루트 엔티티'를 통해 외부에서 접근하고 변경할 수 있습니다.
- **리포지토리 (Repository):** 애그리거트의 저장, 조회 등을 담당하는 인터페이스. 데이터 영속성(Persistence) 계층과의 분리를 담당합니다.

### 2.2. DDD의 장점

- **복잡한 도메인 문제 해결:** 복잡한 비즈니스 로직을 모델링하고 관리하는 데 효과적입니다.
- **비즈니스 전문가와 소통:** 유비쿼터스 언어를 통해 개발자와 비즈니스 전문가 간의 의사소통을 원활하게 합니다.
- **코드와 도메인의 일치:** 코드 구조가 도메인 모델을 직접 반영하므로, 코드의 이해도와 유지보수성이 높아집니다.
- **유연하고 확장 가능한 아키텍처:** 도메인 모델 중심의 설계를 통해 변화에 유연하게 대응하고 확장하기 쉬운 아키텍처를 구축할 수 있습니다.

### 2.3. DDD의 단점

- **높은 학습 곡선:** DDD의 개념과 원칙을 이해하고 적용하는 데 상당한 시간과 노력이 필요합니다.
- **초기 비용 증가:** 초기 도메인 분석 및 모델링에 많은 시간과 노력이 투자됩니다.
- **모든 프로젝트에 적합하지 않음:** 비즈니스 로직이 단순하거나 데이터 중심적인 CRUD(Create, Read, Update, Delete) 애플리케이션에는 과도하게 복잡할 수 있습니다.
- **팀원 간의 협업 중요:** 도메인 전문가와 개발자 간의 지속적인 협업과 의사소통이 필수적입니다.

## 3. TDD와 DDD의 관계

TDD와 DDD는 서로 다른 목적을 가지고 있지만, 함께 사용될 때 시너지를 발휘하여 소프트웨어 개발의 품질과 효율성을 극대화할 수 있습니다.

- **TDD가 DDD를 돕는 방법:**
  - DDD를 통해 정의된 도메인 모델의 각 구성 요소(엔티티, 값 객체, 서비스 등)에 대해 TDD를 적용하여 정확하고 견고한 비즈니스 로직을 구현할 수 있습니다.
  - 테스트 코드를 통해 도메인 모델의 행위를 명확하게 정의하고 검증할 수 있습니다.
- **DDD가 TDD를 돕는 방법:**
  - DDD는 '무엇을 테스트할 것인가'에 대한 명확한 가이드라인을 제공합니다. 도메인 모델이 잘 정의되어 있으면 테스트의 대상과 범위를 쉽게 파악할 수 있습니다.
  - 유비쿼터스 언어를 통해 테스트 시나리오를 더욱 명확하게 작성할 수 있습니다.

## 4. 예제 코드 (JavaScript - TDD와 DDD의 간단한 결합)

DDD의 간단한 도메인 모델(예: `Product` 엔티티)을 정의하고, TDD 방식으로 이 엔티티의 비즈니스 로직을 개발하는 가상의 예시입니다.

```javascript
// ---- 도메인 모델: Product (DDD 관점) ----
// Product.js
class Product {
  constructor(id, name, price) {
    if (price < 0) {
      throw new Error("가격은 음수가 될 수 없습니다.");
    }
    this.id = id;
    this.name = name;
    this.price = price;
  }

  // 비즈니스 로직: 할인 적용
  applyDiscount(percentage) {
    if (percentage < 0 || percentage > 100) {
      throw new Error("할인율은 0%에서 100% 사이여야 합니다.");
    }
    const discountAmount = this.price * (percentage / 100);
    this.price = parseFloat((this.price - discountAmount).toFixed(2)); // 소수점 처리
  }

  // 비즈니스 로직: 가격 변경
  changePrice(newPrice) {
    if (newPrice < 0) {
      throw new Error("새로운 가격은 음수가 될 수 없습니다.");
    }
    this.price = newPrice;
  }
}

// ---- TDD를 통한 Product 기능 개발 (테스트 코드 먼저 작성) ----
// Product.test.js (가상의 테스트 프레임워크 사용)

// describe 함수는 테스트 그룹을 정의합니다.
describe("Product", () => {
  let product; // 각 테스트 케이스 전에 초기화할 변수

  // beforeEach는 각 테스트가 실행되기 전에 호출됩니다.
  beforeEach(() => {
    // Green 단계에서 Product 클래스가 있다고 가정하고 테스트를 작성합니다.
    product = new Product(1, "Laptop", 1000);
  });

  // Red 단계: Product 객체가 올바르게 생성되는지 테스트
  test("should create a product with given id, name, and price", () => {
    expect(product.id).toBe(1);
    expect(product.name).toBe("Laptop");
    expect(product.price).toBe(1000);
  });

  // Red 단계: 가격이 음수일 때 오류를 발생시키는지 테스트
  test("should throw an error if price is negative during creation", () => {
    expect(() => new Product(2, "Invalid Item", -100)).toThrow(
      "가격은 음수가 될 수 없습니다."
    );
  });

  // Red 단계: 할인 적용 기능 테스트
  test("should apply discount correctly", () => {
    product.applyDiscount(10); // 10% 할인
    expect(product.price).toBe(900); // 1000 * 0.9
  });

  // Red 단계: 유효하지 않은 할인율에 대해 오류를 발생시키는지 테스트
  test("should throw an error for invalid discount percentage", () => {
    expect(() => product.applyDiscount(-5)).toThrow(
      "할인율은 0%에서 100% 사이여야 합니다."
    );
    expect(() => product.applyDiscount(105)).toThrow(
      "할인율은 0%에서 100% 사이여야 합니다."
    );
  });

  // Red 단계: 가격 변경 기능 테스트
  test("should change product price", () => {
    product.changePrice(1200);
    expect(product.price).toBe(1200);
  });

  // Red 단계: 변경할 가격이 음수일 때 오류를 발생시키는지 테스트
  test("should throw an error if new price is negative", () => {
    expect(() => product.changePrice(-500)).toThrow(
      "새로운 가격은 음수가 될 수 없습니다."
    );
  });
});
```

**코드 설명:**

1.  **`Product` 클래스 (DDD 관점):**
    - `id`, `name`, `price` 속성을 가지며, 가격이 음수일 수 없다는 도메인 규칙을 `constructor`에서 강제합니다.
    - `applyDiscount`와 `changePrice` 메서드는 `Product` 엔티티가 수행할 수 있는 핵심 비즈니스 로직(행위)을 정의합니다. 할인율 유효성 검사, 음수 가격 방지 등 도메인의 제약 사항을 메서드 내부에 캡슐화했습니다.
2.  **`Product.test.js` (TDD 관점):**
    - 각 `test` 블록은 `Product` 클래스의 특정 기능에 대한 기대 동작을 명시합니다.
    - `beforeEach`를 통해 각 테스트가 독립적으로 실행될 수 있도록 `product` 객체를 초기화합니다.
    - 'Red' 단계에서는 이 테스트들이 실패하도록 작성하고, 'Green' 단계에서는 `Product` 클래스의 코드를 구현하여 이 테스트들을 통과시킵니다.
    - 이후 'Refactor' 단계에서 `Product` 클래스의 코드를 개선합니다 (예: 가격 소수점 처리 등).

이 예시는 TDD가 DDD로 정의된 도메인 모델의 비즈니스 규칙과 행위를 명확하게 테스트하고 구현하는 데 어떻게 사용될 수 있는지 보여줍니다.
