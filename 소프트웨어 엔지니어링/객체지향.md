# 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)

객체 지향 프로그래밍(OOP)은 프로그램을 '객체'라는 독립적인 단위로 나누어 설계하고 구현하는 프로그래밍 패러다임입니다. 실제 세계의 사물과 개념을 소프트웨어 객체로 모델링하여, 코드의 재사용성을 높이고 유지보수를 용이하게 하며, 보다 직관적인 코드 작성을 가능하게 합니다.

## 1. 객체 지향의 핵심 개념

객체 지향 프로그래밍은 주로 다음 네 가지 핵심 개념을 기반으로 합니다.

### 1.1. 추상화 (Abstraction)

- **개념:** 복잡한 시스템의 세부 사항을 숨기고, 사용자가 필요로 하는 본질적인 정보나 기능만을 노출하는 과정입니다. 불필요한 정보는 제거하고 중요한 특성만을 간결하게 표현하여 문제 해결에 집중할 수 있도록 돕습니다.
- **예시:** 자동차를 운전할 때 엔진 내부의 복잡한 작동 방식보다는 핸들, 가속 페달, 브레이크와 같은 핵심적인 '운전' 기능에만 집중하는 것과 같습니다. 클래스나 인터페이스를 통해 구현됩니다.

### 1.2. 캡슐화 (Encapsulation)

- **개념:** 데이터(속성)와 그 데이터를 조작하는 메서드(기능)를 하나의 '객체' 안에 묶고, 외부에서는 객체 내부의 세부 구현을 직접 접근하지 못하도록 보호하는 것입니다. 데이터는 외부로부터 보호되며, 메서드를 통해서만 접근할 수 있습니다.
- **예시:** 자동차의 엔진을 덮개로 가려 외부에서 직접 만지지 못하게 하고, 시동 버튼이나 가속 페달을 통해서만 엔진을 제어하도록 하는 것과 같습니다. 이는 데이터 무결성을 유지하고, 코드 변경의 영향을 최소화하는 데 도움을 줍니다.

### 1.3. 상속 (Inheritance)

- **개념:** 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용하는 메커니즘입니다. 이를 통해 코드의 중복을 줄이고, 확장성을 높일 수 있습니다. 자식 클래스는 부모 클래스의 기능을 그대로 사용하거나, 필요에 따라 기능을 확장하거나 재정의할 수 있습니다.
- **예시:** '동물'이라는 부모 클래스가 '이름'이라는 속성과 '먹기()'라는 메서드를 가지고 있다면, '강아지'와 '고양이' 같은 자식 클래스는 이들을 상속받아 사용할 수 있습니다. 또한, '강아지'는 '짖기()'라는 자신만의 새로운 메서드를 추가할 수 있습니다.

### 1.4. 다형성 (Polymorphism)

- **개념:** 하나의 객체나 메서드가 상황에 따라 여러 가지 형태로 동작하는 능력입니다. 즉, 동일한 이름의 메서드가 다른 클래스 또는 다른 컨텍스트에서 다양한 방식으로 구현될 수 있음을 의미합니다.
- **예시:** '동물' 클래스의 '소리내기()' 메서드를 '강아지' 클래스에서는 '멍멍'으로, '고양이' 클래스에서는 '야옹'으로 다르게 구현할 수 있습니다. 각 객체는 자신의 타입에 맞는 '소리내기()' 동작을 수행합니다.

## 2. 객체 지향 설계 원칙 (SOLID)

객체 지향 시스템을 잘 설계하기 위한 다섯 가지 원칙을 SOLID 원칙이라고 합니다.

- **S (Single Responsibility Principle, 단일 책임 원칙):** 하나의 클래스는 하나의 책임만 가져야 합니다.
- **O (Open/Closed Principle, 개방-폐쇄 원칙):** 확장에 대해서는 열려 있어야 하고, 변경에 대해서는 닫혀 있어야 합니다.
- **L (Liskov Substitution Principle, 리스코프 치환 원칙):** 부모 클래스가 사용되는 곳에 자식 클래스를 대체해도 시스템이 정상적으로 동작해야 합니다.
- **I (Interface Segregation Principle, 인터페이스 분리 원칙):** 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 됩니다. 즉, 인터페이스를 작고 구체적으로 분리해야 합니다.
- **D (Dependency Inversion Principle, 의존성 역전 원칙):** 고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 다 추상화에 의존해야 합니다. 추상화는 세부 사항에 의존해서는 안 됩니다. 세부 사항이 추상화에 의존해야 합니다.

## 3. 장점

- **코드 재사용성 증가:** 상속을 통해 기존 코드를 재사용하고, 중복을 줄일 수 있습니다.
- **유지보수 용이:** 캡슐화를 통해 객체 내부 구현이 변경되어도 외부에는 영향을 미치지 않으므로 유지보수가 쉽습니다.
- **생산성 향상:** 모듈화된 객체를 재활용하여 개발 시간을 단축할 수 있습니다.
- **확장성 증대:** 새로운 기능을 추가할 때 기존 코드의 수정 없이 확장이 용이합니다.
- **직관적인 모델링:** 실제 세계를 객체로 모델링하여 문제 해결에 대한 이해도를 높일 수 있습니다.

## 4. 단점

- **설계의 어려움:** 처음부터 객체와 관계를 잘 설계하는 것이 어렵고, 잘못된 설계는 오히려 복잡도를 증가시킬 수 있습니다.
- **성능 오버헤드:** 런타임 시 객체 간의 통신 비용이나 메모리 사용량이 증가할 수 있습니다.
- **학습 곡선:** 객체 지향 개념을 이해하고 적용하는 데 시간이 필요합니다.

## 5. 예제 코드 (JavaScript)

JavaScript는 프로토타입 기반의 객체 지향 언어이지만, 클래스 문법(ES6부터)을 통해 객체 지향의 개념을 구현할 수 있습니다.

```javascript
// 1. 클래스 정의 (추상화, 캡슐화)
class Animal {
  constructor(name, sound) {
    this.name = name; // 데이터 (속성)
    this.sound = sound;
  }

  makeSound() {
    // 메서드 (기능)
    console.log(`${this.name}가 ${this.sound} 소리를 냅니다.`);
  }

  // 외부에서 직접 접근하기 어려운 private 속성처럼 동작하도록
  // #을 사용하는 Private Class Fields 제안이 있지만, 여기서는 Convention으로 _ 사용
  _privateMethod() {
    console.log("이것은 내부 메서드입니다.");
  }
}

// 2. 상속 (Inheritance)
class Dog extends Animal {
  constructor(name, breed) {
    super(name, "멍멍"); // 부모 클래스 Animal의 constructor 호출
    this.breed = breed;
  }

  // 메서드 오버라이딩 (다형성)
  makeSound() {
    console.log(
      `${this.name} (${this.breed})가 왕왕 ${this.sound} 소리를 냅니다!`
    );
  }

  // 새로운 메서드 추가
  fetch() {
    console.log(`${this.name}가 공을 가져옵니다.`);
  }
}

class Cat extends Animal {
  constructor(name, color) {
    super(name, "야옹");
    this.color = color;
  }

  // 메서드 오버라이딩 (다형성)
  makeSound() {
    console.log(
      `${this.name} (${this.color})가 조용히 ${this.sound} 소리를 냅니다.`
    );
  }
}

// 3. 객체 생성 및 다형성 활용
const animal1 = new Animal("새", "짹짹");
const dog1 = new Dog("바둑이", "진돗개");
const cat1 = new Cat("나비", "삼색");

animal1.makeSound(); // 출력: 새가 짹짹 소리를 냅니다.
dog1.makeSound(); // 출력: 바둑이 (진돗개)가 왕왕 멍멍 소리를 냅니다!
cat1.makeSound(); // 출력: 나비 (삼색)가 조용히 야옹 소리를 냅니다.

dog1.fetch(); // 출력: 바둑이가 공을 가져옵니다.

// 다형성의 또 다른 예시: 배열에 다양한 Animal 객체를 담고 동일한 메서드 호출
const animals = [animal1, dog1, cat1];

for (const animal of animals) {
  animal.makeSound();
}
// 출력:
// 새가 짹짹 소리를 냅니다.
// 바둑이 (진돗개)가 왕왕 멍멍 소리를 냅니다!
// 나비 (삼색)가 조용히 야옹 소리를 냅니다.
```

**코드 설명:**

1.  **`Animal` 클래스:** `name`과 `sound`라는 속성을 가지고 `makeSound`라는 메서드를 가집니다. 이는 동물의 일반적인 특징을 **추상화**한 것이며, 속성과 메서드를 함께 묶어 **캡슐화**했습니다.
2.  **`Dog`와 `Cat` 클래스:** `Animal` 클래스를 **상속**받아 `makeSound` 메서드를 각자의 방식으로 **재정의(오버라이딩)**하여 **다형성**을 보여줍니다. `Dog` 클래스는 `fetch`라는 자신만의 고유한 메서드를 추가했습니다.
3.  **객체 생성 및 활용:** `Animal`, `Dog`, `Cat` 객체를 생성하고 `makeSound` 메서드를 호출하면 각 객체의 타입에 맞는 다른 동작을 수행하는 **다형성**의 예시를 볼 수 있습니다. `animals` 배열에 다양한 타입의 객체를 담아 동일한 `makeSound()` 메서드를 호출해도 각 객체가 자신의 타입에 맞는 행동을 합니다.
