## Vue 3 Composition API

### setup() 함수

`setup()` 함수는 Vue 3의 Composition API를 사용하는 컴포넌트의 진입점(Entry Point)입니다.

- 컴포넌트 인스턴스가 생성될 때 `beforeCreate` 훅 직후에 실행됩니다
- 이 시점에는 아직 컴포넌트 인스턴스(`this`)가 완전히 초기화되지 않았기 때문에, `setup()` 내부에서는 `this`에 접근할 수 없습니다
- 주요 역할은 컴포넌트의 반응성 상태, 연산, 라이프사이클 훅 등을 설정하고 이를 템플릿에 노출시키는 것입니다
- `setup()` 함수는 객체를 반환하며, 이 객체에 포함된 모든 속성(변수, 함수 등)은 템플릿과 나머지 옵션 API(사용하는 경우)에서 사용할 수 있게 노출됩니다

#### setup() 예제

```javascript
import { ref, computed, onMounted } from "vue";

export default {
  setup() {
    const count = ref(0);

    const increment = () => {
      count.value++;
    };

    onMounted(() => {
      console.log("컴포넌트가 마운트되었습니다.");
    });

    return {
      count,
      increment,
    };
  },
};
```

### 반응성 API

Vue 3의 반응성 시스템은 Proxy 객체를 기반으로 하여 데이터 변경을 효율적으로 추적하고 DOM 업데이트를 트리거합니다.

| API          | 목적                                                             | 데이터 타입                                   | 접근 방식                                               | 주요 용도                            |
| ------------ | ---------------------------------------------------------------- | --------------------------------------------- | ------------------------------------------------------- | ------------------------------------ |
| `ref()`      | 단일 값을 반응형으로 만듭니다                                    | 원시 타입 (string, number, boolean) 또는 객체 | `.value` 속성을 통해 접근 및 변경                       | 카운터, 텍스트 입력, 상태 플래그     |
| `reactive()` | 객체나 배열을 반응형 프록시 객체로 만듭니다                      | 객체 (Object, Array)                          | 일반 JavaScript 객체처럼 직접 접근                      | 복잡한 폼 데이터, 중첩된 구조의 상태 |
| `computed()` | 기존 반응형 데이터를 기반으로 새로운 반응형 값을 파생시킵니다    | 모든 타입                                     | `.value`를 통해 읽기 전용으로 접근 (Getter/Setter 가능) | 파생 데이터 계산, 복잡한 필터링      |
| `watch()`    | 반응형 상태가 변경될 때 특정 부수 효과(Side Effect)를 실행합니다 | ref, reactive, computed                       | 콜백 함수 실행                                          | 비동기 데이터 페칭, 디버깅, DOM 조작 |

### 컴포저블 (Composables)

컴포저블은 로직 재사용을 위해 디자인된 Composition API 함수입니다. React의 커스텀 훅(Custom Hook)과 유사한 개념입니다.

### 컴포저블의 특징

- 특정 기능을 수행하는 상태 저장 로직(stateful logic)을 컴포넌트로부터 추출하여 별도의 함수로 만듭니다
- 이 함수를 여러 컴포넌트에서 가져와(import) 사용할 수 있게 하여 코드 중복을 줄이고 로직을 기능별로 응집시킵니다
- 함수 이름은 관례적으로 `use`로 시작하고 Composition API를 사용하여 상태와 로직을 정의합니다
- 함수는 외부에 노출되어야 할 상태와 메서드를 객체 형태로 반환합니다

#### 컴포저블 예제

```javascript
// useMousePosition.js (컴포저블)
import { ref, onMounted, onUnmounted } from "vue";

export function useMousePosition() {
  const x = ref(0);
  const y = ref(0);

  const update = (e) => {
    x.value = e.pageX;
    y.value = e.pageY;
  };

  onMounted(() => window.addEventListener("mousemove", update));
  onUnmounted(() => window.removeEventListener("mousemove", update));

  return { x, y };
}

// MyComponent.vue (사용)
import { useMousePosition } from "./useMousePosition";

export default {
  setup() {
    const { x, y } = useMousePosition();
    return { x, y };
  },
};
```
