## SFC (Single File Component)

### 개요

Vue에서 SFC (Single File Component)는 하나의 파일(.vue 확장자) 안에 컴포넌트의 템플릿, 스크립트(로직), 스타일을 모두 담는 파일 형식입니다. 이는 Vue 개발의 핵심이자 표준 방식으로, 컴포넌트의 관심사 분리(Separation of Concerns)를 직관적으로 구현할 수 있게 해줍니다.

SFC는 다음과 같은 세 가지 주요 블록으로 구성됩니다:

- **`<template>`**: 컴포넌트의 마크업(HTML 구조)과 렌더링 로직을 정의합니다.
- **`<script>`**: 컴포넌트의 로직(JavaScript/TypeScript), 즉 데이터, 메서드, 라이프사이클 훅 등을 정의합니다.
- **`<style>`**: 컴포넌트의 스타일(CSS/SCSS)을 정의합니다. `scoped` 속성을 추가하면 해당 컴포넌트에만 스타일이 적용됩니다.

이 방식은 컴포넌트의 모든 요소가 하나의 파일에 응집되어 있어 관리가 매우 편리하며, 빌드 도구(Vite, Webpack)를 통해 표준 JavaScript 모듈로 변환되어 실행됩니다.

### script setup

Vue 3에서는 Composition API를 더 간결하게 사용하기 위해 `<script>` 태그에 `setup` 속성을 추가하는 방식이 도입되었습니다. `<script setup>`을 사용하면 별도의 `setup()` 함수를 명시적으로 정의하고 값을 `return`할 필요 없이, 내부에서 선언된 모든 최상위 바인딩(변수, 함수, import 등)이 자동으로 컴포넌트의 템플릿에 노출됩니다.

```javascript
<template>
  <button @click="increment">카운트: {{ count }}</button>
  <p>이름: {{ user.name }}</p>
</template>

<script setup>
import { ref, reactive, onMounted } from "vue";

const count = ref(0);
const user = reactive({ name: "Vue User" });

const increment = () => {
  count.value++;
};

onMounted(() => {
  console.log("컴포넌트 마운트됨");
});
</script>

<style scoped>
</style>
```

### `<script setup>` vs Options API 비교

`<script setup>` 방식은 Options API 대비 간결성과 효율성 모두에서 우위를 가집니다.

| 구분              | `<script setup>` 방식 (Composition API)                                | Options API 방식 (Vue 2/3)                                                    |
| :---------------- | :--------------------------------------------------------------------- | :---------------------------------------------------------------------------- |
| **코드 간결성**   | `setup` 로직을 `return`할 필요가 없음 (생략).                          | `data`, `methods`, `computed` 객체 안에 로직을 분산시켜야 함.                 |
| **로직 응집성**   | 특정 기능(예: 카운터 로직) 관련 코드가 한 곳에 모여 수직적으로 배치됨. | 동일 기능 로직이 파일 내 여러 옵션(예: `data`와 `methods`)에 분산됨.          |
| **초기화 과정**   | `import`된 컴포넌트가 바로 사용 가능하며, 추가 등록 과정 불필요.       | 컴포넌트를 사용하기 위해 `components: { ... }` 옵션에 명시적으로 등록해야 함. |
| **런타임 효율성** | 컴파일러 최적화가 용이하여, 런타임 오버헤드가 적고 더 효율적입니다.    | 런타임에 옵션 객체를 병합하고 처리해야 하는 오버헤드가 있습니다.              |
