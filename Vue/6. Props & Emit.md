## Props & Emit

### 개요

Vue에서 `Props`와 `Emit`은 컴포넌트 간의 단방향 데이터 흐름을 구현하는 기본적인 메커니즘입니다. 이를 통해 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하고, 자식 컴포넌트에서 부모 컴포넌트로 이벤트를 발생시켜 통신할 수 있습니다.

### Props (속성): 데이터 내리기

`Props`는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 데 사용됩니다. 이는 Vue의 단방향 데이터 흐름 원칙을 구현하는 핵심입니다.

### 작동 방식 및 특징

- **정의**: 자식 컴포넌트에서 `defineProps`를 사용하여 받을 데이터의 이름, 타입, 필수 여부 등을 정의합니다.
- **전달**: 부모 컴포넌트에서는 자식 태그에 데이터를 `v-bind` 디렉티브 또는 축약형 `:`를 사용하여 `Prop`으로 바인딩하여 전달합니다. 이 때 반응형 데이터를 전달하면 자식 컴포넌트에서도 해당 데이터가 변경될 때마다 반응적으로 업데이트됩니다.
- **단방향 흐름**: 자식 컴포넌트는 받은 `Prop` 값을 직접 변경할 수 없습니다. 만약 변경해야 한다면, 부모에게 이벤트를 발생시켜 부모가 값을 변경하도록 요청해야 합니다.

#### 예시 (Composition API)

**ChildComponent.vue**

```javascript
<script setup>
const props = defineProps({
  message: {
    type: String,
    required: true,
  },
});
</script>

<template>
  <p>부모에게 받은 메시지: {{ props.message }}</p>
</template>
```

**ParentComponent.vue (부모 컴포넌트)**

```javascript
<template>
  <ChildComponent message="안녕하세요, 자식 컴포넌트!" />

  <!-- v-bind -->
  <ChildComponent :message="parentMessage" />
</template>

<script setup>
import { ref } from "vue";
import ChildComponent from "./ChildComponent.vue";

const parentMessage = ref("부모의 반응형 메시지");
</script>
```

### defineProps 호이스팅(Hoisting)과 스코프 충돌

`defineProps`는 일반적인 JavaScript 함수 호출이 아니라, 컴파일러에게 지시하는 특수한 매크로라는 점이 핵심입니다.

#### 1. `setup()` 함수의 역할 (런타임)

`<script setup>` 블록의 코드는 최종적으로 컴포넌트의 `setup()` 함수 안에 래핑됩니다. 이 `setup()` 함수는 컴포넌트 인스턴스가 생성될 때마다 (즉, 런타임에) 실행되는 일반적인 JavaScript 함수입니다.

```javascript
export default {
  props: { /* defineProps 결과 */ },
  setup(props, context) {
    const validTypes = ['primary', 'ghost', ...];
  }
}
```

#### 2. `defineProps`의 호이스팅 (컴파일 타임)

`defineProps()` 매크로의 목적은 컴포넌트의 `props` 옵션 객체를 정의하는 것입니다.

이 `props` 옵션은 컴포넌트 정의의 일부이며, 컴포넌트가 등록되는 시점 (모듈 스코프)에 한 번만 정의되어야 합니다. 매번 인스턴스가 생성될 때마다 재정의할 필요가 없습니다.

따라서 Vue 컴파일러는 `defineProps(...)` 호출 부분을 런타임 `setup()` 함수 밖으로 끌어올려 최종 컴포넌트 옵션 객체 (`export default { props: ... }`)에 포함시킵니다.

#### 3. 스코프 충돌 (오류 발생 지점)

`defineProps`가 `setup()` 밖으로 끌어올려질 때, 그 안에 있는 코드는 모듈 스코프에서 실행된다고 간주됩니다.

```javascript
defineProps({
  validator: (value) => {
    return validTypes.includes(value); // <-- 모듈 스코프에서 실행되지만,
    // validTypes는 setup() 안에 갇혀있음
  },
});
```

`validator` 함수가 `validTypes`를 참조하지만, `validTypes`는 `setup()` 함수가 실행될 때 (즉, 나중에) 정의되도록 예약되어 있으므로, 컴파일러는 지금 당장 찾을 수 없다고 판단하고 오류를 발생시키는 것입니다.

#### 해결책: 분리된 `<script>` 블록의 역할

이 문제를 해결하기 위해 일반 `<script>` 블록을 사용하는 것이 권장되는 이유입니다.

일반 `<script>` 블록에 정의된 변수와 함수는 `setup()` 함수 외부의 모듈 스코프에 존재합니다.

따라서 `defineProps`가 호이스팅되어 모듈 스코프에서 실행될 때, 이 변수들(예: `export const VALID_TYPES`)을 안전하게 참조할 수 있게 되어 충돌이 해결됩니다.

### 양방향 바인딩: `v-model`

`v-model` 디렉티브는 양방향 데이터 흐름을 구현하는 데 활용될 수 있습니다. `v-model`은 사실상 `v-bind`와 `v-on` 이벤트 리스너의 축약형(Syntactic Sugar)입니다.

#### `v-model`과 `v-bind`의 차이점

| 구분            | `v-bind` (단방향)               | `v-model` (양방향)                                                                 |
| :-------------- | :------------------------------ | :--------------------------------------------------------------------------------- |
| **데이터 흐름** | 부모 → 자식 (단방향)            | 부모 ↔ 자식 (양방향)                                                               |
| **사용 목적**   | 데이터 표시, 속성 전달          | 폼 입력 동기화, 컴포넌트 간 양방향 상태 관리                                       |
| **작동 원리**   | `:propName="data"`              | `:modelValue="data"` + `@update:modelValue="data = $event"`                        |
| **컴포넌트**    | `defineProps`로 `propName` 정의 | `defineProps`로 `modelValue` 정의, `defineEmits`로 `update:modelValue` 이벤트 정의 |

### Emit (이벤트): 데이터 올리기

`Emit`은 자식 컴포넌트에서 부모 컴포넌트로 메시지 또는 데이터를 전달하는 데 사용됩니다. 자식은 이벤트를 발생(emit)시키고, 부모는 이를 수신(listen)하여 상태를 업데이트합니다. 여기서, 카멜 케이스의 emit 이벤트를 케밥 케이스로 작성하는 이유는 HTML 표준 및 DOM 이벤트 이름과의 호환성을 보장하기 위함입니다.

`v-model`은 내부적으로 `modelValue`라는 `prop`과 `update:modelValue`라는 `emit` 이벤트를 사용하여 양방향 바인딩을 구현합니다. 따라서 `v-model`을 컴포넌트에 적용하는 것은 `v-bind`로 `modelValue` `prop`을 전달하고 `update:modelValue` 이벤트를 수신하는 것과 같습니다.

#### 작동 방식 및 특징

- **정의**: 자식 컴포넌트에서 `defineEmits`를 사용하여 발생시킬 이벤트 이름을 정의합니다.
- **발생**: `emit` 함수를 호출하여 이벤트를 발생시키고, 필요한 데이터는 인수로 함께 전달합니다.
- **수신**: 부모 컴포넌트는 자식 태그에 `@이벤트명` 형식으로 리스너를 등록하고, 이벤트를 수신하면 등록된 메서드를 실행합니다.

### `v-model`을 이용한 양방향 통신 예시

**ChildInput.vue**

```javascript
<script setup>
const props = defineProps({
  modelValue: String, // v-model 사용 시 기본 Prop 이름은 modelValue
});

const emit = defineEmits(["update:modelValue"]); // v-model 사용 시 기본 Emit 이벤트 이름은 update:modelValue

const onInput = (event) => {
  emit("update:modelValue", event.target.value);
};
</script>

<template>
  <input :value="props.modelValue" @input="onInput" />
</template>
```

**ParentComponent.vue**

```javascript
<template>
  <p>부모의 입력 값: {{ parentText }}</p>
  <ChildInput v-model="parentText" />
</template>

<script setup>
import { ref } from "vue";
import ChildInput from "./ChildInput.vue"; // ChildInput 경로에 맞게 수정

const parentText = ref("초기 값");
</script>
```
