## 전역 상태 관리

### `provide` / `inject`: Vue 내장 전역 상태 관리

Vue에서 `provide`와 `inject`는 부모 컴포넌트(제공자)가 자신을 포함한 모든 하위 컴포넌트(소비자)에게 데이터를 제공할 수 있는 기능을 제공합니다. 이는 컴포넌트 트리를 깊이 내려가면서 `prop`을 일일이 전달할 필요 없이, 원하는 시점에 데이터를 주입받을 수 있게 해주는 패턴입니다. 주로 데이터나 함수를 깊은 계층의 자식에게 전달할 때 **Prop Drilling** 문제를 해결하는 데 유용합니다.

#### 작동 방식 및 원리

- **`provide(key, value)`**: 부모 컴포넌트에서 `provide` 함수를 사용하여 특정 `key`로 `value`를 제공합니다. `value`는 원시값, 객체, 함수 등 어떤 형태도 될 수 있습니다. 반응성을 유지하려면 `ref`나 `reactive`로 감싼 데이터를 제공해야 합니다.
- **`inject(key, defaultValue)`**: 하위 컴포넌트에서 `inject` 함수를 사용하여 `provide`된 `key`에 해당하는 `value`를 주입받습니다. `defaultValue`는 선택 사항이며, 해당 `key`로 제공된 값이 없을 때 사용됩니다.

`provide`와 `inject`는 Vue의 반응성 시스템과 통합되어 작동합니다. `provide`된 반응형 데이터가 변경되면, `inject`를 통해 해당 데이터를 주입받은 모든 하위 컴포넌트는 자동으로 업데이트됩니다.

#### 예시: `provide` / `inject`를 이용한 전역 상태 관리

**App.vue (최상위 컴포넌트 - 데이터 제공자)**

```vue
<script setup>
import { ref, provide } from "vue";

const count = ref(0);
const increment = () => {
  count.value++;
};

provide("appCount", count);
provide("appIncrement", increment);
</script>
```

**ChildComponent.vue (하위 컴포넌트 - 데이터 소비자)**

```vue
<script setup>
import { inject } from "vue";

const injectedCount = inject("appCount");
const injectedIncrement = inject("appIncrement");
</script>
```

### 왜 Pinia를 사용할까?

`provide`와 `inject`는 간단한 컴포넌트 간의 데이터 전달에 유용하지만, 복잡하고 규모가 큰 애플리케이션의 전역 상태 관리에는 다음과 같은 한계점이 있습니다.

#### `provide` / `inject`의 한계

- **디버깅의 어려움**: 데이터가 컴포넌트 트리를 통해 명시적으로 흐르는 것이 아니기 때문에, 어떤 컴포넌트가 어떤 데이터를 `provide`하고 `inject`하는지 추적하기 어렵습니다. Vue Devtools에서도 `provide` / `inject`된 상태를 시각적으로 추적하기 어렵습니다.
- **구조화 및 일관성 부족**: `provide` / `inject`는 상태 관리 패턴을 강제하지 않습니다. 개발자가 직접 상태 변경 로직과 규칙을 만들어야 하므로, 팀 프로젝트나 대규모 애플리케이션에서는 상태 관리의 일관성이 떨어지고 유지보수가 어려워질 수 있습니다.
- **확장성 한계**: 애플리케이션의 규모가 커지고 전역 상태의 종류가 많아질수록, `key` 관리나 상태 분할, 모듈화 등의 작업이 복잡해집니다.
- **TypeScript 지원 부족**: `provide` / `inject`는 기본적으로 `key`와 `value`에 대한 타입 추론이 약해, TypeScript 환경에서 안전하게 사용하기 위해 추가적인 타입 선언이 필요합니다.

요약하자면, `provide` / `inject`는 간단한 데이터 전달에 편리하지만, 애플리케이션의 규모가 커질수록 Pinia가 제공하는 강력한 도구, 구조화된 패턴, 디버깅 기능, 그리고 TypeScript 지원이 필수적입니다.

### Pinia: Vue 공식 전역 상태 관리

**Pinia**는 Vuex의 단점을 개선하고 Vue 3의 Composition API에 최적화되어 개발된 Vue 애플리케이션의 공식 전역 상태 관리 라이브러리입니다. Pinia는 다음과 같은 명확한 이점을 제공합니다.

- **단순화된 구조 (Mutations 제거)**: Vuex는 상태 변경을 위해 `Mutations`를 강제했지만, Pinia는 이 계층을 제거하여 Actions 내에서 직접 상태를 변경할 수 있게 합니다. 이는 코드의 복잡성을 크게 줄여줍니다.
- **TypeScript 지원 강화 (Type Safety)**: Pinia는 코어부터 TypeScript를 염두에 두고 설계되어, 상태(State), Getter, Action에 대한 완벽한 타입 추론을 제공합니다. 이는 대규모 애플리케이션의 안정성과 개발 경험을 크게 향상시킵니다.
- **모듈화 기본 (No Namespacing Headaches)**: Pinia는 모든 Store가 기본적으로 모듈화되어 있으며, Vuex의 복잡했던 네임스페이스(Namespacing) 옵션을 사용할 필요가 없어졌습니다. 각 Store가 독립적으로 작동합니다.
- **더 가벼움**: Pinia의 코어는 Vuex보다 훨씬 가벼우며, 최소한의 API만 제공하여 러닝 커브가 낮습니다.

#### Pinia의 작동 원리

Pinia의 작동 원리는 Vue 3의 반응성(Reactivity) 시스템을 기반으로 합니다.

- **Store 생성**: `defineStore` 함수를 사용하여 Store를 정의하면, Pinia는 내부적으로 이 Store를 Vue의 반응성 시스템(`reactive()`)을 통해 감싸서 만듭니다.
- **데이터 접근**: 컴포넌트에서 `useStore()`와 같은 형태로 Store에 접근하면, Vue는 해당 Store의 모든 속성(State, Getter)에 대한 반응성 연결(Reactivity Connection)을 설정합니다.
- **상태 변경 감지**: 컴포넌트나 Action에서 Store의 State를 변경하면, Pinia는 Vue의 반응성 메커니즘을 통해 변경을 감지하고, 해당 상태를 사용하고 있는 모든 컴포넌트를 자동으로 업데이트합니다.

#### Pinia의 기본 구조 (State, Getters, Actions)

Pinia Store는 `defineStore` 함수를 사용하여 정의됩니다. `Option Store` (Vuex와 유사) 또는 `Setup Store` (Composition API와 유사) 두 가지 방식으로 정의할 수 있으며, 가장 일반적인 `Option Store`의 기본 구조는 다음과 같습니다.

```javascript
import { defineStore } from "pinia";

// 'counter'는 이 Store의 고유 ID이며 필수입니다.
export const useCounterStore = defineStore("counter", {
  state: () => ({
    count: 0,
    name: "Pinia User",
    isAdmin: true,
  }),

  getters: {
    doubleCount: (state) => state.count * 2,
    isAdminInfo() {
      return this.name + (this.isAdmin ? " (Admin)" : " (Guest)");
    },
  },

  actions: {
    increment() {
      this.count++;
    },

    // 비동기 처리 가능
    async waitAndIncrement() {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      this.count++;
    },
  },
});
```

#### 스토어에서 데이터 접근 및 변경

Pinia는 컴포넌트 내부에서 Store를 사용할 때도 Composition API의 훅처럼 작동하여 코드를 간결하게 만듭니다.

#### 1. 컴포넌트에서 Store 사용

| 작업                | Composition API 방식               | 설명                                             |
| :------------------ | :--------------------------------- | :----------------------------------------------- |
| **Store 사용**      | `const store = useCounterStore();` | `defineStore`에서 정의한 함수를 호출합니다.      |
| **Getter 접근**     | `store.doubleCount`                | Getter는 읽기 전용 속성처럼 접근합니다.          |
| **Action 호출**     | `store.increment()`                | Action은 메서드처럼 호출하여 상태를 변경합니다.  |
| **State 직접 접근** | `store.count`                      | State에 직접 접근하여 읽거나 변경할 수 있습니다. |

#### 2. State 해체 시 반응성 유지

`const { count } = store;`와 같이 State를 구조 분해(Destructuring)하면 반응성을 잃습니다. 반응성을 유지하며 State를 해체하려면 `storeToRefs` 유틸리티를 사용해야 합니다.

```javascript
import { storeToRefs } from "pinia";
import { useCounterStore } from "./stores/counter";

export default {
  setup() {
    const store = useCounterStore();
    // State와 Getter를 해체하여 반응성 있게 사용
    const { count, doubleCount } = storeToRefs(store);
    const { increment } = store;

    return {
      count,
      doubleCount,
      increment,
    };
  },
};
```
