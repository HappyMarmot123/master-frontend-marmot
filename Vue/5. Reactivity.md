## Vue 반응성 (Reactivity)

Vue의 반응성 시스템은 데이터의 변경을 감지하고, 이 변경을 사용하는 모든 곳(주로 DOM)을 자동으로 업데이트하는 핵심 메커니즘입니다. Vue 3에서는 JavaScript의 `Proxy` 객체를 기반으로 작동하여 빠른 반응성을 제공합니다.

### Vue 3 반응성 시스템의 원리

Vue 3의 반응성 시스템은 데이터를 반응형 객체(`Proxy`)로 변환하여 작동합니다.

- **관찰 (Observe)**: Vue 인스턴스가 생성될 때, `ref()`나 `reactive()`를 통해 정의된 JavaScript 객체는 `Proxy`로 감싸집니다.
- **추적 (Track)**: 컴포넌트가 렌더링될 때, Vue는 해당 컴포넌트가 `Proxy` 객체의 어떤 속성을 읽는지를 자동으로 기록합니다 (이를 의존성 수집이라고 합니다).
- **알림 (Trigger)**: 이후 해당 `Proxy` 객체의 속성 값이 변경되면, `Proxy`가 변경을 가로채어 Vue에게 알립니다.
- **업데이트 (Update)**: Vue는 이전에 기록된 의존성 목록을 확인하여 해당 변경을 사용했던 모든 컴포넌트를 식별하고 효율적으로 재렌더링합니다.

### 반응형 API와 반응성 유지/손실 방법

Vue의 반응형 API를 사용할 때, 데이터의 형태와 접근 방식에 따라 반응성을 잃거나 유지하는 방법이 다릅니다.

### 1. `ref()` (원시값 및 단일 객체)

`ref()`는 주로 원시값이나 단일 객체를 반응형으로 만들 때 사용합니다. `ref`는 `.value` 속성을 통해 값에 접근해야 반응성이 유지됩니다.

| 구분     | 방법                                 | 반응성 결과        | 설명                                                                                  |
| :------- | :----------------------------------- | :----------------- | :------------------------------------------------------------------------------------ |
| **유지** | 템플릿에서 직접 사용 (`{{ count }}`) | 유지 (자동 언래핑) | 템플릿은 `ref`의 `.value`에 자동으로 접근합니다.                                      |
| **유지** | 로직에서 `.value`를 통해 접근        | 유지               | `ref`의 값을 읽거나 변경할 때는 반드시 `.value`를 사용해야 추적됩니다.                |
| **손실** | `ref`를 구조 분해 할당               | 손실               | `const { value } = myRef;`는 `ref` 객체가 아닌 내부 값을 복사하여 일반 변수가 됩니다. |

### 2. `reactive()` (객체 및 배열)

`reactive()`는 객체나 배열을 반응형으로 만들 때 사용합니다. `reactive` 객체는 `Proxy`로 감싸지므로, 속성에 직접 접근하여 반응성을 유지할 수 있습니다.

| 구분     | 방법                             | 반응성 결과 | 설명                                                                                                                                                       |
| :------- | :------------------------------- | :---------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **유지** | 속성에 직접 접근 (`user.name`)   | 유지        | `reactive` 객체는 일반 객체처럼 사용하며, Vue가 `Proxy`를 통해 모든 접근을 추적합니다.                                                                     |
| **손실** | `reactive` 객체를 구조 분해 할당 | 손실        | `const { name } = user;`는 `user.name`의 현재 값을 복사한 일반 변수가 되며, 원본 변경을 추적하지 못합니다.                                                 |
| **유지** | `toRefs()`를 사용하여 구조 분해  | 유지        | `toRefs()`는 `reactive` 객체의 모든 속성을 개별적인 `ref`로 변환하여 반환합니다. 이를 해체하면 `.value` 없이 템플릿에서 사용 가능하며 반응성이 유지됩니다. |

**`toRefs` 사용 예시 (반응성 유지)**

```javascript
import { reactive, toRefs } from "vue";

const state = reactive({ count: 0, name: "Vue" });
const { count, name } = toRefs(state);

// 이제 count와 name은 개별 ref 객체이므로, 템플릿에서 반응성이 유지됩니다.
// 로직에서 사용할 때는 .value를 통해 접근해야 합니다 (예: count.value++)
```

### 3. Pinia Store (State)

Pinia Store의 `State`도 `reactive` 객체이므로, 일반 `reactive`와 동일한 규칙이 적용됩니다. 하지만 Pinia에서는 `State`를 구조 분해할 때 `storeToRefs()` 유틸리티를 사용하여 반응성을 유지하는 것을 권장합니다.

| 구분     | 방법                                | 반응성 결과 | 설명                                                                                   |
| :------- | :---------------------------------- | :---------- | :------------------------------------------------------------------------------------- |
| **손실** | Store를 직접 해체                   | 손실        | `const { count } = store;`는 단순한 값 복사입니다.                                     |
| **유지** | `storeToRefs()`를 사용하여 해체     | 유지        | Pinia 전용 유틸리티로, `State`와 `Getter` 속성을 `ref`로 변환하여 반응성을 유지합니다. |
| **유지** | Store 객체 전체를 반환 후 속성 접근 | 유지        | `return { store }` 후 템플릿에서 `{{ store.count }}`로 접근하면 반응성 유지.           |
