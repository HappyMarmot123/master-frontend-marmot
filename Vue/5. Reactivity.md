## Vue 반응성 (Reactivity)

Vue의 반응성 시스템은 데이터의 변경을 감지하고, 이 변경을 사용하는 모든 곳(주로 DOM)을 자동으로 업데이트하는 핵심 메커니즘입니다. Vue 3에서는 JavaScript의 `Proxy` 객체를 기반으로 작동하여 빠른 반응성을 제공합니다.

### Vue 3 반응성 시스템의 원리

Vue 3의 반응성 시스템은 데이터를 반응형 객체(`Proxy`)로 변환하여 작동합니다.

- **관찰 (Observe)**: Vue 인스턴스가 생성될 때, `ref()`나 `reactive()`를 통해 정의된 JavaScript 객체는 `Proxy`로 감싸집니다.
- **추적 (Track)**: 컴포넌트가 렌더링될 때, Vue는 해당 컴포넌트가 `Proxy` 객체의 어떤 속성을 읽는지를 자동으로 기록합니다 (이를 의존성 수집이라고 합니다).
- **알림 (Trigger)**: 이후 해당 `Proxy` 객체의 속성 값이 변경되면, `Proxy`가 변경을 가로채어 Vue에게 알립니다.
- **업데이트 (Update)**: Vue는 이전에 기록된 의존성 목록을 확인하여 해당 변경을 사용했던 모든 컴포넌트를 식별하고 효율적으로 재렌더링합니다.

### 반응형 API와 반응성 유지/손실 방법

Vue의 반응형 API를 사용할 때, 데이터의 형태와 접근 방식에 따라 반응성을 잃거나 유지하는 방법이 다릅니다.

### 1. `ref()` (원시값 및 단일 객체)

`ref()`는 주로 원시값이나 단일 객체를 반응형으로 만들 때 사용합니다. `ref`는 `.value` 속성을 통해 값에 접근해야 반응성이 유지됩니다.

| 구분     | 방법                                 | 반응성 결과        | 설명                                                                                  |
| :------- | :----------------------------------- | :----------------- | :------------------------------------------------------------------------------------ |
| **유지** | 템플릿에서 직접 사용 (`{{ count }}`) | 유지 (자동 언래핑) | 템플릿은 `ref`의 `.value`에 자동으로 접근합니다.                                      |
| **유지** | 로직에서 `.value`를 통해 접근        | 유지               | `ref`의 값을 읽거나 변경할 때는 반드시 `.value`를 사용해야 추적됩니다.                |
| **손실** | `ref`를 구조 분해 할당               | 손실               | `const { value } = myRef;`는 `ref` 객체가 아닌 내부 값을 복사하여 일반 변수가 됩니다. |

### 2. `reactive()` (객체 및 배열)

`reactive()`는 객체나 배열을 반응형으로 만들 때 사용합니다. `reactive` 객체는 `Proxy`로 감싸지므로, 속성에 직접 접근하여 반응성을 유지할 수 있습니다.

| 구분     | 방법                             | 반응성 결과 | 설명                                                                                                                                                                                                                        |
| :------- | :------------------------------- | :---------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **유지** | 속성에 직접 접근 (`user.name`)   | 유지        | `reactive` 객체는 일반 객체처럼 사용하며, Vue가 `Proxy`를 통해 모든 접근을 추적합니다.                                                                                                                                      |
| **손실** | `reactive` 객체를 구조 분해 할당 | 손실        | `const { name } = user;`는 `user.name`의 현재 값을 복사한 일반 변수가 되며, 원본 `user` 객체의 변경을 추적하지 못합니다.                                                                                                    |
| **유지** | `toRefs()`를 사용하여 구조 분해  | 유지        | `toRefs()`는 `reactive` 객체의 모든 속성을 개별적인 `ref`로 변환하여 반환합니다. 이 `ref`들은 원본 `reactive` 객체의 해당 속성과 연결되어 있어 반응성이 유지됩니다. 이를 해체하면 `.value` 없이 템플릿에서 사용 가능합니다. |

**`toRefs` 사용 예시 (반응성 유지)**

```javascript
import { reactive, toRefs } from "vue";

const state = reactive({ count: 0, name: "Vue" });
const { count, name } = toRefs(state);

// 로직에서 값을 변경할 때는 .value를 통해 접근해야 합니다 (예: count.value++).
// 이 때 원본 state.count도 함께 변경됩니다.
count.value++;
console.log(state.count);
console.log(count.value);
```

### 3. `computed()` (파생 상태)

`computed()`는 기존의 반응형 데이터를 기반으로 새로운 반응형 데이터를 파생시킬 때 사용합니다. 캐싱 메커니즘을 내장하고 있어 의존하는 반응형 데이터가 변경될 때만 다시 계산됩니다.

computed는 기본적으로 읽기 전용이지만, getter와 setter를 모두 제공하여 양방향으로 동작하는 파생 상태를 만들 수도 있습니다. 정의하는 방식에 따라 다음과 같이 두 가지 형태로 사용될 수 있습니다.

1.  **읽기 전용 (Getter-only)**: 하나의 콜백 함수를 인수로 받습니다. 이 콜백 함수는 계산된 값을 반환하며, `computed` 속성은 읽기 전용이 됩니다. (예: `computed(() => price.value * quantity.value)`) 이 형태는 암묵적으로 `getter` 역할을 합니다.
2.  **읽기-쓰기 (Writable)**: `get`과 `set` 두 가지 함수를 가진 객체를 인수로 전달합니다. `get` 함수는 값을 반환하고, `set` 함수는 `computed` 속성에 새로운 값이 할당될 때 실행되어 의존하는 반응형 데이터를 업데이트합니다.

`computed`는 캐싱 메커니즘을 내장하고 있어 의존하는 반응형 데이터가 변경될 때만 다시 계산됩니다.

| 구분     | 방법                                  | 결과 | 설명                                                                                                                                                                                                                                                               |
| :------- | :------------------------------------ | :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **유지** | `.value`를 통해 접근                  | 유지 | `computed` 속성은 `ref`와 유사하게 `.value`를 통해 값에 접근합니다.                                                                                                                                                                                                |
| **손실** | `computed` 결과 자체를 구조 분해 할당 | 손실 | `const { total } = myComputedValue;`처럼 구조 분해하면 `computed`의 현재 값을 복사한 일반 변수가 되므로, 의존하는 반응형 데이터가 변경되어도 `total` 값은 업데이트되지 않습니다. (`toRefs`나 `storeToRefs`와 같은 유틸리티는 `computed`에 직접 적용되지 않습니다.) |

**`computed` 사용 예시**

```javascript
import { ref, computed } from "vue";

const price = ref(100);
const quantity = ref(2);
const total = computed(() => price.value * quantity.value);

console.log(total.value); // 200
price.value = 150;
console.log(total.value); // 300 (price 변경 시 자동으로 재계산)

// 쓰기 가능한 computed 속성 (getter/setter)
const totalProduct = computed({
  get: () => price.value * quantity.value,
  set: (newValue) => {
    price.value = newValue / quantity.value;
  },
});

console.log(totalProduct.value); // 200
totalProduct.value = 300;
console.log(price.value); // 150 (300 / 2)
```

### 4. Pinia Store (State)

Pinia Store의 `State`도 `reactive` 객체이므로, 일반 `reactive`와 동일한 규칙이 적용됩니다. 하지만 Pinia에서는 `State`를 구조 분해할 때 `storeToRefs()` 유틸리티를 사용하여 반응성을 유지하는 것을 권장합니다.

| 구분     | 방법                                | 반응성 결과 | 설명                                                                                   |
| :------- | :---------------------------------- | :---------- | :------------------------------------------------------------------------------------- |
| **손실** | Store를 직접 해체                   | 손실        | `const { count } = store;`는 단순한 값 복사입니다.                                     |
| **유지** | `storeToRefs()`를 사용하여 해체     | 유지        | Pinia 전용 유틸리티로, `State`와 `Getter` 속성을 `ref`로 변환하여 반응성을 유지합니다. |
| **유지** | Store 객체 전체를 반환 후 속성 접근 | 유지        | `return { store }` 후 템플릿에서 `{{ store.count }}`로 접근하면 반응성 유지.           |
