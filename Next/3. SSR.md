# 서버 사이드 렌더링 (SSR) 및 서버 컴포넌트

이 문서에서는 Next.js 애플리케이션의 핵심 렌더링 전략인 서버 사이드 렌더링(SSR)과 서버 컴포넌트의 개념 및 작동 방식에 대해 자세히 설명합니다.

---

## 1. 서버 사이드 렌더링 (SSR - Server-Side Rendering)

SSR은 웹 페이지의 렌더링이 **서버** 측에서 이루어지는 방식입니다. 서버에서 완성된 형태의 HTML을 클라이언트로 전송합니다.

**작동 방식:**

1.  **최초 요청**: 브라우저가 서버에 페이지를 요청하면, 서버는 JSX 파일을 JavaScript로 변환하고, 이를 실행하여 메모리상에 가상 DOM을 생성합니다. 컴포넌트의 초기 상태(state)나 속성(props)을 기반으로 데이터를 미리 채워서 **정적인 HTML**이 만들어진 상태입니다. 서버는 이 HTML 문자열을 클라이언트에 전송합니다.

2.  **클라이언트에 HTML 전달**: 클라이언트 브라우저는 이 HTML을 받아서 DOM 트리를 구성하고 화면에 바로 렌더링합니다. 사용자에게는 콘텐츠가 즉시 보여지므로 초기 로딩 경험이 좋습니다.

3.  **Hydration(하이드레이션)**: 이 시점에서 사용자는 페이지의 콘텐츠를 볼 수 있지만, 아직 JavaScript가 로드되지 않았기 때문에 상호작용은 불가능합니다. 이후 클라이언트 측 JavaScript가 다운로드되어, 이미 렌더링된 정적인 DOM 노드에 이벤트 핸들러와 같은 동적인 기능을 연결합니다. 이 과정을 **하이드레이션(Hydration)** 이라고 합니다. 이는 '수분 공급' 이라는 단어로, 정적인 피부에 앰플을 바르는 과정을 의미합니다. 하이드레이션이 완료되면, 해당 페이지는 클라이언트 측에서 동적으로 작동하는 SPA(Single-Page Application)와 동일하게 동작하게 됩니다.

4.  **After Hydration**: 이 시점부터 컴포넌트의 수명 주기는 브라우저 측 React 라이브러리에 의해 관리됩니다.

**장점:**

- **빠른 초기 로딩**: 서버에서 미리 렌더링된 HTML을 받으므로, 사용자는 페이지 내용을 더 빨리 볼 수 있습니다.
- **SEO에 유리**: 검색 엔진 크롤러가 페이지의 완전한 HTML 콘텐츠를 즉시 수집할 수 있어 SEO에 매우 효과적입니다.
- **사용자 경험 개선**: 빈 화면 노출 없이 빠르게 콘텐츠를 제공하여 사용자 경험을 향상시킵니다.

**단점:**

- **서버 부하 증가**: 각 요청마다 서버에서 페이지를 렌더링해야 하므로, 서버에 부담이 커질 수 있습니다.
- **첫 바이트 시간(TTFB) 증가**: 서버에서 렌더링하는 시간이 추가되어 첫 바이트를 받는 시간이 CSR보다 길어질 수 있습니다.

---

## 2. 하이드레이션 시 데이터 불일치 (Hydration Mismatch Error)

SSR(Server-Side Rendering) 환경에서 페이지를 렌더링할 때, 서버에서 생성된 HTML과 클라이언트에서 하이드레이션 과정 중 생성된 DOM 트리가 일치하지 않으면 하이드레이션 불일치 에러(Hydration Mismatch Error)가 발생할 수 있습니다. React는 이러한 불일치를 감지하면 경고를 발생시키고, 클라이언트 측에서 전체 UI를 다시 렌더링하게 됩니다.

**주요 원인:**

1.  **브라우저 전용 API 사용**: 서버 환경에서는 `window`, `document` 객체와 같은 브라우저 전용 API에 접근할 수 없습니다. 만약 서버에서 렌더링되는 컴포넌트 코드 내에서 이러한 API를 직접 사용하면, 서버와 클라이언트의 렌더링 결과가 달라져 불일치 에러가 발생할 수 있습니다.

2.  **시간에 민감한 데이터**: `new Date()`와 같이 서버와 클라이언트의 실행 시점에 따라 다른 값을 생성하는 코드가 있는 경우, 서로 다른 타임스탬프로 인해 불일치가 발생할 수 있습니다.

3.  **서버/클라이언트 간 다른 렌더링 로직**: `navigator.userAgent`와 같이 서버와 클라이언트 환경에 따라 다르게 동작하는 로직이 있거나, 조건부 렌더링 로직이 환경에 따라 다르게 실행될 때 불일치가 발생할 수 있습니다. 예를 들어, 서버에서는 모바일 UI를 렌더링하고 클라이언트에서는 데스크톱 UI를 렌더링하는 경우입니다.
4.  **HTML 구조 불일치**: `dangerouslySetInnerHTML`을 잘못 사용하거나, 외부 라이브러리가 DOM을 직접 조작하여 서버에서 생성된 HTML과 다른 DOM 구조를 클라이언트에서 만들 때 발생할 수 있습니다.

**해결 방안:**

1.  **환경 분리**: `typeof window !== 'undefined'` 와 같은 조건문을 사용하여 브라우저 전용 API나 클라이언트 측에서만 실행되어야 하는 코드를 분리합니다.

2.  **`useEffect` 활용**: 클라이언트 측에서만 실행되어야 하는 로직이나 데이터를 사용하는 컴포넌트는 `useEffect` 훅 내부에서 처리하여 초기 서버 렌더링 시에는 포함되지 않도록 합니다.

3.  **일관된 데이터 페칭**: 서버와 클라이언트가 동일한 데이터를 동일한 방식으로 가져오도록 보장합니다. Next.js의 `getServerSideProps`나 `getStaticProps`를 사용하여 초기 데이터를 프리페칭하는 것이 좋습니다.

4.  **`suppressHydrationWarning` 사용**: 극히 드문 경우이거나 사소한 텍스트 콘텐츠 불일치에 한해 `suppressHydrationWarning` prop을 사용하여 React의 경고를 억제할 수 있습니다. 하지만 이는 근본적인 문제를 해결하는 것이 아니므로, 신중하게 사용해야 합니다.

5.  **디버깅**: React 개발자 도구를 사용하여 서버에서 생성된 HTML과 클라이언트에서 생성된 DOM의 차이를 비교하고, 불일치 지점을 찾아 수정합니다.

하이드레이션 불일치 에러는 SSR 애플리케이션에서 흔히 발생할 수 있는 문제이므로, 위 원인과 해결 방안을 이해하고 적용하는 것이 중요합니다.

---

## 3. 서버 컴포넌트 (Server Components)

Next.js 13부터 도입된 서버 컴포넌트(Server Components)는 React 애플리케이션의 렌더링 방식을 최적화하고, 성능을 향상시키며, 개발자가 서버와 클라이언트의 강점을 모두 활용할 수 있도록 돕는 강력한 기능입니다. 기본적으로 Next.js의 모든 컴포넌트는 서버 컴포넌트로 간주됩니다.

**사용 가능한 기능:**

- **데이터 페칭**: 데이터베이스나 백엔드 API로부터 직접 데이터를 가져오는 데 이상적입니다.
- **번들 크기 0**: 클라이언트로 전송되는 JavaScript가 없어 최종 번들 크기를 줄일 수 있습니다.
- **민감한 데이터/로직 처리**: API 키나 민감한 환경 변수, 보안이 중요한 로직 등을 서버에서 안전하게 처리할 수 있습니다.
- **대규모 의존성 사용**: 서버에만 필요한 라이브러리를 클라이언트 번들에 포함하지 않고 사용할 수 있습니다.
- **SEO 최적화**: 서버에서 완전한 HTML을 생성하여 전송하므로, 검색 엔진 크롤러가 페이지 내용을 쉽게 색인할 수 있습니다.
- **상태 및 효과 없음**: React Hook(`useState`, `useEffect` 등)을 사용할 수 없으며, 클라이언트 측 상태 관리나 상호작용이 필요하지 않은 정적인 UI 부분에 적합합니다.

**예시:**

```jsx
// app/page.tsx (기본적으로 서버 컴포넌트)
import { fetchPosts } from "../lib/api"; // 서버에서만 실행되는 함수

export default async function Page() {
  const posts = await fetchPosts(); // 서버에서 데이터 페칭
  return (
    <div>
      <h1>블로그 게시물</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```
