# 클라이언트 사이드 렌더링 (CSR) 및 클라이언트 컴포넌트

이 문서에서는 클라이언트 사이드 렌더링(CSR)의 개념과 Next.js에서 클라이언트 컴포넌트가 어떻게 작동하며 어떤 기능들을 제공하는지 설명합니다.

---

## 1. 클라이언트 사이드 렌더링 (CSR - Client-Side Rendering)

CSR은 웹 페이지의 렌더링이 전적으로 **클라이언트(브라우저)** 측에서 이루어지는 방식입니다.

**작동 방식:**

1.  **최초 요청**: 브라우저가 서버에 페이지를 요청하면, 서버는 거의 비어있는 HTML 파일과 JavaScript 번들 파일을 응답합니다.
2.  **JavaScript 다운로드 및 실행**: 브라우저는 HTML을 파싱하고 JavaScript 파일을 다운로드하여 실행합니다.
3.  **데이터 페칭 및 렌더링**: JavaScript 코드가 실행되면서 필요한 데이터를 서버에 요청하고, 데이터를 받아온 후 React(또는 Vue, Angular 등)와 같은 라이브러리가 DOM을 직접 조작하여 UI를 생성하고 화면에 렌더링합니다.

**단점:**

- **느린 초기 로딩**: 모든 JavaScript 코드가 다운로드되고 실행되어야 페이지가 렌더링되므로, 초기 로딩 시간이 길어질 수 있습니다.
- **SEO 불리**: 검색 엔진 크롤러가 비어있는 초기 HTML만 보고 페이지 내용을 파악하기 어려울 수 있습니다. (최근에는 크롤러도 JS를 실행하지만, SSR/SSG에 비해 여전히 불리할 수 있음)

---

## 2. 클라이언트 컴포넌트 (Client Components)

클라이언트 컴포넌트는 기존의 React 컴포넌트와 유사하게 **클라이언트(브라우저)에서 렌더링되고 상호작용이 가능한 컴포넌트**입니다. 클라이언트 번들에 JavaScript 코드가 포함됩니다.

파일 상단에 `'use client'` 지시어를 추가하여 클라이언트 컴포넌트임을 명시합니다.

**사용 가능한 기능:**

- **상호작용 및 상태 관리**: `useState`, `useEffect`와 같은 Hook을 사용하여 사용자 상호작용에 반응하거나, 클라이언트 측 상태를 관리할 수 있습니다.
- **브라우저 전용 API 사용**: `window`, `document` 객체와 같이 브라우저 환경에서만 사용 가능한 API에 접근해야 할 때 사용합니다.
- **이벤트 리스너**: `onClick`, `onChange`와 같은 이벤트 핸들러를 등록할 수 있습니다.
- **React 생태계 활용**: React 컨텍스트(Context), 상태 관리 라이브러리(Zustand, Redux 등), 애니메이션 라이브러리 등 클라이언트 측에서만 작동하는 다양한 React 생태계 도구들을 활용할 수 있습니다.

**예시:**

```jsx
// app/components/Counter.tsx
"use client"; // 클라이언트 컴포넌트임을 명시

import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

---

## 3. 서버 컴포넌트와 클라이언트 컴포넌트의 상호작용 (Client Component 관점)

클라이언트 컴포넌트가 서버 컴포넌트를 직접 `import`할 수 없습니다. 대신, 서버 컴포넌트에서 `children` prop을 통해 서버 컴포넌트를 자식으로 전달받거나, `Next.js`의 `Suspense`와 같은 패턴을 활용하여 서버 컴포넌트의 렌더링 결과를 클라이언트 컴포넌트 내부에서 사용해야 합니다.

**예시:**

```jsx
// app/components/ClientLayout.tsx
'use client';
import { useState } from 'react';

export default function ClientLayout({ children }: { children: React.ReactNode }) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>Toggle Menu</button>
      {isOpen && <nav>메뉴</nav>}
      {children} {/* 서버 컴포넌트로부터 전달받은 자식 (서버 컴포넌트) */}
    </div>
  );
}

// app/page.tsx (서버 컴포넌트)
import ClientLayout from '../components/ClientLayout';

export default function Page() {
  return (
    <ClientLayout>
      <h1>환영합니다!</h1> {/* 이 H1은 서버 컴포넌트이며 ClientLayout의 children으로 전달됩니다. */}
    </ClientLayout>
  );
}
```
