## Data Fetching

Next.js는 웹 애플리케이션에서 데이터를 가져오는 다양한 방법을 제공하여, 각 페이지의 특성과 요구사항에 맞춰 최적의 렌더링 전략을 선택할 수 있도록 합니다.

주요 데이터 페칭 방법으로는 빌드 시 데이터를 가져오는 `getStaticProps`, 동적 경로를 정의하는 `getStaticPaths`, 요청 시 데이터를 가져오는 `getServerSideProps`, 그리고 클라이언트 측에서 데이터를 가져오는 클라이언트 페칭이 있습니다.

## getStaticProps (Static Site Generation - SSG)

Next.js 애플리케이션에서 **빌드 시** 데이터를 가져와 정적으로 페이지를 생성하는 함수입니다. 데이터가 자주 변경되지 않거나, 변경되어도 즉각적인 반영이 필요 없는 경우에 적합합니다.

- **작동 방식**:
  - Next.js 애플리케이션 빌드 시 실행됩니다.
  - 함수 내부에서 외부 데이터를 가져와 `props` 객체 형태로 반환합니다.
  - 반환된 `props`는 페이지 컴포넌트로 전달되어 정적 HTML을 생성합니다.
- **특징**:
  - 생성된 HTML과 JSON 데이터는 CDN에 캐시됩니다.
  - 클라이언트 측 JavaScript 번들 크기를 줄여줍니다.
  - `revalidate` 옵션을 사용하여 ISR을 구현할 수 있습니다.
- **사용법**:

  ```javascript
  export async function getStaticProps(context) {
    const res = await fetch("https://.../posts");
    const posts = await res.json();

    return {
      props: {
        posts, // 페이지 컴포넌트로 전달
      },
      revalidate: 60, // 60초마다 ISR을 통해 페이지 재생성 시도 (선택 사항)
    };
  }

  function Blog({ posts }) {
    return (
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    );
  }

  export default Blog;
  ```

## getStaticPaths (Static Site Generation with Dynamic Routes)

`getStaticProps`와 함께 **동적 라우팅을 사용하는 페이지**에서 빌드 시점에 어떤 경로들을 미리 생성할 것인지 정의하는 함수입니다.

**용도 및 필요성**:

`getStaticProps`를 사용하여 동적 경로 페이지를 빌드 시점에 정적으로 미리 생성(Pre-render) 할 때 필요합니다.

Next.js는 빌드 시점에 어떤 `id` 값을 가진 페이지들을 미리 생성해야 하는지 알 수 없으므로, `getStaticPaths`를 통해 미리 생성할 동적 경로들의 목록을 알려줍니다.

이를 통해 Next.js는 해당 경로들에 대해 `getStaticProps`를 실행하여 각각의 정적 HTML 파일을 만들 수 있습니다. 즉, `getStaticPaths`는 동적 경로를 가진 페이지를 SSG 방식으로 최적화하기 위한 필수적인 단계입니다.

사용자의 요청(예: `/posts/123`)은 런타임에 발생하지만, `getStaticPaths`는 이 요청이 오기 전에 미리 페이지를 준비하는 역할을 합니다.

- **작동 방식**:
  - Next.js 빌드 시 실행됩니다.
  - 각 경로 객체는 `params` 속성을 가져야 하며, 이 `params`는 해당 경로의 `getStaticProps`로 전달됩니다.
  - `fallback` 옵션을 통해 미리 생성되지 않은 경로에 대한 동작을 정의합니다.
- **특징**:
  - `fallback: false`: 미리 정의된 `paths` 외의 경로로 접근하면 404 페이지를 반환합니다.
  - `fallback: true`: 미리 정의되지 않은 경로로 접근 시, 첫 요청에는 빈 페이지를 보여주고 백그라운드에서 해당 페이지를 생성한 후, 다음 요청부터 생성된 페이지를 보여줍니다 (로딩 상태 처리 필요).
  - `fallback: 'blocking'`: 미리 정의되지 않은 경로로 접근 시, 페이지가 생성될 때까지 기다렸다가 완전히 생성된 페이지를 제공합니다 (로딩 상태 처리 불필요).
- **사용법**:

  ```javascript
  export async function getStaticPaths() {
    const res = await fetch("https://.../posts");
    const posts = await res.json();

    const paths = posts.map((post) => ({
      params: { id: post.id.toString() },
    }));

    return {
      paths,
      fallback: "blocking", // 미리 생성되지 않은 경로에 대한 처리 방식
    };
  }

  export async function getStaticProps({ params }) {
    // params.id를 사용하여 해당 게시물 데이터 가져옴
    const res = await fetch(`https://.../posts/${params.id}`);
    const post = await res.json();

    return {
      props: {
        post,
      },
    };
  }

  function Post({ post }) {
    // ...
    return (
      <div>
        <h1>{post.title}</h1>
        <p>{post.content}</p>
      </div>
    );
  }

  export default Post;
  ```

---

#### 마멋님 질문:

getStaticPaths의 사용법 및 동작 원리를 잘 이해했어요. 다만, 이게 실용적으로 잘 쓰일지는 모르겠습니다. 보통 동적 경로라 하면 사용자가 하나의의 쿼리 데이터를 요청하고 그것으로 특정 데이터를 조회하는 방식인데, 저렇게 사용자 요청 파라미터 없이 사용하는 게 의미가 있을까요?

---

사실 많은 개발자들이 처음 getStaticPaths를 접할 때 비슷한 의문을 갖습니다. “동적 경로인데 왜 사용자 요청 없이 미리 HTML을 생성하지?”라는 질문은 아주 타당하죠.

하지만 이 함수는 사용자 요청 기반의 동적 처리와는 조금 다른 목적을 가지고 있어요. 핵심은 “빌드 타임에 미리 생성할 수 있는 경로”를 정의하는 데 있습니다.

#### getStaticPaths의 실용성은 예측 가능한 경로가 있을 때 드러납니다.

- 예: 블로그 글, 제품 상세 페이지, 뉴스 기사 등
  이런 경우에는 URL이 posts/[id]처럼 동적이지만, 모든 가능한 id를 미리 알고 있고, 콘텐츠가 자주 바뀌지 않기 때문에 SSG가 적합합니다.

getStaticPaths 함수에서 전체 인덱스를 조회하고 getStaticProps 함수에서 원하는 특정 인덱스만 조회하는 방식입니다.

## `getServerSideProps` (Server-Side Rendering - SSR)

`getServerSideProps`는 Next.js 애플리케이션에서 **요청 시** 데이터를 가져와 서버에서 페이지를 렌더링하는 함수입니다. 이 함수는 매 요청마다 서버에서 실행되므로, 항상 최신 데이터를 포함한 페이지를 사용자에게 제공할 수 있습니다.

- **용도**: 매 요청마다 최신 데이터를 가져와야 하는 페이지 (예: 사용자 프로필 페이지, 장바구니 페이지, 검색 결과 페이지).
- **작동 방식**:
  - 페이지 요청이 들어올 때마다 서버에서 실행됩니다.
  - 함수 내부에서 데이터를 가져와 `props` 객체 형태로 반환합니다.
  - 반환된 `props`는 페이지 컴포넌트로 전달되어 HTML을 생성하고, 이 HTML이 클라이언트로 전송됩니다.
- **특징**:
  - 항상 최신 데이터를 보장합니다.
  - 서버에서 완전한 HTML을 생성하므로 SEO에 유리합니다.
  - `context` 객체를 통해 요청(request), 응답(response) 객체, 쿼리 파라미터 등에 접근할 수 있습니다.
- **단점**:
  - 매 요청마다 서버에서 렌더링하므로 `getStaticProps`에 비해 서버 부하가 높을 수 있습니다.
  - CDN 캐싱이 어렵습니다.
- **사용법**:

  ```javascript
  // pages/profile.js
  export async function getServerSideProps(context) {
    // context.req, context.res 등을 통해 요청 정보에 접근 가능
    const userId = context.query.userId;
    const res = await fetch(`https://.../users/${userId}`);
    const user = await res.json();

    if (!user) {
      return {
        notFound: true, // 404 페이지 반환
      };
    }

    return {
      props: {
        user,
      },
    };
  }

  function Profile({ user }) {
    return (
      <div>
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    );
  }

  export default Profile;
  ```

---

## 클라이언트 페칭 (Client-side Data Fetching)

클라이언트 페칭은 브라우저에서 JavaScript를 사용하여 데이터를 가져오는 방식입니다.

- **용도**:
  - 초기 로드 후 동적으로 변경되는 데이터
  - SEO가 중요하지 않거나 초기 로딩 시점에 필수적이지 않은 데이터.
- **작동 방식**:

  - 페이지가 클라이언트 측에서 렌더링된 후, 브라우저의 JavaScript가 실행되어 API를 호출하고 데이터를 가져옵니다.
  - 가져온 데이터는 컴포넌트의 상태로 관리됩니다.

- **사용법 (useEffect와 fetch API 예시)**:

  ```javascript
  // components/MyDataComponent.js (클라이언트 컴포넌트 또는 페이지 컴포넌트)
  import { useState, useEffect } from "react";

  function MyDataComponent() {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
      async function fetchData() {
        try {
          const res = await fetch("https://.../some-data");
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          const json = await res.json();
          setData(json);
        } catch (e) {
          setError(e);
        } finally {
          setLoading(false);
        }
      }
      fetchData();
    }, []); // 빈 배열: 컴포넌트 마운트 시 한 번만 실행

    if (loading) return <p>Loading data...</p>;
    if (error) return <p>Error: {error.message}</p>;

    return (
      <div>
        <h2>Client-side Fetched Data</h2>
        <pre>{JSON.stringify(data, null, 2)}</pre>
      </div>
    );
  }

  export default MyDataComponent;
  ```
