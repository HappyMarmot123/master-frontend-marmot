# 호이스팅 (Hoisting)

## 📖 개요

자바스크립트에서 **변수/함수 선언을 호이스팅**하는 것은 실행 컨텍스트의 생성 단계에서 해당 식별자들을 미리 렉시컬 환경(Lexical Environment)의 환경 레코드에 등록해두기 때문입니다. 이렇게 미리 등록하는 이유는 스코프 내의 모든 선언을 코드가 실행되기 전에 한 번에 수집하여, 코드의 순서와 관계없이 참조할 수 있게 만들기 위함입니다.

이러한 메커니즘은 코드를 분석하고 실행하는 효율성을 높여줍니다.

## 🔍 호이스팅과 렉시컬 환경의 관계

자바스크립트 코드는 크게 두 단계로 실행됩니다.

### 1. 생성 단계 (Creation Phase)

- 자바스크립트 엔진이 코드를 읽어 들여 **실행 컨텍스트**를 생성합니다.
- 이 과정에서 스코프 내의 **`var` 변수, 함수 선언문, `let`, `const`, `class`** 선언을 모두 찾습니다.
- 찾아낸 선언들을 **렉시컬 환경**에 미리 등록합니다.
- `var` 변수와 함수 선언은 `undefined` 또는 함수 객체로 **초기화**됩니다.
- `let`, `const`, `class`는 **초기화되지 않은 상태**로 등록됩니다. (이 때문에 호이스팅이 일어나도 변수 선언 이전에 접근하면 ReferenceError가 발생합니다. 이를 **일시적 사각지대(Temporal Dead Zone)**라고 합니다.)

### 2. 실행 단계 (Execution Phase)

- 이제 코드가 한 줄씩 순서대로 실행됩니다.
- 코드에서 변수나 함수를 만날 때, 엔진은 이미 렉시컬 환경에 등록된 정보를 이용해 해당 식별자에 접근합니다.

## 🎯 호이스팅에 대한 정확한 이해

호이스팅은 특정 실행 컨텍스트가 생성될 때, 해당 컨텍스트의 환경 레코드(Environment Record)에 변수 및 함수 선언을 미리 등록하는 과정입니다.

호이스팅은 변수나 함수 선언을 코드의 최상단으로 물리적으로 끌어올리는 작업이 아닙니다. 실제로는 실행 컨텍스트의 생성 단계에서 해당 컨텍스트의 렉시컬 환경에 있는 환경 레코드에 선언부를 미리 등록하는 작업입니다.

## 🔑 변수 키워드와 스코프

### 변수 키워드별 특성 비교

| 키워드  | 스코프                       | 재선언     | 재할당     | 호이스팅                               |
| ------- | ---------------------------- | ---------- | ---------- | -------------------------------------- |
| `var`   | 함수 스코프 (Function Scope) | O (가능)   | O (가능)   | O (선언만, undefined로 초기화)         |
| `let`   | 블록 스코프 (Block Scope)    | X (불가능) | O (가능)   | O (선언만, 초기화되지 않음 → TDZ 발생) |
| `const` | 블록 스코프 (Block Scope)    | X (불가능) | X (불가능) | O (선언만, 초기화되지 않음 → TDZ 발생) |

### 스코프의 차이점

**블록 스코프 (Block Scope)**

- `let`, `const`가 가지는 스코프
- 변수가 선언된 `{}` 블록 내에서만 유효
- 블록을 벗어나면 변수에 접근할 수 없음

```javascript
{
  let blockScoped = "블록 내부에서만 유효";
  const alsoBlockScoped = "마찬가지로 블록 내부에서만 유효";
}
// console.log(blockScoped); // ReferenceError: blockScoped is not defined
```

**함수 스코프 (Function Scope)**

- `var`가 가지는 스코프
- 변수가 선언된 함수 내부 전체에서 유효
- 블록(`{}`)은 무시하고 함수 전체에서 접근 가능

```javascript
function example() {
  if (true) {
    var functionScoped = "함수 전체에서 유효";
  }
  console.log(functionScoped); // "함수 전체에서 유효" 출력됨
}
```

### TDZ (Temporal Dead Zone)

**TDZ란?**

- `let`과 `const`는 호이스팅되지만, 초기화되기 전까지는 접근할 수 없어 참조 에러(Reference Error)가 발생하는 구간
- 변수 선언 이전에 접근하려고 하면 발생

```javascript
// TDZ 예시
console.log(tdzVariable); // ReferenceError: Cannot access 'tdzVariable' before initialization
let tdzVariable = "TDZ를 벗어남";
```

### 루프에서의 데이터 캡처 문제

**문제 상황:**
`var`를 루프에서 사용할 때 클로저나 비동기 함수에서 예상과 다른 결과가 나오는 문제

```javascript
// var를 사용한 루프 - 문제 발생
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 3, 3, 3 출력 (예상: 0, 1, 2)
  }, 100);
}
```

**문제가 발생하는 이유:**

### 1. 스코프의 근본적인 차이점

**`var`의 함수 스코프 특성:**
`var`는 함수 스코프를 가지므로 루프 블록(`{}`)을 완전히 무시합니다. 이는 `var`가 선언된 함수 전체에서 유효하다는 의미입니다. 루프가 포함된 함수가 시작될 때 `i` 변수가 함수 스코프에 등록되고, 루프가 완료된 후에도 여전히 존재하며 최종 값인 3을 가지게 됩니다.

클로저는 자신이 생성된 시점의 렉시컬 환경을 기억합니다. `var`를 사용할 때는 모든 콜백이 같은 렉시컬 환경(함수 스코프)의 같은 `i` 변수를 참조하게 됩니다. 이 변수는 루프가 완료된 후에도 계속 존재하며, 모든 콜백이 이 최종 값을 참조하게 됩니다.

**`let`의 블록 스코프 특성:**
`let`은 블록 스코프를 가지므로 각 루프 반복마다 새로운 독립적인 `i` 변수가 생성됩니다. 이는 각 반복에서 생성된 `i`가 해당 블록에서만 유효하며, 다음 반복에서는 완전히 새로운 변수라는 의미입니다.

`let`을 사용하면 각 루프 반복마다 새로운 렉시컬 환경이 생성되므로, 각 콜백이 서로 다른 렉시컬 환경의 독립적인 `i` 변수를 참조하게 됩니다. 이로 인해 각 콜백이 올바른 값을 캡처할 수 있게 됩니다.
