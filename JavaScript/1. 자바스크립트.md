# JavaScript 런타임 구조

## 📖 개요

JavaScript는 최초에 웹 브라우저에서 간단한 상호작용을 처리하는 것이 주요 목적이었습니다. UI를 조작하는 데 필요한 복잡한 동시성 문제를 피하기 위해 **싱글 스레드 방식**이 채택되었습니다.

## 🚫 싱글 스레드 채택 이유

### 경쟁 조건(Race Condition) 방지

- 여러 스레드가 동시에 하나의 데이터를 수정하려고 할 때 발생하는 문제를 미리 방지
- 예측 가능한 동작 보장

### 데드락(Deadlock) 회피

- 두 개 이상의 스레드가 서로 상대방의 작업이 끝나기를 기다리며 멈춰버리는 상황을 피함
- 복잡한 동기화 로직 불필요

### 개발 효율성

- 이러한 문제들은 디버깅을 매우 어렵게 만들고 예측 불가능한 버그를 유발
- 싱글 스레드 환경은 이러한 복잡성을 근본적으로 제거
- 개발자가 코드를 더 쉽게 작성하고 이해할 수 있음

> **결론**: JavaScript는 인터프리터 언어의 단점을 보완하는 언어라고 볼 수 있습니다.

## 🏗️ JavaScript 런타임 구조

JavaScript의 **런타임(Runtime)**은 코드를 실행하는 환경으로, 단일 스레드 언어의 한계를 극복하기 위해 여러 구성 요소들이 유기적으로 결합된 시스템입니다.

### 핵심 구성 요소

#### 1. 콜 스택 (Call Stack)

- 코드가 실제로 실행되는 곳
- 함수 호출이 발생하면 스택에 쌓이고, 함수가 종료되면 스택에서 제거
- **후입선출(LIFO)** 방식
- 한 번에 하나의 작업만 처리 가능

#### 2. 힙 (Heap)

- 객체나 배열 같은 동적 데이터가 저장되는 메모리 공간
- 가비지 컬렉션이 관리하는 영역
- 런타임 중에 메모리 크기 결정
- 필요에 따라 메모리 확장/축소가 가능하지만 스택보다 속도가 느리며 메모리 누수 위험

#### 3. 웹 API (Web API)

- 비동기 작업을 브라우저/Node.js 환경의 Web API로 위임
- `setTimeout()`, `fetch()`, DOM 이벤트 등 포함
- 콜 스택과는 독립적으로 실행

#### 4. 콜백 큐 (Callback Queue)

- 웹 API에서 처리된 비동기 작업의 콜백 함수들이 대기하는 곳
- `Promise`, `await`과 같이 즉각적인 처리가 필요한 콜백 함수들은 우선순위가 높은 마이크로 태스크 큐 (Microtask Queue)으로 이동
- 일반적인 비동기 작업들은 태스크 큐 (Task Queue)에서 처리

## ⚡ 논블로킹(Non-blocking) 비동기 처리

싱글 스레드는 한 번에 하나의 작업만 처리할 수 있습니다. 따라서 시간이 오래 걸리는 작업(예: 대용량 파일 처리, 네트워크 요청 등)이 발생하면, 해당 작업이 끝날 때까지 다른 작업들은 멈추게 됩니다.

이러한 싱글 스레드의 한계를 해결하기 위해, JavaScript는 이벤트 루프(Event Loop)와 웹 API(Web API)를 활용하는 비동기 모델을 도입했습니다. 싱글 스레드이면서도 여러 작업을 동시에 처리하는 **효율적인 논블로킹 비동기 처리** 가능합니다.

## 🔄 이벤트 루프 동작 원리

이벤트 루프는 콜 스택과 큐(태스크 큐, 마이크로 태스크 큐)를 끊임없이 감시하는 역할을 합니다.

### 동작 과정

1. **지속적 감시**: 콜 스택이 비어 있는지를 지속적으로 확인
2. **마이크로 태스크 우선 처리**:

   - 콜 스택이 비는 즉시, 이벤트 루프는 마이크로 태스크 큐에 있는 **모든 작업**을 먼저 콜 스택으로 옮겨 실행
   - Promise 기반 작업들이 우선 처리됨

3. **태스크 처리**:

   - 마이크로 태스크 큐가 완전히 비면, 이벤트 루프는 태스크 큐에서 가장 오래된 작업 **하나**를 가져와 콜 스택으로 옮겨 실행
   - 일반적인 비동기 작업들이 처리됨

#### 이벤트 루프 처리 순서

# 콜스택 > 마이크로 태스크 큐 > 브라우저 렌더링 > 태스크 큐
