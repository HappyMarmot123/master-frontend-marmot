# 명령형(Imperative) vs 선언형(Declarative)

## 📖 개요

**명령형 프로그래밍**은 “무엇을 하기 위해 어떻게 수행할지”를 단계별로 지시합니다. 반면 **선언형 프로그래밍**은 “무엇을 얻고 싶은지”를 기술하고, 수행 절차는 런타임/프레임워크/엔진에 위임합니다.

- **선언형**: 목표 상태를 기술(map/filter, SQL), 내부 절차는 추상화 뒤로 감춤
- **명령형**: 상태 변경과 절차를 직접 기술(for, if, 변수 갱신)

## ✨ 예제로 보는 차이

### 1) 배열 데이터 변환

```js
// 선언형: '짝수 → 제곱'이라는 의도만 표현
const evenSquares2 = numbers.filter((n) => n % 2 === 0).map((n) => n * n);

// 명령형: 절차(반복, 조건, 푸시)를 직접 명시
const numbers = [1, 2, 3, 4, 5];
const evenSquares = [];
for (let i = 0; i < numbers.length; i++) {
  const n = numbers[i];
  if (n % 2 === 0) evenSquares.push(n * n);
}
```

### 2) 비동기 흐름(의존적 호출)

```js
// 선언형(개념): 데이터 의존성을 선언하고 바인딩
const { data, error, isLoading } = useQuery(["user"], fetchUser);

// 명령형: 단계·예외·상태를 직접 관리
async function loadUser() {
  try {
    const res = await fetch("/api/user");
    if (!res.ok) throw new Error("fail");
    const data = await res.json();
    render(data);
  } catch (e) {
    showError(e);
  }
}
```

## ⚖️ 장단점

- **명령형 장점**: 세밀한 제어, 미세 최적화 용이, 러닝 커브 낮음
- **명령형 단점**: 보일러플레이트 증가, 상태 전이 오류↑, 테스트/리팩터링 부담
- **선언형 장점**: 의도 중심 가독성, 추론·테스트 용이, 공통 로직 재사용(추상화)
- **선언형 단점**: 내부 동작이 불투명, 과한 추상화 시 디버깅 난이도↑, 일부 시나리오에서 비용↑

## 🧭 선택 가이드

- **데이터 변환/집계**: map/filter/reduce 등 선언형 API 우선
- **UI 렌더링**: 상태→뷰 매핑은 선언형(템플릿/JSX) 우선, 단 성능 병목은 명령형 미세 최적화
- **부수효과 I/O**: 선언형(리액트 쿼리, rx 등)로 의존성 선언, 경계에서는 명령형로 래핑
- **일회성 절차**(스크립팅/마이그레이션): 명령형이 단순·직관적

## ✅ 체크리스트

- 의도를 코드에서 바로 읽을 수 있는가? → 선언형 우선
- 상태 변경 지점이 최소화되었는가? → 불변/순수 함수 활용
- 복잡도가 어디에 있는가? → 추상화로 숨기되, 디버깅 경로를 확보
- 측정 기반인가? → 성능 병목은 프로파일링 후 명령형 도입

## 📌 요약

JavaScript 개발에서는 두 스타일이 경쟁이 아니라 **보완 관계**입니다. “읽기 쉬운 선언형 기본 + 필요 지점의 명령형 최적화”가 유지보수성과 성능을 동시에 만족시키는 실무 해법입니다.
