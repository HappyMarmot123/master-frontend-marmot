# 동기와 비동기 (Synchronous vs Asynchronous)

## 📖 개요

JavaScript에서 **동기(Synchronous)** / **비동기(Asynchronous)** 는 코드 실행 방식의 핵심 개념입니다. 동기 방식은 코드가 순차적으로 실행되는 반면, 비동기 방식은 코드 실행을 기다리지 않고 다음 작업을 진행할 수 있게 해줍니다. 이 차이를 이해하는 것은 현대적인 웹 애플리케이션 개발에서 매우 중요합니다.

## 🔍 동기와 비동기의 기본 개념

### 동기(Synchronous)란?

동기 방식은 **작업이 순차적으로 실행**되는 것을 의미합니다. 한 작업이 완료될 때까지 다음 작업은 대기 상태에 머물러야 합니다.

**동기 방식의 특징**:

- **순차적 실행**: 코드가 작성된 순서대로 실행
- **블로킹**: 작업 완료까지 다음 작업 대기
- **예측 가능성**: 실행 흐름을 쉽게 파악 가능
- **단순함**: 코드 구조가 직관적

### 비동기(Asynchronous)란?

비동기 방식은 **작업 완료를 기다리지 않고 다음 작업을 진행**할 수 있게 해주는 방식입니다. 작업이 백그라운드에서 실행되며, 완료 시점에 결과를 처리합니다.

**비동기 방식의 특징**:

- **비블로킹**: 작업 완료를 기다리지 않음
- **병렬 처리**: 여러 작업을 동시에 처리 가능
- **콜백 기반**: 작업 완료 시점에 결과 처리
- **복잡성**: 실행 흐름 파악이 상대적으로 어려움

## 💡 동기 vs 비동기 비교

### 실행 방식의 차이

```javascript
// 동기 방식
console.log("1. 첫 번째 작업 시작");
const result = heavyCalculation(); // 이 작업이 완료될 때까지 대기
console.log("2. 두 번째 작업 시작");
console.log("3. 모든 작업 완료");

// 비동기 방식
console.log("1. 첫 번째 작업 시작");
setTimeout(() => {
  console.log("2. 비동기 작업 완료");
}, 1000);
console.log("3. 다음 작업 시작 (비동기 작업 완료를 기다리지 않음)");
```

**출력 결과**:

```
// 동기 방식
1. 첫 번째 작업 시작
2. 두 번째 작업 시작
3. 모든 작업 완료

// 비동기 방식
1. 첫 번째 작업 시작
3. 다음 작업 시작 (비동기 작업 완료를 기다리지 않음)
2. 비동기 작업 완료 (1초 후)
```

### 성능과 사용자 경험

**동기 방식의 한계**:

- **블로킹**: 긴 작업 시 전체 애플리케이션 멈춤
- **사용자 경험 저하**: UI가 응답하지 않는 현상
- **리소스 낭비**: 대기 시간 동안 CPU 유휴 상태

**비동기 방식의 장점**:

- **반응성**: UI가 계속 응답 가능
- **효율성**: 여러 작업을 동시에 처리
- **사용자 경험 향상**: 애플리케이션이 멈추지 않음

## 🔄 JavaScript의 비동기 처리 메커니즘

### 1. 콜백(Callback)

콜백은 비동기 작업이 완료된 후 실행될 함수를 지정하는 가장 기본적인 방법입니다.

```javascript
// 콜백을 사용한 비동기 처리
function fetchUserData(userId, callback) {
  console.log("사용자 데이터 요청 중...");

  setTimeout(() => {
    const userData = {
      id: userId,
      name: "김철수",
      email: "chulsoo@example.com",
    };

    callback(null, userData);
  }, 2000);
}

// 콜백 함수 사용
fetchUserData(123, (error, data) => {
  if (error) {
    console.error("에러 발생:", error);
    return;
  }

  console.log("사용자 데이터:", data);
});

console.log("데이터 요청 완료 (실제로는 아직 진행 중)");
```

**콜백의 장단점**:

- **장점**: 간단하고 직관적
- **단점**: 콜백 지옥(Callback Hell), 에러 처리 복잡성

### 2. Promise

Promise는 비동기 작업의 결과를 나타내는 객체로, 콜백의 한계를 극복하기 위해 도입되었습니다.

- **체이닝**: .then()을 통한 연속적인 비동기 처리
- **에러 처리**: .catch()를 통한 통합된 에러 처리
- **가독성**: 콜백 지옥 방지

### 3. async/await

async/await는 Promise를 더 직관적으로 사용할 수 있게 해주는 문법적 설탕(Syntactic Sugar)입니다.

- **동기적 코드와 유사**: 비동기 코드를 동기 코드처럼 작성
- **에러 처리**: try-catch 블록 사용 가능
- **가독성**: 코드 흐름을 쉽게 파악 가능

## 🔗 Promise 상세 가이드

**Promise**는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 비동기 작업의 최종 완료(또는 실패)와 그 결과값을 나타내는 표준화된 방법을 제공합니다.

### Promise의 3가지 상태

1. **Pending (대기)**: 초기 상태, 아직 완료되지 않음
2. **Fulfilled (이행)**: 작업이 성공적으로 완료됨
3. **Rejected (거부)**: 작업이 실패함

### Promise.all()

모든 Promise가 완료될 때까지 기다립니다. 하나라도 실패하면 모두 실패 처리합니다.

#### Promise.allSettled()

모든 Promise가 완료될 때까지 기다리며, 성공/실패 여부와 관계없이 결과를 모두 반환합니다.

#### Promise.any()

가장 먼저 성공한 **결과**를 반환하고 즉시 종료됩니다.

### async/await

Promise를 더 읽기 쉽게 사용할 수 있는 문법입니다.

### 🚫 AbortController

**AbortController**는 하나 이상의 웹 요청을 취소할 수 있게 해주는 인터페이스입니다.

### 기본 사용법

```javascript
// AbortController 생성
const controller = new AbortController();
const signal = controller.signal;

// fetch 요청에 signal 전달
fetch("/api/data", { signal })
  .then((response) => response.json())
  .then((data) => console.log("데이터:", data))
  .catch((error) => {
    if (error.name === "AbortError") {
      console.log("요청이 취소됨");
    } else {
      console.error("다른 오류:", error);
    }
  });

// 요청 취소
setTimeout(() => {
  controller.abort();
}, 5000); // 5초 후 취소
```

## 📊 Promise와 AbortController의 장단점

### Promise 장점

- 비동기 코드를 동기적으로 작성 가능
- 에러 처리가 체계적
- 체이닝을 통한 가독성 향상
- 표준화된 비동기 처리 방법

### Promise 단점

- 콜백 지옥 대신 Promise 지옥 가능성
- 디버깅이 복잡할 수 있음
- 메모리 누수 가능성 (취소되지 않는 Promise)

### AbortController 장점

- 진행 중인 요청을 명시적으로 취소 가능
- 메모리 누수 방지
- 사용자 경험 향상 (불필요한 요청 중단)

### AbortController 단점

- 모든 API에서 지원하지 않음
- 구현이 복잡할 수 있음
- 브라우저 호환성 고려 필요

## 🎯 결론

Promise와 AbortController는 현대 JavaScript에서 비동기 작업을 효율적으로 처리하는 핵심 도구입니다. Promise는 비동기 작업의 결과를 체계적으로 처리하고, AbortController는 불필요한 요청을 취소하여 성능과 사용자 경험을 향상시킵니다.

적절한 상황에서 이 두 기술을 조합하여 사용한다면, 강력하고 사용자 친화적인 비동기 애플리케이션을 구축할 수 있습니다. 동기와 비동기의 개념을 이해하고, 각각의 장단점을 파악하여 상황에 맞는 적절한 패턴을 선택하는 것이 중요합니다.
