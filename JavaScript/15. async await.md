async function은 함수를 비동기 함수로 선언합니다. 이벤트 루프를 통해 비동기적으로 작동하는 함수로, 암시적으로 Promise를 사용하여 결과를 반환합니다.

함수가 일반 값을 반환하더라도, async가 붙으면 자바스크립트는 그 값을 자동으로 Promise.resolve()로 감싸서 프로미스 객체를 반환합니다. 즉, 함수의 반환 값을 항상 Promise로 '규격화'해 줍니다.

await는 일반적으로 Promise를 표현식으로 전달하여 해당 프로미스를 언랩하는 데 사용됩니다. await를 사용하면 해당 Promise 상태가 settled 될 때까지 async 함수의 실행이 일시 중단됩니다. 함수가 일시 중단되는 순간, async 함수는 제어권을 메인 스레드로 반환합니다. 이전에 중단했던 다른 작업(예: 렌더링, 이벤트 처리)을 계속해서 처리합니다.

```javascript
function resolveAfter2Seconds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("resolved");
    }, 2000);
  });
}

async function asyncCall() {
  const result = await resolveAfter2Seconds();
  // Expected output: "resolved"
}

asyncCall();
```

new Promise() 생성자 내부 코드가 동기적으로 즉시 실행되어 프로미스가 곧바로 완료(Settled)되더라도, 반환값이 프로미스 객체인 이상 호출하는 곳에서는 그 값을 추출하기 위해 await을 사용합니다. 이는 Promise 객체가 완료될 때까지 기다렸다가 내부의 최종 값을 추출하여 변수에 할당해 주는 역할을 합니다.

new Promise() 생성자는 자체적으로 프로미스 객체를 반환합니다. 따라서 async 키워드로 래핑할 필요가 없습니다. 하지만 반환값이 Promise 객체가 아니라 다른 자료구조라면 우리는 항상 async로 래핑해 주어야 합니다. 예를 들어, Promise 객체를 순회하며 배열에 넣고 실행된 값을 반환한다면 이렇게 구현할 수 있습니다.

```javascript
async function promiseFunc() {
  let stack = [];
  for (let i = 1; i <= 3; i++) {
    let time = i * 1000;
    stack.push(
      new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve(i);
        }, time);
      })
    );
  }
  return stack;
}

async function main() {
  const result = await promiseFunc();
  console.log(result);
}

main();
```

하지만 위의 코드는 우리가 예상한 대로 실행되지 않습니다. Promise는 생성되는 즉시 시작되고, 그 객체들이 배열에 pending 상태로 담깁니다. async function이므로 반환값이 Promise.resolve로 감싸집니다. 즉시 완료되는 것이므로 stack 배열 안에 담긴 pending Promise 객체들이 실행 여부와 관계없이 성공적으로 반환되고 즉시 완료됩니다.

이를 해결하려면 for 루프 내에서 각 Promise가 끝날 때까지 await로 순차적으로 기다리게 만들어야 합니다. 각 반복은 이전 반복이 완전히 완료될 때까지 기다렸다가 시작되므로 (1+2+3) 총 6초가 소요됩니다.

```javascript
for (let i = 1; i <= 3; i++) {
  let time = i * 1000;

  await new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Resolved: ${i} (after ${time / 1000}s)`);
      resolve(i);
    }, time);
  });
}
```

여전히 Promise가 생성될 때 모든 비동기 처리를 병렬적으로 진행하고 싶다면, 반환값을 Promise로 강제 래핑해줘야 합니다. 최대 (1,2,3) 3초에 걸쳐 진행됩니다.

```javascript
async function promiseFunc() {
  let stack = [];
  for (let i = 1; i <= 3; i++) {
    let time = i * 1000;
    stack.push(
      new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve(i);
        }, time);
      })
    );
  }
  return Promise.all(stack);
}
```
