# this 바인딩 (This Binding)

## 📖 개요

JavaScript에서 `this`는 함수가 호출되는 방식에 따라 동적으로 결정되는 특별한 키워드입니다. `this`의 값은 함수를 **어떻게 호출했는지**에 따라 달라지며, 이는 객체지향 프로그래밍에서 매우 중요한 개념입니다.

## 🔍 this 바인딩의 기본 원리

### 기본 규칙

1. **함수 호출 방식**에 따라 `this`가 결정됨
2. **선언 위치**가 아닌 **호출 시점**에 바인딩

```javascript
const person = {
  name: "마멋",
  sayHi() {
    console.log(`안녕, 나는 ${this.name}`);
  }),
};

person.sayHi(); // 안녕, 나는 마멋
```

### this 바인딩 문제점

```javascript
const user = {
  name: "Leo",
  logName: function () {
    console.log(this.name); // 'Leo'

    setTimeout(function () {
      // 일반 함수이므로 this는 전역 객체를 가리킵니다.
      console.log(this.name); // 'undefined' (또는 window.name)
    }, 100);
  },
};

user.logName();
```

**동작 원리**:

- **`user.logName()` 호출**: `logName`은 `user` 객체의 **메서드**로 호출됩니다. 이 경우, `this`는 메서드를 소유한 객체인 `user`를 가리킵니다. 따라서 첫 번째 `console.log(this.name)`은 `'Leo'`를 출력합니다.
- **`setTimeout`의 콜백 함수 호출**: `setTimeout`에 전달된 함수는 별도의 객체 없이 단독으로 호출되는 **일반 함수**입니다. 자바스크립트는 기본적으로 이 `this`를 전역 객체(브라우저의 `window` 또는 Node.js의 `global`)에 바인딩합니다. 전역 객체에는 `name`이라는 속성이 없거나 비어있는 경우가 많으므로, 두 번째 `console.log(this.name)`은 `'undefined'` 또는 빈 문자열을 출력합니다.

## ⚡ 화살표 함수로 해결

화살표 함수는 위와 같은 문제를 해결하기 위해 도입되었습니다. 화살표 함수는 **자신을 둘러싼 외부(렉시컬) 스코프**의 this를 그대로 가져옵니다. 즉, 함수가 **어디서 호출되든 관계없이 this가 고정**됩니다.

```javascript
const user = {
  name: "Leo",
  logName: function () {
    console.log(this.name); // 'Leo'

    setTimeout(() => {
      // 화살표 함수는 상위 스코프(logName 메서드)의 this를 상속받습니다.
      console.log(this.name); // 'Leo'
    }, 100);
  },
};

user.logName();
```

이 예시에서 `setTimeout` 내의 화살표 함수는 `logName` 메서드의 `this`를 상속받아 `user` 객체를 가리키게 됩니다. 이처럼 `this`가 정적으로 결정되기 때문에 **콜백 함수를 다룰 때 매우 유용**합니다.

## 🔄 바인딩 우선순위

**우선순위 (높음 → 낮음)**:

1. **new 바인딩** (가장 높음)
2. **명시적 바인딩** (call, apply, bind)
3. **암시적 바인딩** (객체 메서드)
4. **기본 바인딩** (가장 낮음)

## 이벤트 리스너에서의 this

```javascript
const button = document.querySelector("button");

// 문제가 있는 코드
button.addEventListener("click", function () {
  console.log(this); // button 요소
  // 하지만 setTimeout 내부에서는 this가 손실됨
  setTimeout(function () {
    console.log(this); // window 또는 undefined
  }, 100);
});

// 해결: 화살표 함수 사용
button.addEventListener("click", function () {
  console.log(this); // button 요소
  setTimeout(() => {
    console.log(this); // button 요소 (렉시컬 this)
  }, 100);
});
```

## 📚 학습 포인트

1. **this는 호출 시점에 결정**되며, 선언 위치와 무관
2. **4가지 바인딩 규칙**을 이해하고 우선순위 파악
3. **화살표 함수**는 렉시컬 this를 사용
4. **콜백 함수**에서 this 손실 주의
