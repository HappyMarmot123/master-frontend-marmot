# Map

## 📖 개요

자바에 HashMap이 있다면, 자바스크립트는 Map이 있습니다. 자바스크립트의 Map은 **키(key)**와 **값(value)**의 쌍으로 이루어진 컬렉션입니다. 
Map은 특정 키(key)를 이용해 값을 효율적으로 검색하거나 추가, 삭제하는 것에 특화된 자료구조로 입니다.
객체와 비슷해 보이지만, 다음과 같은 중요한 차이점 때문에 더 유연하게 사용할 수 있습니다.

## 🏗️ Map의 주요 특징

### 1. 다양한 키 타입 지원

Map은 키로 어떤 타입이든 사용할 수 있습니다. 객체, 함수, 심지어 다른 Map까지도 키로 쓸 수 있습니다. 반면 일반 객체는 키로 문자열 또는 심볼만 허용합니다. 이는 Map의 가장 큰 장점 중 하나로, 복잡한 데이터 구조를 키로 사용할 수 있어 다양한 시나리오에서 활용할 수 있습니다.

### 2. 삽입 순서 보장

Map은 요소들이 추가된 순서를 기억하고 유지합니다. 따라서 순서가 중요한 작업을 할 때 유용합니다. 일반 객체는 속성의 순서를 보장하지 않으며, 특히 숫자 키가 포함된 경우 순서가 예측하기 어려울 수 있습니다.

**순서 보장의 장점**:

- **반복 순서 예측 가능**: for...of 루프에서 항상 같은 순서로 요소에 접근
- **데이터 처리 순서**: 로그, 히스토리, 타임라인 등 순서가 중요한 데이터 관리
- **사용자 인터페이스**: UI 컴포넌트의 렌더링 순서 제어

### 3. 뛰어난 성능

Map은 **해시 테이블 기반**으로 구현되어 추가, 삭제, 검색 상황에서 평균적으로 O(1) 시간 복잡도를 보여줍니다. 이는 대량의 데이터를 다룰 때 일반 객체보다 훨씬 효율적입니다.

**성능 특징**:

- **빠른 검색**: 키를 통한 값 검색이 매우 빠름
- **효율적인 삽입/삭제**: 요소 추가 및 제거가 빠름
- **메모리 효율성**: 해시 테이블 구조로 인한 효율적인 메모리 사용

## 🔍 Map vs 일반 객체 비교

### 키 타입 제한

**일반 객체**:

- 키는 문자열, 숫자, 심볼만 허용
- 숫자 키는 자동으로 문자열로 변환
- 객체 키는 문자열로 변환되어 사용

**Map**:

- 모든 타입의 키 허용
- 키의 타입이 정확히 보존됨
- 객체 참조를 키로 사용 가능

### 순서 보장

**일반 객체**:

- ES2015 이후 삽입 순서가 보장되지만, 숫자 키가 포함된 경우 예외
- 숫자 키는 오름차순으로 정렬되어 표시
- 문자열 키는 삽입 순서 유지

**Map**:

- 모든 키에 대해 삽입 순서 완벽 보장
- 숫자 키도 삽입 순서대로 유지
- 예측 가능한 반복 순서

### 성능 특성

**일반 객체**:

- 작은 데이터셋에서는 빠름
- 대량 데이터에서는 성능 저하
- 프로토타입 체인 검색으로 인한 오버헤드

**Map**:

- 일관된 성능 (O(1))
- 대량 데이터에서도 안정적인 성능
- 프로토타입 체인 검색 없음

## 💡 Map의 기본 사용법

### 1. Map 생성

```javascript
// 빈 Map 생성
const userMap = new Map();

// 초기값과 함께 생성
const configMap = new Map([
  ["apiUrl", "https://api.example.com"],
  ["timeout", 5000],
  ["retries", 3],
]);
```

### 2. 기본 CRUD 작업

```javascript
const userMap = new Map();

// 값 추가 (set)
userMap.set("name", "철수");
userMap.set(123, "순이");
userMap.set(true, "성공");

// 값 조회 (get)
console.log(userMap.get("name")); // '철수'

// 키 존재 여부 확인 (has)
console.log(userMap.has("name")); // true

// 값 삭제 (delete)
userMap.delete(true);

// 전체 삭제 (clear)
userMap.clear();
```

### 3. 반복 및 순회

```javascript
const userMap = new Map([
  ["name", "영희"],
  ["age", 25],
  ["city", "서울"],
]);

// 키와 값을 모두 순회
for (const [key, value] of userMap) {
  console.log(`${key}: ${value}`);
}

// forEach 사용
userMap.forEach((value, key) => {
  console.log(`${key}는 ${value}입니다.`);
});

// 키만 순회
for (const key of userMap.keys()) {
  console.log(key);
}

// 값만 순회
for (const value of userMap.values()) {
  console.log(value);
}
```

## 🎯 Map의 실제 활용 사례

### 1. 캐싱 시스템

Map은 함수 결과나 계산된 값을 캐싱하는 데 매우 유용합니다. 키로 함수나 입력값을 사용하여 결과를 저장하고, 동일한 입력에 대해 재계산을 피할 수 있습니다.

**캐싱의 장점**:

- **성능 향상**: 반복적인 계산 방지
- **메모리 효율성**: 필요한 데이터만 저장
- **응답 속도**: 캐시된 결과 즉시 반환

### 2. 사용자 세션 관리

웹 애플리케이션에서 사용자별 세션 정보를 관리할 때 Map을 사용할 수 있습니다. 사용자 ID를 키로 하고, 세션 정보를 값으로 저장하여 효율적으로 관리할 수 있습니다.

**세션 관리의 장점**:

- **빠른 접근**: 사용자 ID로 즉시 세션 정보 검색
- **순서 보장**: 로그인 순서대로 세션 관리
- **유연한 구조**: 다양한 세션 데이터 저장

### 3. 이벤트 리스너 관리

DOM 이벤트나 커스텀 이벤트의 리스너를 관리할 때 Map을 사용할 수 있습니다. 이벤트 타입을 키로 하고, 해당 이벤트에 등록된 리스너들을 값으로 저장할 수 있습니다.

**이벤트 관리의 장점**:

- **효율적인 등록/해제**: 특정 이벤트의 리스너만 관리
- **중복 방지**: 동일한 리스너 중복 등록 방지
- **메모리 누수 방지**: 이벤트 해제 시 정확한 리스너 제거

### 4. 데이터 정규화

복잡한 데이터 구조를 정규화하여 저장할 때 Map을 사용할 수 있습니다. ID를 키로 하고, 정규화된 데이터를 값으로 저장하여 관계형 데이터를 효율적으로 관리할 수 있습니다.

**데이터 정규화의 장점**:

- **중복 제거**: 동일한 데이터의 중복 저장 방지
- **일관성 유지**: 데이터 업데이트 시 한 곳에서만 수정
- **효율적인 검색**: ID 기반 빠른 데이터 접근

## ⚠️ Map 사용 시 주의사항

### 1. 메모리 관리

Map은 강한 참조를 사용하므로, 키로 사용된 객체가 다른 곳에서 참조되지 않으면 가비지 컬렉션의 대상이 됩니다. 하지만 Map 자체가 해당 객체를 참조하고 있으므로, Map이 존재하는 한 객체는 메모리에 유지됩니다.

**메모리 누수 방지**:

- **WeakMap 사용**: 키가 약한 참조인 WeakMap 사용 고려
- **정기적 정리**: 사용하지 않는 항목 주기적 제거
- **참조 해제**: Map 사용 완료 후 clear() 호출

### 2. 직렬화 제한

Map은 JSON.stringify()로 직렬화할 수 없습니다. Map을 JSON으로 변환하려면 먼저 배열로 변환해야 합니다.

**직렬화 방법**:

```javascript
const map = new Map([
  ["key1", "value1"],
  ["key2", "value2"],
]);

// Map을 배열로 변환 후 직렬화
const jsonString = JSON.stringify(Array.from(map));
console.log(jsonString); // [["key1","value1"],["key2","value2"]]

// 역직렬화
const reconstructedMap = new Map(JSON.parse(jsonString));
```

## 🔧 Map 성능 최적화

### 1. 초기 크기 설정

Map을 생성할 때 예상되는 요소 개수를 미리 설정하면 초기 할당을 최적화할 수 있습니다.

```javascript
// 예상 요소 개수가 1000개인 경우
const largeMap = new Map();
// vs
const optimizedMap = new Map(1000); // 초기 용량 설정
```

### 2. 배치 작업 활용

여러 요소를 한 번에 추가할 때는 개별 set() 호출보다 초기값 배열을 사용하는 것이 효율적입니다.

```javascript
// 비효율적: 개별 set() 호출
const map1 = new Map();
for (let i = 0; i < 1000; i++) {
  map1.set(`key${i}`, `value${i}`);
}

// 효율적: 초기값 배열 사용
const entries = Array.from({ length: 1000 }, (_, i) => [
  `key${i}`,
  `value${i}`,
]);
const map2 = new Map(entries);
```

### 3. 적절한 키 타입 선택

키로 사용할 타입을 신중하게 선택해야 합니다. 객체나 함수를 키로 사용하면 참조 동등성에 의존하게 되므로, 예상치 못한 동작이 발생할 수 있습니다.

**키 타입 선택 가이드**:

- **원시 타입**: 단순한 값 저장 시 사용
- **객체**: 복잡한 데이터 구조를 키로 사용해야 할 때
- **함수**: 함수별 설정이나 캐시를 관리할 때
