# 웹 보안

## 개요

웹 보안은 웹 애플리케이션과 웹사이트를 다양한 공격으로부터 보호하는 것입니다. 사용자 데이터 보호와 서비스 안정성을 위해 필수적입니다.

**웹 보안이 현대 웹 개발에서 중요한 이유:**
웹 보안은 단순한 기술적 요구사항을 넘어서 사용자 신뢰와 비즈니스 지속가능성을 보장하는 핵심 요소입니다. 보안 취약점은 사용자의 개인정보 유출, 금융적 손실, 브랜드 이미지 훼손 등 심각한 결과를 초래할 수 있으며, 이는 웹 애플리케이션의 성공과 실패를 가르는 중요한 기준이 됩니다.

**웹 보안의 다층적 접근:**
웹 보안은 단일 기술이나 도구로 해결할 수 있는 문제가 아닙니다. 애플리케이션 레벨, 네트워크 레벨, 인프라 레벨 등 다양한 계층에서의 보안 조치가 필요하며, 각 계층은 서로 보완적인 역할을 합니다. 개발자는 이러한 다층적 보안 구조를 이해하고, 각 계층에 적절한 보안 조치를 구현해야 합니다.

## 주요 보안 위협

### 1. OWASP Top 10

- **Injection**: SQL, NoSQL, OS 명령어 주입
- **Broken Authentication**: 인증 취약점
- **Sensitive Data Exposure**: 민감 데이터 노출
- **XML External Entities (XXE)**: XML 외부 엔티티 공격
- **Broken Access Control**: 접근 제어 취약점
- **Security Misconfiguration**: 보안 설정 오류
- **Cross-Site Scripting (XSS)**: 크로스 사이트 스크립팅
- **Insecure Deserialization**: 안전하지 않은 역직렬화
- **Using Components with Known Vulnerabilities**: 알려진 취약점이 있는 컴포넌트 사용
- **Insufficient Logging & Monitoring**: 불충분한 로깅 및 모니터링

## SQL Injection 방어

SQL Injection은 악의적인 사용자가 웹 애플리케이션의 입력 필드를 통해 임의의 SQL 코드를 삽입하여 데이터베이스를 조작하는 공격입니다. 이를 통해 데이터를 무단으로 조회, 수정, 삭제할 수 있으며, 시스템 전체를 장악할 수도 있습니다.

### 1. SQL Injection 공격 예시

```sql
-- 취약한 쿼리
SELECT * FROM users WHERE username = '$username' AND password = '$password'

-- 공격자가 입력한 값
username: admin' --
password: anything

-- 결과적으로 실행되는 쿼리
SELECT * FROM users WHERE username = 'admin' --' AND password = 'anything'
-- 주석 처리되어 admin 계정으로 로그인 성공
```

### 2. 방어 방법

**Prepared Statements (준비된 구문):** 사용자의 입력을 SQL 쿼리의 일부가 아닌 데이터로 취급하게 만듭니다. 데이터베이스는 먼저 쿼리의 구조를 컴파일하고, 그 후에 사용자 입력을 파라미터로 바인딩합니다. 이렇게 하면 입력값이 쿼리 문법으로 해석되지 않아 인젝션 공격을 원천적으로 차단할 수 있습니다.

**ORM (Object-Relational Mapping):** Sequelize와 같은 ORM 라이브러리는 내부적으로 Prepared Statements를 사용하여 안전한 쿼리를 생성합니다. 개발자가 직접 SQL 쿼리를 작성하지 않고 객체지향적인 방식으로 데이터베이스와 상호작용하므로, SQL Injection과 같은 일반적인 취약점을 방지하는 데 도움이 됩니다.

```javascript
// Node.js - Prepared Statement 사용
const mysql = require("mysql2");

const connection = mysql.createConnection({
  host: "localhost",
  user: "username",
  password: "password",
  database: "database",
});

// 안전한 방법
const query = "SELECT * FROM users WHERE username = ? AND password = ?";
connection.execute(query, [username, password], (err, results) => {
  if (err) throw err;
  console.log(results);
});

// Express.js - ORM 사용
const { User } = require("./models");

// Sequelize ORM
const user = await User.findOne({
  where: {
    username: username,
    password: password,
  },
});
```

## XSS (Cross-Site Scripting) 방어

XSS (Cross-Site Scripting)는 공격자가 웹 애플리케이션에 악성 스크립트를 삽입하여 다른 사용자의 브라우저에서 실행되게 하는 공격입니다. 이를 통해 사용자의 세션 쿠키를 탈취하거나, 개인정보를 빼내거나, 웹사이트의 내용을 변조할 수 있습니다.

### 1. XSS 공격 유형

**Stored XSS (저장형 XSS):** 악성 스크립트가 데이터베이스나 파일 시스템과 같이 서버에 저장되었다가, 사용자가 특정 페이지를 요청할 때마다 해당 스크립트가 포함된 응답이 전송되어 실행되는 유형입니다. 게시판, 댓글 등에서 주로 발생합니다.
**Reflected XSS (반사형 XSS):** 악성 스크립트가 URL 파라미터 등에 포함되어 서버로 전송되고, 서버가 해당 스크립트를 그대로 응답에 포함하여 사용자에게 반사(reflect)시킬 때 발생합니다. 사용자가 악성 링크를 클릭하도록 유도해야 합니다.
**DOM-based XSS (DOM 기반 XSS):** 서버와는 무관하게 브라우저의 DOM(Document Object Model) 환경에서 발생하는 XSS입니다. 악성 스크립트가 포함된 URL을 사용자가 요청하면, 클라이언트 측 스크립트가 DOM을 조작하는 과정에서 악성 스크립트가 실행됩니다.

```html
<!-- Stored XSS 예시: 게시판에 악성 스크립트 저장 -->
<script>
  alert("XSS");
</script>
<img src="x" onerror="alert('XSS')" />
<svg onload="alert('XSS')">
  <!-- Reflected XSS 예시: URL 파라미터에 악성 스크립트 포함 -->
  https://example.com/search?q=
  <script>
    alert('XSS')
  </script>

  <!-- DOM-based XSS 예시: URL 해시를 DOM에 직접 삽입 -->
  <script>
    // URL: https://example.com#<img src=x onerror=alert('XSS')>
    document.getElementById('content').innerHTML = location.hash.substring(1);
  </script>
</svg>
```

### 2. 방어 방법

**입력 데이터 검증 및 이스케이프:** 사용자로부터 입력받은 데이터에 포함될 수 있는 스크립트 관련 문자(예: `<`, `>`, `"` 등)를 HTML 엔티티(`&lt;`, `&gt;`, `&quot;` 등)로 변환(이스케이프)하여 스크립트가 실행되지 않도록 합니다. 서버 측과 클라이언트 측 모두에서 검증하는 것이 안전합니다.
**출력 시 이스케이프:** 데이터베이스나 파일에서 읽어온 데이터를 HTML에 출력할 때, 해당 데이터에 포함된 스크립트가 실행되지 않도록 이스케이프 처리를 해야 합니다. 이는 Stored XSS를 방어하는 데 필수적입니다.
**Content Security Policy (CSP):** 브라우저에 신뢰할 수 있는 스크립트 소스를 명시하여, 허용되지 않은 외부 스크립트가 실행되는 것을 방지하는 강력한 보안 정책입니다. `Content-Security-Policy` HTTP 헤더를 통해 설정할 수 있습니다.

```javascript
// 1. 입력 데이터 검증 및 이스케이프
const validator = require("validator");

function sanitizeInput(input) {
  return validator.escape(input);
}

// 2. 출력 시 이스케이프
const escapeHtml = require("escape-html");

app.get("/search", (req, res) => {
  const query = req.query.q;
  const sanitizedQuery = escapeHtml(query);
  res.send(`검색 결과: ${sanitizedQuery}`);
});

// 3. Content Security Policy 설정
app.use((req, res, next) => {
  res.setHeader(
    "Content-Security-Policy",
    "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"
  );
  next();
});
```

## CSRF (Cross-Site Request Forgery) 방어

CSRF (Cross-Site Request Forgery)는 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다. 사용자가 로그인된 상태의 브라우저를 이용해 악성 스크립트가 있는 페이지에 방문하면 발생할 수 있습니다.

### 1. CSRF 공격 예시

```html
<!-- 악의적인 사이트에서 실행되는 코드 -->
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="amount" value="1000" />
  <input type="hidden" name="to" value="attacker" />
  <input type="submit" value="클릭하세요" />
</form>

<script>
  document.forms[0].submit();
</script>
```

### 2. 방어 방법

**CSRF 토큰 사용:** 서버는 사용자 세션에 무작위의 고유한 토큰(CSRF 토큰)을 저장하고, 모든 상태 변경 요청에 이 토큰을 포함하도록 요구합니다. 서버는 요청을 받을 때마다 세션에 저장된 토큰과 요청에 포함된 토큰을 비교하여 요청의 유효성을 검증합니다. 이 방법이 가장 강력하고 널리 사용됩니다.
**SameSite 쿠키 설정:** 쿠키의 `SameSite` 속성을 `Strict` 또는 `Lax`로 설정하여, 다른 도메인에서 시작된 요청에 쿠키가 전송되지 않도록 제한합니다. 이를 통해 다른 사이트에서 위조된 요청이 발생하더라도 인증 쿠키가 전송되지 않아 CSRF 공격을 방어할 수 있습니다.
**Referer 헤더 검증:** 요청의 `Referer` 헤더를 확인하여, 요청이 허용된 도메인에서 시작되었는지 검증하는 방법입니다. 그러나 `Referer` 헤더는 비어 있거나 조작될 수 있어 보조적인 방어 수단으로 사용해야 합니다.

```javascript
// 1. CSRF 토큰 사용
const csrf = require("csurf");
const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get("/form", (req, res) => {
  res.render("form", { csrfToken: req.csrfToken() });
});

app.post("/transfer", csrfProtection, (req, res) => {
  // CSRF 토큰 검증
  res.send("Transfer successful");
});

// 2. SameSite 쿠키 설정
app.use(
  session({
    secret: "your-secret",
    cookie: {
      secure: true,
      httpOnly: true,
      sameSite: "strict",
    },
  })
);

// 3. Referer 헤더 검증
app.use((req, res, next) => {
  const referer = req.get("Referer");
  if (referer && !referer.startsWith("https://yourdomain.com")) {
    return res.status(403).send("Forbidden");
  }
  next();
});
```

## 인증 및 권한 관리

### 1. 안전한 비밀번호 정책

비밀번호는 절대 평문으로 저장해서는 안 됩니다. `bcrypt`와 같은 강력한 해시 함수를 사용하여 비밀번호를 해시하고, 솔트(salt)를 추가하여 레인보우 테이블 공격을 방지해야 합니다. 또한, 비밀번호 복잡도(길이, 대소문자, 숫자, 특수문자 조합) 정책을 강제하여 사용자가 추측하기 어려운 비밀번호를 사용하도록 유도해야 합니다.

```javascript
const bcrypt = require("bcrypt");
const passwordValidator = require("password-validator");

const schema = new passwordValidator();

schema
  .is()
  .min(8)
  .is()
  .max(100)
  .has()
  .uppercase()
  .has()
  .lowercase()
  .has()
  .digits()
  .has()
  .symbols()
  .has()
  .not()
  .spaces();

function validatePassword(password) {
  return schema.validate(password);
}

async function hashPassword(password) {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
}

async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash);
}
```

### 2. JWT 토큰 관리

JWT(JSON Web Token)는 사용자 인증 및 권한 정보를 안전하게 전달하는 간결한 방법입니다. 토큰에 사용자 ID, 역할(role) 등의 정보를 담고, 비밀 키로 서명하여 위변조를 방지합니다. 서버는 요청 헤더에 포함된 JWT를 검증하여 사용자를 인증하고, 토큰에 포함된 역할 정보를 기반으로 특정 리소스에 대한 접근 권한을 제어할 수 있습니다.

```javascript
const jwt = require("jsonwebtoken");

// 토큰 생성
function generateToken(user) {
  return jwt.sign(
    {
      userId: user.id,
      email: user.email,
      role: user.role,
    },
    process.env.JWT_SECRET,
    {
      expiresIn: "1h",
      issuer: "your-app",
      audience: "your-app-users",
    }
  );
}

// 토큰 검증
function verifyToken(token) {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    throw new Error("Invalid token");
  }
}

// 권한 검증 미들웨어
function requireRole(role) {
  return (req, res, next) => {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) {
      return res.status(401).json({ message: "Token required" });
    }

    try {
      const decoded = verifyToken(token);
      if (decoded.role !== role && decoded.role !== "admin") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      req.user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({ message: "Invalid token" });
    }
  };
}
```

## 파일 업로드 보안

파일 업로드는 웹 셸(web shell)과 같은 악성 파일이 서버에 업로드되어 실행될 경우 심각한 보안 위협이 될 수 있습니다. 따라서 파일 업로드 기능은 신중하게 구현해야 합니다.

### 1. 안전한 파일 업로드

다음과 같은 조치를 통해 파일 업로드 취약점을 방어할 수 있습니다:

- **파일 타입 검증:** `Content-Type` 헤더(MIME 타입)와 파일 확장자를 모두 검증하여 허용된 파일 형식만 업로드되도록 제한합니다.
- **파일 크기 제한:** 비정상적으로 큰 파일 업로드를 막아 서비스 거부(DoS) 공격을 방지합니다.
- **안전한 파일명 사용:** 사용자가 입력한 파일명 대신, 서버에서 임의의 고유한 파일명을 생성하여 저장합니다. 이는 경로 조작(Path Traversal) 공격을 방지하는 데 도움이 됩니다.
- **실행 권한 제거:** 업로드된 파일이 저장되는 디렉토리의 실행 권한을 제거하여, 웹 셸과 같은 스크립트가 실행되지 않도록 합니다.

```javascript
const multer = require("multer");
const path = require("path");

// 파일 타입 검증
const fileFilter = (req, file, cb) => {
  const allowedTypes = ["image/jpeg", "image/png", "image/gif"];

  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error("Invalid file type"), false);
  }
};

// 파일 크기 제한
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/");
  },
  filename: (req, file, cb) => {
    // 원본 파일명 대신 안전한 파일명 생성
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
    files: 1,
  },
});

// 파일 확장자 검증
function validateFileExtension(filename) {
  const allowedExtensions = [".jpg", ".jpeg", ".png", ".gif"];
  const ext = path.extname(filename).toLowerCase();
  return allowedExtensions.includes(ext);
}
```

## 보안 헤더 설정

### 1. 보안 헤더 미들웨어

```javascript
const helmet = require("helmet");

app.use(helmet());

// 추가 보안 헤더
app.use((req, res, next) => {
  // XSS 방지
  res.setHeader("X-XSS-Protection", "1; mode=block");

  // 클릭재킹 방지
  res.setHeader("X-Frame-Options", "DENY");

  // MIME 타입 스니핑 방지
  res.setHeader("X-Content-Type-Options", "nosniff");

  // HSTS (HTTPS 강제)
  res.setHeader(
    "Strict-Transport-Security",
    "max-age=31536000; includeSubDomains"
  );

  // Content Security Policy
  res.setHeader(
    "Content-Security-Policy",
    "default-src 'self'; " +
      "script-src 'self' 'unsafe-inline'; " +
      "style-src 'self' 'unsafe-inline'; " +
      "img-src 'self' data: https:; " +
      "font-src 'self'; " +
      "connect-src 'self';"
  );

  next();
});
```

### 2. CORS 설정

```javascript
const cors = require("cors");

const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = [
      "https://yourdomain.com",
      "https://app.yourdomain.com",
    ];

    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"],
};

app.use(cors(corsOptions));
```

## 로깅 및 모니터링

### 1. 보안 이벤트 로깅

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'security.log' }),
    new winston.transports.Console()
  ]
});

// 로그인 시도 로깅
app.post('/login', (req, res) => {
  const { username, ip } = req.body;

  logger.info('Login attempt', {
    username,
    ip,
    timestamp: new Date(),
    userAgent: req.get('User-Agent')
  });

  // 로그인 로직...
});

// 실패한 로그인 시도 모니터링
function monitorFailedLogins(username, ip) {
  const key = `failed_login:${username}:${ip}`;
  const failedCount = await redis.incr(key);

  if (failedCount === 1) {
    await redis.expire(key, 3600); // 1시간 후 만료
  }

  if (failedCount >= 5) {
    logger.warn('Multiple failed login attempts', { username, ip, count: failedCount });
    // 계정 잠금 또는 추가 보안 조치
  }
}
```

### 2. Rate Limiting

```javascript
const rateLimit = require("express-rate-limit");

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 5, // 최대 5번 시도
  message: "Too many login attempts, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    logger.warn("Rate limit exceeded", {
      ip: req.ip,
      endpoint: req.path,
    });
    res.status(429).json({
      error: "Too many requests",
      retryAfter: Math.ceil((15 * 60) / 1000),
    });
  },
});

app.use("/login", loginLimiter);
```

## 요약

웹 보안은 지속적인 학습과 업데이트가 필요한 분야입니다. OWASP 가이드라인을 따르고, 최신 보안 위협에 대한 정보를 습득하며, 보안 테스트를 정기적으로 수행하는 것이 중요합니다.
