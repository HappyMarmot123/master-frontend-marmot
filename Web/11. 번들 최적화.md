# 번들 최적화 (Bundle Optimization)

## 📖 개요

**번들 최적화(Bundle Optimization)** 는 웹 애플리케이션의 JavaScript, CSS, 기타 자산들을 효율적으로 패키징하고 전달하는 기법입니다. 이를 통해 초기 로딩 시간을 단축하고, 사용자 경험을 향상시키며, 네트워크 대역폭을 절약할 수 있습니다.

**단일 번들은 한계가 존재합니다.** 필요하지 않아도 모든 코드를 한 번에 다운로드하여 첫 페이지 로딩 시간 증가로 비효율적입니다. 사용하지 않는 기능이나 라이브러리까지 포함이 되므로 캐싱 효율성도 낮고 메모리 사용량이 증가합니다.

### 번들 최적화의 해결책

- **코드 스플리팅**: 필요한 코드만 로드하여 초기 로딩 시간 단축
- **Tree Shaking**: 사용하지 않는 코드 제거로 번들 크기 감소
- **Minification**: 코드 압축으로 전송 크기 최소화
- **Vendor Chunk**: 라이브러리 코드 분리로 캐싱 효율성 향상

## 1. 코드 스플리팅 (Code Splitting)

**코드 스플리팅(Code Splitting)** 은 웹 애플리케이션의 JavaScript 번들을 여러 개의 작은 청크(chunk)로 나누어 필요할 때만 로드하는 기법입니다. 이를 통해 초기 번들 크기를 줄이고, 사용자가 실제로 필요로 하는 코드만 다운로드하여 웹 성능을 크게 향상시킬 수 있습니다.

Webpack을 활용한 Entry Point **분할**:

```javascript
// webpack.config.js
const path = require("path");

module.exports = {
  entry: {
    main: "./src/main.js",
    vendor: "./src/vendor.js",
  },
  output: {
    filename: "[name].[contenthash].js",
    path: path.resolve(__dirname, "dist"),
    clean: true,
  },
  optimization: {
    splitChunks: {
      chunks: "all",
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: "vendors",
          chunks: "all",
        },
        common: {
          name: "common",
          minChunks: 2,
          chunks: "all",
          enforce: true,
        },
      },
    },
  },
};
```

**Lazy Load(지연 로딩)** 는 웹 페이지의 리소스(이미지, 비디오, 스크립트 등)를 사용자가 실제로 필요로 할 때까지 로딩을 지연시키는 기법입니다. 이를 통해 초기 페이지 로딩 시간을 단축하고, 불필요한 리소스 다운로드를 방지하여 웹 성능을 크게 향상시킬 수 있습니다.

**라우트 기반 코드 스플리팅**:

```jsx
// 페이지별 동적 임포트
const Home = lazy(() => import("./pages/Home"));
const About = lazy(() => import("./pages/About"));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

export default App;
```

프리페칭은 미래 탐색 대비 사전 다운로드를 진행하므로 사용자 행동 예측을 통한 최적화가 가능합니다.

```jsx
// hooks/usePrefetch.js
import { useCallback } from "react";

export const usePrefetch = () => {
  const prefetchComponent = useCallback((importFunc) => {
    // 마우스 호버 시 프리페칭
    importFunc();
  }, []);

  const prefetchOnHover = useCallback(
    (importFunc, delay = 100) => {
      let timeoutId;

      const handleMouseEnter = () => {
        timeoutId = setTimeout(() => {
          prefetchComponent(importFunc);
        }, delay);
      };

      const handleMouseLeave = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      };

      return { handleMouseEnter, handleMouseLeave };
    },
    [prefetchComponent]
  );

  return { prefetchComponent, prefetchOnHover };
};

// 사용 예시
function Navigation() {
  const { prefetchOnHover } = usePrefetch();
  const handleAboutHover = prefetchOnHover(() => import("../pages/About"));
  const handleContactHover = prefetchOnHover(() => import("../pages/Contact"));

  return (
    <nav>
      <a
        href="/about"
        onMouseEnter={handleAboutHover.handleMouseEnter}
        onMouseLeave={handleAboutHover.handleMouseLeave}
      >
        소개
      </a>
    </nav>
  );
}
```

### 주의사항

과도한 분할은 비효율 적입니다. 코드를 매우 작은 여러 파일(청크)로 분할하면, 브라우저가 다운로드해야 할 파일의 수가 기하급수적으로 늘어납니다.

대부분의 브라우저는 한 번에 동일한 도메인으로 보낼 수 있는 **동시 요청 수를 제한**합니다. 일반적으로 이 제한은 6개에서 8개 사이입니다. 만약 분할된 청크 파일이 이 제한보다 많아지면, 일부 요청은 앞선 요청이 완료될 때까지 **대기**해야 합니다. 이는 다운로드 병목 현상을 초래하여 페이지 로딩을 지연시킵니다.

### 2. Tree Shaking 최적화

트리 셰이킹은 나무를 흔들어 죽은 잎을 떨어뜨리는 것에 비유됩니다. 애플리케이션의 사용되지 않는 코드를 제거하는 것은 번들 크기와 로딩 속도를 개선합니다.

**사용하지 않는 코드 제거 (핵심 스니펫)**:

```javascript
// math.js — 개별 export 필수 (default 통합 export 지양)
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;

// 사용처 — 필요한 것만 import
import { add } from "./math.js";
console.log(add(2, 3));
```

**Webpack 설정 (간단 버전)**:

```javascript
// webpack.config.js
module.exports = {
  mode: "production",
  optimization: { usedExports: true, sideEffects: false, minimize: true },
};
```

**핵심 포인트**

- ESM의 named export만 Tree Shaking 대상이 되기 쉬움
- `sideEffects: false`는 CSS-in-JS, 폴리필 등 부작용 모듈에 주의(화이트리스트 필요)
- 동적 require/namespace import는 제거 불가 → 구조 개선

### 3. Minification 최적화

**JavaScript 코드 압축 (핵심 스니펫)**

```bash
npx terser src/app.js -c -m -o dist/app.min.js
```

**핵심 포인트**

- `-c`(compress), `-m`(mangle)로 크기 최소화, Sourcemap은 배포 채널에 따라 분리 제공
- 로깅 제거는 빌드 타깃/환경변수로 제어(무조건 drop_console 지양)

### 4. Vendor Chunk 최적화

**라이브러리 코드 분리 (간단 버전)**

```javascript
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: "all",
      minSize: 20000,
      maxAsyncRequests: 30,
      maxInitialRequests: 30,
    },
  },
};
```

**핵심 포인트**

- 프레임워크/대형 라이브러리는 청크로 분리해 캐시 히트율↑, 앱 코드 변경 시 재다운로드 최소화
- 너무 세분화된 cacheGroup은 요청 수↑ → 균형점 찾기

**동적 Import (핵심 스니펫)**

```javascript
// 조건부 로딩 — 경로 기준 스플리팅
if (location.pathname.startsWith("/dashboard")) {
  const { init } = await import("./pages/dashboard.js");
  init();
}
```

**핵심 포인트**

- 라우트/뷰 단위 스플리팅이 기본 전략, 위젯/그래프 등 무거운 컴포넌트는 추가 분리
- 동적 import는 주석 힌트로 청크명 제어 가능: `import(/* webpackChunkName: "chart" */ './Chart')`
