# HTTP & HTTPS

## 개요

HTTP(HyperText Transfer Protocol)는 웹에서 데이터를 주고받는 프로토콜입니다. HTTPS는 HTTP에 보안 계층(SSL/TLS)을 추가한 것입니다.

**HTTP와 HTTPS가 웹 개발에서 중요한 이유:**
HTTP와 HTTPS는 웹의 기본 통신 방식을 정의하는 핵심 프로토콜입니다. 모든 웹 애플리케이션은 이 프로토콜을 기반으로 동작하며, 프로토콜의 특성과 보안 수준은 사용자 경험과 웹사이트의 신뢰성에 직접적인 영향을 미칩니다.

**HTTP의 기본 원리와 특징:**
HTTP는 클라이언트-서버 모델을 기반으로 하는 무상태(stateless) 프로토콜입니다. 각 요청은 독립적으로 처리되며, 이전 요청과의 연관성이 없습니다. 이는 웹의 확장성과 성능을 보장하지만, 동시에 세션 관리나 상태 유지가 필요한 경우 추가적인 기술적 해결책이 필요합니다.

**HTTPS의 보안적 중요성:**
HTTPS는 데이터 전송 과정에서 암호화를 제공하여 사용자의 개인정보와 민감한 데이터를 보호합니다. 현대 웹에서는 보안이 필수적이며, HTTPS 미적용은 검색 엔진 순위 하락, 브라우저 경고 표시, 사용자 신뢰도 저하 등 다양한 문제를 야기할 수 있습니다.

**웹 개발에서의 실무적 고려사항:**
개발자는 HTTP/HTTPS의 동작 원리를 이해하고, 적절한 상태 코드 사용, 효율적인 헤더 관리, 보안 설정 등을 통해 안전하고 성능이 좋은 웹 애플리케이션을 구축할 수 있습니다.

## HTTP 헤더

### 1. 일반 헤더

```http
# 요청 헤더
GET /api/users HTTP/1.1
Host: api.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: application/json
Accept-Language: ko-KR,ko;q=0.9,en;q=0.8
Accept-Encoding: gzip, deflate
Connection: keep-alive
Cache-Control: no-cache

# 응답 헤더
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 1234
Cache-Control: max-age=3600
ETag: "abc123"
Last-Modified: Wed, 15 Jan 2024 10:00:00 GMT
```

### 2. 인증 헤더

```http
# Basic 인증
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=

# Bearer 토큰
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# API 키
X-API-Key: your-api-key-here
```

### 3. 캐시 헤더

```http
# 캐시 제어
Cache-Control: max-age=3600, public
Cache-Control: no-cache, no-store, must-revalidate
Cache-Control: private, max-age=0

# ETag (Entity Tag)
ETag: "33a64df551"
If-None-Match: "33a64df551"

# Last-Modified
Last-Modified: Wed, 15 Jan 2024 10:00:00 GMT
If-Modified-Since: Wed, 15 Jan 2024 10:00:00 GMT
```

## HTTPS (HTTP Secure)

### 1. SSL/TLS 핸드셰이크

```
클라이언트                    서버
    |                         |
    |--- Client Hello ------>|
    |                         |
    |<-- Server Hello -------|
    |<-- Certificate --------|
    |<-- Server Key Exchange |
    |<-- Server Hello Done --|
    |                         |
    |--- Client Key Exchange->|
    |--- Change Cipher Spec ->|
    |--- Finished ----------->|
    |                         |
    |<-- Change Cipher Spec -|
    |<-- Finished -----------|
    |                         |
    |--- Encrypted Data ---->|
    |<-- Encrypted Data -----|
```

### 2. 인증서 체인

```
Root CA (루트 인증기관)
    |
    +-- Intermediate CA (중간 인증기관)
            |
            +-- Domain Certificate (도메인 인증서)
```

### 3. HTTPS 설정 예시 (Node.js)

```javascript
const https = require("https");
const fs = require("fs");

const options = {
  key: fs.readFileSync("private-key.pem"),
  cert: fs.readFileSync("certificate.pem"),
  ca: fs.readFileSync("ca-bundle.crt"),
};

https
  .createServer(options, (req, res) => {
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("HTTPS Server Running!\n");
  })
  .listen(443, () => {
    console.log("HTTPS Server running on port 443");
  });
```

## HTTP/2

### 1. HTTP/2 특징

- **멀티플렉싱**: 하나의 연결로 여러 요청/응답 동시 처리
- **헤더 압축**: HPACK을 사용한 헤더 압축
- **서버 푸시**: 서버가 클라이언트에게 리소스 미리 전송
- **바이너리 프로토콜**: 텍스트 기반에서 바이너리 기반으로 변경

### 2. HTTP/2 서버 푸시

```javascript
// Node.js HTTP/2 서버 푸시 예시
const http2 = require("http2");
const fs = require("fs");

const server = http2.createSecureServer({
  key: fs.readFileSync("private-key.pem"),
  cert: fs.readFileSync("certificate.pem"),
});

server.on("stream", (stream, headers) => {
  if (headers[":path"] === "/") {
    // HTML 응답
    stream.respond({
      "content-type": "text/html",
      ":status": 200,
    });

    // CSS 파일 푸시
    stream.pushStream({ ":path": "/styles.css" }, (pushStream) => {
      pushStream.respond({
        "content-type": "text/css",
        ":status": 200,
      });
      pushStream.end(fs.readFileSync("styles.css"));
    });

    stream.end(fs.readFileSync("index.html"));
  }
});

server.listen(443);
```

## 성능 최적화

### 1. HTTP/2 서버 푸시 최적화

```html
<!-- HTTP/2 서버 푸시를 위한 Link 헤더 -->
<link rel="preload" href="/styles.css" as="style" />
<link rel="preload" href="/script.js" as="script" />
<link
  rel="preload"
  href="/font.woff2"
  as="font"
  type="font/woff2"
  crossorigin
/>
```

### 2. 캐싱 전략

```http
# 정적 리소스 (1년)
Cache-Control: public, max-age=31536000, immutable

# 동적 콘텐츠 (1시간)
Cache-Control: public, max-age=3600, must-revalidate

# 민감한 데이터 (캐시 금지)
Cache-Control: no-cache, no-store, must-revalidate
```

### 3. 압축 설정

```javascript
// Gzip 압축 미들웨어
const compression = require("compression");
app.use(
  compression({
    level: 6,
    threshold: 1024,
    filter: (req, res) => {
      if (req.headers["x-no-compression"]) {
        return false;
      }
      return compression.filter(req, res);
    },
  })
);
```

## 요약

HTTP는 웹의 기본 프로토콜이며, HTTPS는 보안을 강화한 버전입니다. HTTP/2는 성능을 크게 향상시키며, 적절한 보안 설정과 성능 최적화가 중요합니다.
