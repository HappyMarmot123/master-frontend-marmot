# 프로세스와 스레드

## 개요

프로세스와 스레드는 운영체제에서 프로그램 실행을 관리하는 기본 단위입니다. 웹 개발에서 성능 최적화와 동시성 처리를 이해하는 데 중요한 개념입니다.

## 프로세스 (Process)

### 1. 프로세스의 정의

프로세스는 실행 중인 프로그램의 인스턴스로, 독립적인 메모리 공간과 시스템 자원을 가집니다. 운영체제는 각 프로세스에게 고유한 프로세스 ID(PID)를 할당하고, 프로세스 간 격리를 통해 안전한 실행 환경을 제공합니다.

**프로세스가 독립적인 이유:**
프로세스는 서로 다른 메모리 공간을 사용하기 때문에, 한 프로세스에서 발생한 오류나 충돌이 다른 프로세스에 영향을 주지 않습니다. 이는 시스템의 안정성과 보안을 크게 향상시킵니다. 예를 들어, 웹 브라우저에서 하나의 탭이 충돌해도 다른 탭은 정상적으로 작동할 수 있습니다.

### 2. 프로세스 구조

```
프로세스
├── 코드 영역 (Text Segment)
├── 데이터 영역 (Data Segment)
├── 힙 영역 (Heap Segment)
│   └── 동적 할당 메모리
├── 스택 영역 (Stack Segment)
│   ├── 지역 변수
│   ├── 함수 매개변수
│   └── 반환 주소
└── 프로세스 제어 블록 (PCB)
    ├── 프로세스 ID
    ├── 상태 정보
    ├── CPU 레지스터
    └── 자원 정보
```

### 3. 프로세스 상태 전이

```
     생성
      ↓
   [New] → [Ready] → [Running] → [Terminated]
              ↑         ↓
           [Waiting] ← [Blocked]
```

- **New**: 프로세스가 생성되었지만 아직 메모리에 로드되지 않음
- **Ready**: CPU 할당을 기다리는 상태
- **Running**: CPU에서 실행 중인 상태
- **Waiting**: I/O 완료나 다른 이벤트를 기다리는 상태
- **Terminated**: 프로세스 실행 완료

## 스레드 (Thread)

### 1. 스레드의 정의

스레드는 프로세스 내에서 실행되는 실행 단위로, 같은 프로세스 내의 다른 스레드와 메모리와 자원을 공유합니다.

#### 특징

- **경량성**: 프로세스보다 생성/전환 비용이 적음
- **공유**: 같은 프로세스 내 스레드들은 메모리와 자원을 공유
- **동시성**: 여러 스레드가 동시에 실행 가능
- **통신**: 공유 메모리를 통한 빠른 통신

### 2. 스레드 구조

```
프로세스
├── 공유 자원
│   ├── 코드 영역
│   ├── 데이터 영역
│   ├── 힙 영역
│   └── 파일 디스크립터
└── 스레드들
    ├── 스레드 1
    │   ├── 스택
    │   ├── 레지스터
    │   └── 상태
    ├── 스레드 2
    │   ├── 스택
    │   ├── 레지스터
    │   └── 상태
    └── 스레드 3
        ├── 스택
        ├── 레지스터
        └── 상태
```

## 프로세스 vs 스레드 비교

### 1. 메모리 공유

```javascript
// 프로세스: 독립적인 메모리 공간
const { spawn } = require("child_process");

const process1 = spawn("node", ["worker1.js"]);
const process2 = spawn("node", ["worker2.js"]);

// 각 프로세스는 독립적인 메모리 공간을 가짐
// process1과 process2는 서로의 변수에 접근할 수 없음
```

```javascript
// 스레드: 공유 메모리 공간
const { Worker } = require("worker_threads");

// Node.js에서 Worker는 별도 스레드로 실행
const worker = new Worker(`
  const { parentPort } = require('worker_threads');
  
  // 부모 스레드와 메시지 통신
  parentPort.on('message', (data) => {
    parentPort.postMessage('Processed: ' + data);
  });
`);

worker.on("message", (result) => {
  console.log(result);
});

worker.postMessage("Hello from main thread");
```
