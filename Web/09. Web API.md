# Web API (웹 API)

## Web API란?

**Web API(Application Programming Interface)**는 웹 브라우저에서 제공하는 다양한 기능들을 JavaScript로 사용할 수 있게 해주는 인터페이스입니다. 이는 웹 애플리케이션이 브라우저의 기능과 상호작용할 수 있게 해주며, 사용자 경험을 향상시키는 핵심 기술입니다.

## 주요 Web API 카테고리

### 1. DOM (Document Object Model) API

DOM API는 HTML 문서의 구조를 프로그래밍 방식으로 조작할 수 있게 해줍니다.

#### 핵심 DOM 메서드

```javascript
// 요소 선택
const element = document.getElementById("myId");
const elements = document.querySelectorAll(".myClass");
const element = document.querySelector("#myId");

// 요소 생성 및 조작
const newElement = document.createElement("div");
newElement.textContent = "Hello World";
document.body.appendChild(newElement);

// 요소 속성 조작
element.setAttribute("class", "newClass");
element.classList.add("active");
element.classList.remove("inactive");
```

#### DOM 이벤트

```javascript
// 이벤트 리스너 추가
element.addEventListener("click", function (event) {
  console.log("클릭됨:", event.target);
});

// 이벤트 제거
element.removeEventListener("click", handler);

// 커스텀 이벤트 생성
const customEvent = new CustomEvent("myEvent", {
  detail: { message: "Hello" },
});
element.dispatchEvent(customEvent);
```

### 2. Fetch API

Fetch API는 HTTP 요청을 보내고 응답을 받는 현대적인 방법을 제공합니다.

```javascript
// 기본 GET 요청
fetch("https://api.example.com/data")
  .then((response) => {
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    return response.json();
  })
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));

// POST 요청
fetch("https://api.example.com/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "John Doe",
    email: "john@example.com",
  }),
})
  .then((response) => response.json())
  .then((data) => console.log("Success:", data));

// async/await 사용
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error:", error);
  }
}
```

### 3. Web Storage API

웹 애플리케이션이 브라우저에 데이터를 저장할 수 있게 해주는 API입니다.

#### localStorage

```javascript
// 데이터 저장
localStorage.setItem("username", "john_doe");
localStorage.setItem(
  "userPreferences",
  JSON.stringify({
    theme: "dark",
    language: "ko",
  })
);

// 데이터 읽기
const username = localStorage.getItem("username");
const preferences = JSON.parse(localStorage.getItem("userPreferences"));

// 데이터 삭제
localStorage.removeItem("username");
localStorage.clear(); // 모든 데이터 삭제

// 저장된 데이터 개수
console.log(localStorage.length);
```

#### sessionStorage

```javascript
// 세션 동안만 유지되는 데이터
sessionStorage.setItem("sessionId", "abc123");
sessionStorage.setItem("tempData", "temporary");

// 브라우저 탭을 닫으면 데이터 삭제됨
```

### 4. Geolocation API

사용자의 지리적 위치 정보를 얻을 수 있는 API입니다.

```javascript
// 현재 위치 가져오기
if ("geolocation" in navigator) {
  navigator.geolocation.getCurrentPosition(
    function (position) {
      const latitude = position.coords.latitude;
      const longitude = position.coords.longitude;
      console.log(`위도: ${latitude}, 경도: ${longitude}`);
    },
    function (error) {
      console.error("위치 정보를 가져올 수 없습니다:", error.message);
    },
    {
      enableHighAccuracy: true,
      timeout: 5000,
      maximumAge: 0,
    }
  );
}

// 위치 변화 감지
const watchId = navigator.geolocation.watchPosition(
  function (position) {
    console.log("위치 변경됨:", position.coords);
  },
  function (error) {
    console.error("위치 감시 오류:", error.message);
  }
);

// 위치 감시 중지
navigator.geolocation.clearWatch(watchId);
```

### 5. Web Workers API

메인 스레드를 차단하지 않고 백그라운드에서 스크립트를 실행할 수 있게 해줍니다.

```javascript
// 메인 스레드에서 Worker 생성
const worker = new Worker("worker.js");

// Worker로부터 메시지 수신
worker.onmessage = function (event) {
  console.log("Worker로부터 받은 메시지:", event.data);
};

// Worker로 메시지 전송
worker.postMessage({
  type: "calculate",
  data: [1, 2, 3, 4, 5],
});

// Worker 종료
worker.terminate();
```

```javascript
// worker.js
self.onmessage = function (event) {
  const { type, data } = event.data;

  if (type === "calculate") {
    const result = data.reduce((sum, num) => sum + num, 0);
    self.postMessage({
      type: "result",
      data: result,
    });
  }
};
```

### 6. Service Workers API

웹 애플리케이션을 오프라인에서도 작동하게 하고, 백그라운드 동기화를 제공합니다.

```javascript
// Service Worker 등록
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/sw.js")
    .then(function (registration) {
      console.log("Service Worker 등록 성공:", registration);
    })
    .catch(function (error) {
      console.log("Service Worker 등록 실패:", error);
    });
}

// Service Worker 설치 및 활성화
self.addEventListener("install", function (event) {
  event.waitUntil(
    caches.open("v1").then(function (cache) {
      return cache.addAll(["/", "/styles/main.css", "/scripts/main.js"]);
    })
  );
});

self.addEventListener("fetch", function (event) {
  event.respondWith(
    caches.match(event.request).then(function (response) {
      return response || fetch(event.request);
    })
  );
});
```

### 7. WebSocket API

실시간 양방향 통신을 위한 API입니다.

```javascript
// WebSocket 연결
const socket = new WebSocket("wss://echo.websocket.org");

// 연결 열림
socket.onopen = function (event) {
  console.log("WebSocket 연결됨");
  socket.send("Hello Server!");
};

// 메시지 수신
socket.onmessage = function (event) {
  console.log("서버로부터 메시지 수신:", event.data);
};

// 연결 닫힘
socket.onclose = function (event) {
  console.log("WebSocket 연결 닫힘:", event.code, event.reason);
};

// 오류 발생
socket.onerror = function (error) {
  console.error("WebSocket 오류:", error);
};

// 메시지 전송
socket.send("안녕하세요!");

// 연결 종료
socket.close();
```

### 8. Canvas API

2D 그래픽을 그릴 수 있는 API입니다.

```javascript
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

// 사각형 그리기
ctx.fillStyle = "red";
ctx.fillRect(10, 10, 100, 100);

// 원 그리기
ctx.beginPath();
ctx.arc(200, 200, 50, 0, 2 * Math.PI);
ctx.fillStyle = "blue";
ctx.fill();

// 선 그리기
ctx.beginPath();
ctx.moveTo(300, 300);
ctx.lineTo(400, 400);
ctx.strokeStyle = "green";
ctx.lineWidth = 5;
ctx.stroke();

// 텍스트 그리기
ctx.font = "30px Arial";
ctx.fillStyle = "black";
ctx.fillText("Hello Canvas!", 50, 300);
```

### 9. Web Audio API

오디오를 프로그래밍 방식으로 제어할 수 있는 API입니다.

```javascript
// AudioContext 생성
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

// 오실레이터 생성
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();

// 오실레이터 설정
oscillator.type = "sine";
oscillator.frequency.setValueAtTime(440, audioContext.currentTime);

// 게인 설정
gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

// 노드 연결
oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);

// 오실레이터 시작
oscillator.start();
oscillator.stop(audioContext.currentTime + 2);
```

### 10. WebRTC API

실시간 음성, 영상, 데이터 통신을 위한 API입니다.

```javascript
// 사용자 미디어 가져오기
navigator.mediaDevices
  .getUserMedia({
    video: true,
    audio: true,
  })
  .then(function (stream) {
    const video = document.getElementById("video");
    video.srcObject = stream;
  })
  .catch(function (error) {
    console.error("미디어 접근 오류:", error);
  });

// 화면 공유
navigator.mediaDevices
  .getDisplayMedia({
    video: true,
  })
  .then(function (stream) {
    const video = document.getElementById("screenShare");
    video.srcObject = stream;
  });
```

### 11. IndexedDB API

클라이언트 사이드에 대용량 데이터를 저장할 수 있는 데이터베이스 API입니다.

```javascript
// IndexedDB 열기
const request = indexedDB.open("MyDatabase", 1);

request.onerror = function (event) {
  console.error("IndexedDB 오류:", event.target.error);
};

request.onsuccess = function (event) {
  const db = event.target.result;
  console.log("IndexedDB 열기 성공");

  // 트랜잭션 시작
  const transaction = db.transaction(["users"], "readwrite");
  const objectStore = transaction.objectStore("users");

  // 데이터 추가
  const user = { id: 1, name: "John", email: "john@example.com" };
  const addRequest = objectStore.add(user);

  addRequest.onsuccess = function () {
    console.log("사용자 추가 성공");
  };
};

request.onupgradeneeded = function (event) {
  const db = event.target.result;

  // 객체 스토어 생성
  if (!db.objectStoreNames.contains("users")) {
    const objectStore = db.createObjectStore("users", { keyPath: "id" });
    objectStore.createIndex("email", "email", { unique: true });
  }
};
```

### 12. File API

파일을 읽고 조작할 수 있는 API입니다.

```javascript
// 파일 선택
const fileInput = document.getElementById("fileInput");
fileInput.addEventListener("change", function (event) {
  const file = event.target.files[0];

  if (file) {
    // 파일 정보
    console.log("파일명:", file.name);
    console.log("파일 크기:", file.size, "bytes");
    console.log("파일 타입:", file.type);

    // 파일 읽기
    const reader = new FileReader();
    reader.onload = function (e) {
      console.log("파일 내용:", e.target.result);
    };
    reader.readAsText(file);
  }
});

// 드래그 앤 드롭
const dropZone = document.getElementById("dropZone");

dropZone.addEventListener("dragover", function (e) {
  e.preventDefault();
});

dropZone.addEventListener("drop", function (e) {
  e.preventDefault();
  const files = e.dataTransfer.files;

  for (let file of files) {
    console.log("드롭된 파일:", file.name);
  }
});
```

### 13. Drag and Drop API

HTML 요소를 드래그하고 드롭할 수 있는 API입니다.

```javascript
const draggable = document.getElementById("draggable");
const dropZone = document.getElementById("dropZone");

// 드래그 가능하게 설정
draggable.draggable = true;

// 드래그 시작
draggable.addEventListener("dragstart", function (e) {
  e.dataTransfer.setData("text/plain", e.target.id);
  e.target.style.opacity = "0.5";
});

// 드래그 종료
draggable.addEventListener("dragend", function (e) {
  e.target.style.opacity = "1";
});

// 드래그 오버
dropZone.addEventListener("dragover", function (e) {
  e.preventDefault();
  e.target.style.backgroundColor = "lightblue";
});

// 드래그 리브
dropZone.addEventListener("dragleave", function (e) {
  e.target.style.backgroundColor = "";
});

// 드롭
dropZone.addEventListener("drop", function (e) {
  e.preventDefault();
  const data = e.dataTransfer.getData("text/plain");
  const element = document.getElementById(data);

  dropZone.appendChild(element);
  dropZone.style.backgroundColor = "";
});
```

### 14. History API

브라우저 히스토리를 프로그래밍 방식으로 제어할 수 있는 API입니다.

```javascript
// 히스토리 항목 추가
function navigateToPage(page) {
  const state = { page: page };
  const url = `/${page}`;

  history.pushState(state, "", url);
  updateContent(page);
}

// 브라우저 뒤로가기/앞으로가기 처리
window.addEventListener("popstate", function (event) {
  if (event.state) {
    updateContent(event.state.page);
  }
});

// 히스토리 상태 교체
history.replaceState({ page: "home" }, "", "/home");

// 히스토리 뒤로가기
history.back();

// 히스토리 앞으로가기
history.forward();
```

### 15. Intersection Observer API

요소가 뷰포트에 보이는지 감지할 수 있는 API입니다.

```javascript
// Intersection Observer 생성
const observer = new IntersectionObserver(
  function (entries) {
    entries.forEach(function (entry) {
      if (entry.isIntersecting) {
        console.log("요소가 뷰포트에 보임:", entry.target);
        entry.target.classList.add("visible");
      } else {
        entry.target.classList.remove("visible");
      }
    });
  },
  {
    threshold: 0.5, // 50% 보일 때 트리거
    rootMargin: "0px", // 루트 마진
  }
);

// 관찰할 요소들
const elements = document.querySelectorAll(".observe");
elements.forEach(function (element) {
  observer.observe(element);
});

// 관찰 중지
observer.unobserve(element);
observer.disconnect();
```

### 16. Resize Observer API

요소의 크기 변화를 감지할 수 있는 API입니다.

```javascript
// Resize Observer 생성
const resizeObserver = new ResizeObserver(function (entries) {
  entries.forEach(function (entry) {
    const { width, height } = entry.contentRect;
    console.log("요소 크기 변경:", width, height);

    // 반응형 레이아웃 조정
    if (width < 768) {
      entry.target.classList.add("mobile");
    } else {
      entry.target.classList.remove("mobile");
    }
  });
});

// 관찰할 요소
const element = document.getElementById("responsiveElement");
resizeObserver.observe(element);

// 관찰 중지
resizeObserver.unobserve(element);
resizeObserver.disconnect();
```

### 17. Performance API

웹 애플리케이션의 성능을 측정하고 분석할 수 있는 API입니다.

```javascript
// 페이지 로드 성능 측정
window.addEventListener("load", function () {
  const perfData = performance.getEntriesByType("navigation")[0];

  console.log("DOM 완성 시간:", perfData.domComplete);
  console.log(
    "페이지 로드 시간:",
    perfData.loadEventEnd - perfData.loadEventStart
  );
  console.log("전체 로드 시간:", perfData.loadEventEnd - perfData.fetchStart);
});

// 사용자 정의 성능 측정
performance.mark("startOperation");
// ... 작업 수행 ...
performance.mark("endOperation");

performance.measure("operationDuration", "startOperation", "endOperation");
const measure = performance.getEntriesByName("operationDuration")[0];
console.log("작업 소요 시간:", measure.duration);

// 성능 메모리 정보
const memory = performance.memory;
console.log("사용된 힙 크기:", memory.usedJSHeapSize);
console.log("총 힙 크기:", memory.totalJSHeapSize);
```

### 18. Web Animations API

CSS 애니메이션을 JavaScript로 제어할 수 있는 API입니다.

```javascript
// 요소 애니메이션
const element = document.getElementById("animated");

const animation = element.animate(
  [
    { transform: "translateX(0px)", opacity: 1 },
    { transform: "translateX(100px)", opacity: 0.5 },
    { transform: "translateX(200px)", opacity: 0 },
  ],
  {
    duration: 2000,
    easing: "ease-in-out",
    iterations: Infinity,
    direction: "alternate",
  }
);

// 애니메이션 제어
animation.pause();
animation.play();
animation.reverse();

// 애니메이션 이벤트
animation.onfinish = function () {
  console.log("애니메이션 완료");
};

animation.oncancel = function () {
  console.log("애니메이션 취소됨");
};
```

### 19. Web Speech API

음성 인식과 음성 합성을 위한 API입니다.

#### Speech Recognition (음성 인식)

```javascript
if ("webkitSpeechRecognition" in window) {
  const recognition = new webkitSpeechRecognition();

  recognition.continuous = true;
  recognition.interimResults = true;
  recognition.lang = "ko-KR";

  recognition.onresult = function (event) {
    let finalTranscript = "";
    let interimTranscript = "";

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = event.results[i][0].transcript;

      if (event.results[i].isFinal) {
        finalTranscript += transcript;
      } else {
        interimTranscript += transcript;
      }
    }

    console.log("최종 결과:", finalTranscript);
    console.log("임시 결과:", interimTranscript);
  };

  recognition.start();
}
```

#### Speech Synthesis (음성 합성)

```javascript
if ("speechSynthesis" in window) {
  const utterance = new SpeechSynthesisUtterance(
    "안녕하세요, 웹 음성 합성입니다."
  );

  utterance.lang = "ko-KR";
  utterance.rate = 1.0;
  utterance.pitch = 1.0;
  utterance.volume = 1.0;

  utterance.onstart = function () {
    console.log("음성 합성 시작");
  };

  utterance.onend = function () {
    console.log("음성 합성 완료");
  };

  speechSynthesis.speak(utterance);
}
```

### 20. Web Bluetooth API

블루투스 장치와 통신할 수 있는 API입니다.

```javascript
// 블루투스 장치 요청
navigator.bluetooth
  .requestDevice({
    acceptAllDevices: true,
    optionalServices: ["heart_rate"],
  })
  .then(function (device) {
    console.log("장치 선택됨:", device.name);

    // GATT 서버 연결
    return device.gatt.connect();
  })
  .then(function (server) {
    console.log("GATT 서버 연결됨");

    // 서비스 가져오기
    return server.getPrimaryService("heart_rate");
  })
  .then(function (service) {
    // 특성 가져오기
    return service.getCharacteristic("heart_rate_measurement");
  })
  .then(function (characteristic) {
    // 알림 시작
    return characteristic.startNotifications();
  })
  .catch(function (error) {
    console.error("블루투스 오류:", error);
  });
```

## Web API 사용 시 주의사항

### 1. 브라우저 호환성

- 모든 API가 모든 브라우저에서 지원되지 않을 수 있음
- 기능 감지(feature detection)를 통한 안전한 사용 필요

```javascript
if ("geolocation" in navigator) {
  // Geolocation API 사용
} else {
  // 대체 방법 제공
}
```

### 2. 보안 고려사항

- HTTPS 환경에서만 작동하는 API들이 많음
- 사용자 권한이 필요한 API들 (카메라, 마이크, 위치 등)
- CORS 정책 준수 필요

### 3. 성능 최적화

- 불필요한 API 호출 최소화
- 이벤트 리스너 적절한 제거
- 메모리 누수 방지

## 결론

Web API는 현대 웹 개발의 핵심 요소로, 다양한 기능을 제공하여 풍부한 사용자 경험을 구현할 수 있게 해줍니다. 각 API의 특성과 사용법을 이해하고, 적절한 상황에서 활용한다면 강력하고 인터랙티브한 웹 애플리케이션을 만들 수 있습니다.

하지만 API 사용 시에는 브라우저 호환성, 보안, 성능 등을 고려하여 신중하게 접근해야 하며, 사용자에게 최적의 경험을 제공하는 것을 목표로 해야 합니다.
