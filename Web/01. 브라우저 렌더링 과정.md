# 브라우저 렌더링 과정

## 개요

브라우저가 HTML, CSS, JavaScript를 받아서 화면에 표시하는 과정을 렌더링 과정이라고 합니다. 이 과정은 여러 단계로 나뉘며, 각 단계가 순차적으로 실행됩니다.

**브라우저 렌더링 과정을 이해하는 것이 중요한 이유:**

- **성능 최적화**: 렌더링 과정의 각 단계를 이해하면 웹사이트 성능을 크게 향상시킬 수 있습니다
- **사용자 경험**: 빠른 로딩과 부드러운 애니메이션은 사용자 만족도를 높입니다
- **개발 효율성**: 렌더링 최적화 원리를 알면 더 효율적인 코드를 작성할 수 있습니다
- **문제 해결**: 웹사이트가 느리거나 버벅일 때 원인을 파악하고 해결할 수 있습니다

**렌더링 과정의 핵심 원리:**
브라우저는 HTML을 파싱하여 DOM 트리를 만들고, CSS를 파싱하여 CSSOM 트리를 만든 후, 이 둘을 결합하여 렌더 트리를 생성합니다. 그 다음 레이아웃 계산과 페인팅을 통해 최종 화면을 표시합니다. 각 단계에서 발생하는 지연은 전체 페이지 로딩 시간에 직접적인 영향을 미칩니다.

## 렌더링 과정 단계

### 1. 파싱 (Parsing)

파싱은 브라우저가 HTML, CSS, JavaScript 코드를 읽고 이해할 수 있는 구조로 변환하는 첫 번째 단계입니다. 이 과정에서 코드의 문법을 검증하고, 의미있는 구조로 변환합니다.

**HTML 파싱의 중요성:**
HTML 파싱은 웹페이지의 구조를 정의하는 핵심 과정입니다. 잘못된 HTML은 파싱 오류를 발생시키고, 이는 렌더링 지연과 예상치 못한 레이아웃 문제를 야기할 수 있습니다. 특히 중첩된 태그나 닫히지 않은 태그는 파싱을 방해하여 전체 페이지 로딩 속도를 늦출 수 있습니다.

**CSS 파싱의 특징:**
CSS 파싱은 HTML 파싱과 병렬로 진행되지만, CSS가 완전히 파싱되기 전까지는 렌더 트리 생성이 지연됩니다. 이는 CSS가 레이아웃과 스타일에 직접적인 영향을 미치기 때문입니다. 따라서 CSS 파일의 크기와 복잡성은 초기 렌더링 속도에 중요한 영향을 미칩니다.

**JavaScript 파싱의 고려사항:**
JavaScript 파싱은 HTML 파싱을 차단할 수 있습니다. `<script>` 태그를 만나면 HTML 파싱이 일시 중단되고, JavaScript 코드가 실행된 후에야 HTML 파싱이 재개됩니다. 이는 페이지 로딩 속도에 큰 영향을 미치므로, JavaScript 로딩 전략이 중요합니다.

**실제 적용 예시:**

```html
<!-- HTML 파싱 최적화: 유효한 HTML 구조 -->
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>최적화된 페이지</title>
  </head>
  <body>
    <h1>제목</h1>
    <p>내용</p>
  </body>
</html>
```

### 2. DOM 트리 생성

DOM 트리는 HTML 문서의 구조를 계층적으로 표현한 객체 모델입니다. 브라우저는 HTML을 파싱한 후, 각 요소를 노드로 변환하여 부모-자식 관계를 가진 트리 구조를 만듭니다.

**DOM 트리의 구조적 특징:**
DOM 트리는 문서의 모든 요소를 포함하며, 각 요소는 노드(Node)로 표현됩니다. 요소 노드, 텍스트 노드, 속성 노드 등 다양한 타입의 노드가 계층적으로 연결되어 전체 문서의 구조를 나타냅니다. 이 구조는 JavaScript를 통해 동적으로 조작할 수 있어, 웹페이지를 인터랙티브하게 만드는 기반이 됩니다.

**DOM 트리 생성의 성능 영향:**
DOM 트리 생성은 HTML의 복잡성에 직접적으로 영향을 받습니다. 깊게 중첩된 요소나 많은 수의 요소가 있을수록 DOM 트리 생성에 더 많은 시간이 소요됩니다. 특히 모바일 기기에서는 이 과정이 더 느릴 수 있으므로, HTML 구조를 단순하게 유지하는 것이 중요합니다.

**실제 적용 예시:**

```html
<!-- 간단한 DOM 구조 -->
<!DOCTYPE html>
<html>
  <head>
    <title>웹페이지</title>
  </head>
  <body>
    <h1>제목</h1>
    <p>내용</p>
  </body>
</html>
```

**생성된 DOM 트리:**

```
Document
├── html
    ├── head
    │   └── title
    │       └── "웹페이지"
    └── body
        ├── h1
        │   └── "제목"
        └── p
            └── "내용"
```

### 3. CSSOM 트리 생성

CSSOM(CSS Object Model) 트리는 CSS 스타일 정보를 구조화된 형태로 표현한 모델입니다. 브라우저는 CSS 파일을 파싱하여 각 요소에 적용될 스타일 규칙을 계산하고, 이를 CSSOM 트리로 구성합니다.

**CSSOM 트리의 역할:**
CSSOM 트리는 각 HTML 요소에 어떤 스타일이 적용될지 결정하는 중요한 역할을 합니다. CSS 선택자, 상속, 우선순위 등의 복잡한 규칙을 해석하여 최종적으로 각 요소에 적용될 스타일 값을 계산합니다. 이 과정에서 CSS의 복잡성과 크기가 직접적으로 성능에 영향을 미칩니다.

**CSS 파싱의 성능 고려사항:**
CSS 파싱은 렌더링을 차단할 수 있습니다. 브라우저는 CSS가 완전히 파싱되고 CSSOM 트리가 생성될 때까지 렌더 트리 생성을 기다립니다. 따라서 CSS 파일이 크거나 복잡할수록 초기 렌더링이 지연됩니다. 특히 외부 CSS 파일의 로딩 시간은 전체 페이지 표시 속도에 직접적인 영향을 미칩니다.

**실제 적용 예시:**

```css
/* 간단한 CSS 구조 */
body {
  font-size: 16px;
}
h1 {
  color: blue;
}
```

**생성된 CSSOM 트리:**

```
CSSOM
├── body
│   └── font-size: 16px
└── h1
    └── color: blue
```

### 4. 렌더 트리 생성

렌더 트리는 DOM 트리와 CSSOM 트리를 결합하여 실제로 화면에 표시될 요소들만을 포함하는 최종 트리 구조입니다. 이 단계에서 브라우저는 어떤 요소가 보이고, 어떤 요소가 숨겨질지 결정합니다.

**렌더 트리 생성의 핵심 과정:**
렌더 트리 생성은 DOM과 CSSOM의 정보를 통합하는 복잡한 과정입니다. 브라우저는 각 HTML 요소에 적용된 CSS 스타일을 분석하여, 화면에 표시될 요소와 그 스타일을 결정합니다. 이 과정에서 `display: none`과 같은 속성은 해당 요소를 렌더 트리에서 완전히 제외시키고, `visibility: hidden`은 요소는 포함하지만 보이지 않게 만듭니다.

**렌더 트리와 성능의 관계:**
렌더 트리의 복잡성은 직접적으로 페인팅 성능에 영향을 미칩니다. 렌더 트리에 포함된 요소가 많을수록 화면을 그리는 데 더 많은 시간이 소요됩니다. 따라서 불필요한 요소를 제거하고, CSS를 효율적으로 작성하여 렌더 트리를 최적화하는 것이 중요합니다.

**렌더 트리 최적화 전략:**

- **불필요한 요소 제거**: `display: none`을 사용하여 요소를 렌더 트리에서 제외
- **CSS 최적화**: 복잡한 선택자와 중첩된 규칙을 피하여 CSSOM 생성 속도 향상
- **레이어 분리**: `transform`, `opacity` 등을 사용하여 별도 레이어로 분리하여 성능 향상

### 5. 레이아웃 (Layout/Reflow)

레이아웃 단계는 렌더 트리의 각 요소가 화면의 어느 위치에, 어떤 크기로 배치될지를 계산하는 과정입니다. 이 과정은 웹페이지의 시각적 구조를 결정하는 핵심 단계로, 복잡한 계산이 필요한 과정입니다.

**레이아웃 계산의 복잡성:**
레이아웃 계산은 각 요소의 크기, 위치, 여백, 테두리 등을 고려하여 정확한 위치를 결정합니다. 특히 CSS의 `position`, `float`, `flexbox`, `grid` 등의 레이아웃 모델은 복잡한 계산을 요구하며, 요소 간의 상호 의존성으로 인해 한 요소의 변경이 다른 요소들의 위치에 영향을 미칠 수 있습니다.

**리플로우(Reflow)의 성능 영향:**
리플로우는 레이아웃을 다시 계산하는 과정으로, JavaScript로 DOM을 조작하거나 CSS를 변경할 때 발생할 수 있습니다. 리플로우는 비용이 큰 작업이므로, 가능한 한 최소화해야 합니다. 특히 반복적인 DOM 조작이나 스타일 변경은 성능에 큰 영향을 미칠 수 있습니다.

**레이아웃 최적화 전략:**

- **일괄 처리**: 여러 DOM 조작을 한 번에 처리하여 리플로우 횟수 최소화
- **레이어 분리**: `transform`, `opacity` 등을 사용하여 별도 레이어로 분리
- **가상화**: 대량의 요소를 화면에 보이는 부분만 렌더링하여 성능 향상
- **CSS 최적화**: 레이아웃에 영향을 주는 속성 변경을 최소화

### 6. 페인팅 (Painting)

페인팅은 계산된 레이아웃을 바탕으로 실제 화면에 픽셀을 그리는 최종 단계입니다. 이 과정에서 텍스트, 이미지, 색상, 그림자 등 모든 시각적 요소가 화면에 표시됩니다.

**페인팅 과정의 세부 단계:**
페인팅은 여러 단계로 나뉘어 진행됩니다. 먼저 배경을 그리고, 그 다음 텍스트, 이미지, 테두리 등을 순서대로 그립니다. 각 요소는 지정된 색상, 폰트, 크기 등에 따라 정확하게 렌더링됩니다. 특히 복잡한 CSS 효과(그림자, 그라데이션, 애니메이션 등)는 더 많은 계산과 렌더링 시간을 요구합니다.

**GPU 가속의 역할:**
현대 브라우저는 GPU 가속을 활용하여 페인팅 성능을 크게 향상시킵니다. `transform`, `opacity`, `filter` 등의 CSS 속성은 별도의 레이어로 분리되어 GPU에서 직접 처리됩니다. 이는 CPU의 부하를 줄이고, 부드러운 애니메이션과 스크롤을 가능하게 합니다.

**페인팅 성능 최적화:**

- **레이어 분리**: `will-change`, `transform3d` 등을 사용하여 GPU 레이어 생성
- **페인트 영역 최소화**: 변경된 부분만 다시 그리도록 최적화
- **애니메이션 최적화**: `transform`과 `opacity`를 사용하여 레이아웃 변경 방지
- **이미지 최적화**: 적절한 이미지 포맷과 크기 사용으로 렌더링 속도 향상

## 성능 최적화 팁

### 1. CSS 최적화

CSS 최적화는 렌더링 성능을 향상시키는 핵심 요소입니다. 잘못된 CSS는 불필요한 리플로우와 리페인트를 발생시켜 전체 페이지 성능을 저하시킬 수 있습니다.

**CSS 최적화의 핵심 원칙:**

- **레이아웃 변경 최소화**: `width`, `height`, `margin`, `padding` 등은 리플로우를 발생시킵니다
- **GPU 가속 활용**: `transform`, `opacity`, `filter` 등은 별도 레이어로 분리되어 성능이 좋습니다
- **선택자 최적화**: 복잡한 CSS 선택자는 CSSOM 생성 시간을 늘립니다
- **중요한 스타일 인라인**: 초기 렌더링에 필요한 CSS는 인라인으로 포함하여 외부 파일 로딩 지연 방지

**실제 적용 예시:**

```css
/* 나쁜 예: 레이아웃 변경 발생 */
.box {
  width: 100px;
  height: 100px;
  margin: 10px;
}

/* 좋은 예: 레이아웃 변경 최소화 */
.box {
  width: 100px;
  height: 100px;
  transform: translateX(10px); /* 레이아웃 변경 없음 */
}
```

### 2. JavaScript 최적화

```javascript
// 나쁜 예: DOM 직접 조작
for (let i = 0; i < 1000; i++) {
  const div = document.createElement("div");
  div.textContent = `Item ${i}`;
  document.body.appendChild(div); // 매번 리플로우 발생
}

// 좋은 예: DocumentFragment 사용
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement("div");
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
document.body.appendChild(fragment); // 한 번만 리플로우 발생
```

### 3. 이미지 최적화

- 적절한 이미지 포맷 선택 (WebP, AVIF 등)
- 이미지 크기 최적화
- 지연 로딩 (Lazy Loading) 적용

## 렌더링 차단 요소

### 1. CSS 차단

- `<link>` 태그의 CSS는 렌더링을 차단
- Critical CSS를 인라인으로 포함하여 초기 렌더링 최적화

### 2. JavaScript 차단

- `<script>` 태그는 HTML 파싱을 차단
- `async`, `defer` 속성 활용
- DOMContentLoaded 이벤트 활용

```html
<!-- 파싱 차단 -->
<script src="script.js"></script>

<!-- 비동기 로딩 (파싱 차단하지 않음) -->
<script async src="script.js"></script>

<!-- 지연 실행 (파싱 완료 후 실행) -->
<script defer src="script.js"></script>
```

## 모던 렌더링 최적화

### 1. 가상 스크롤링

- 대량의 데이터를 효율적으로 렌더링
- 화면에 보이는 요소만 실제 DOM에 생성

### 2. 웹 워커

- 메인 스레드 블로킹 방지
- 복잡한 계산을 백그라운드에서 처리

### 3. 서비스 워커

- 오프라인 지원
- 캐싱 전략으로 성능 향상

## 디버깅 도구

### 1. Chrome DevTools

- Performance 탭: 렌더링 성능 분석
- Elements 탭: DOM 구조 확인
- Network 탭: 리소스 로딩 시간 분석

### 2. Lighthouse

- 웹페이지 성능 점수
- 개선 방안 제시
- SEO, 접근성 등 종합 평가

## 요약

브라우저 렌더링 과정을 이해하면 웹 성능 최적화에 큰 도움이 됩니다. 각 단계별로 최적화 포인트를 파악하고, 사용자 경험을 향상시키는 방향으로 개발하는 것이 중요합니다.
