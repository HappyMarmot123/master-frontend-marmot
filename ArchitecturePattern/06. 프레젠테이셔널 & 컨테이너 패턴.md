# 프레젠테이셔널 & 컨테이너 패턴 (Presentational & Container Pattern)

## 📖 개요

React 애플리케이션이 복잡해지면서 여러 문제점이 대두되었습니다. 요구사항이 복잡할수록 단일 컴포넌트가 갖는 책임이 방대해지면서 코드가 길어지고 성능 과부하 이슈가 생기게 됩니다. 이는 비효율적인 개발과 어려운 테스트를 야기합니다. **프레젠테이셔널 & 컨테이너 패턴**은 React에서 주로 사용되는 컴포넌트 설계 패턴으로, 컴포넌트를 뷰와 로직 두 가지 유형으로 나누어 관심사를 분리합니다.

복잡성이 없는 아주 작은 컴포넌트는 분리하지 않는 것이 좋습니다. 또한, 프롭 드릴링(prop drilling)이 심해질 경우 단일 책임을 갖는 전역 상태를 이용하는 것도 좋은 방법입니다. 이 패턴은 관심사 분리를 통해 비즈니스 로직과 뷰를 분리하지만, 결국 이 둘은 결합도가 매우 높은 상태라는 점을 인지해야 합니다.

이 패턴은 다음과 같은 문제들을 해결하기 위해 등장했습니다:

- **관심사 분리**: UI 로직과 비즈니스 로직을 명확히 분리
- **재사용성 향상**: 프레젠테이셔널 컴포넌트의 독립적 사용 가능
- **테스트 용이성**: 각 컴포넌트를 독립적으로 테스트 가능
- **협업 효율성**: 역할별 독립적 개발 가능

### 1. 프레젠테이셔널 컴포넌트 (Presentational Components)

**프레젠테이셔널 컴포넌트**는 '어떻게 보이는가'에 초점을 맞추며 UI를 담당합니다. 최소한의 UI 상태만 가지며, 데이터는 부모로부터 props로 받아 표시합니다.

```jsx
// UserCard.jsx - 프레젠테이셔널 컴포넌트
const UserCard = ({ user, onEdit, onDelete }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>수정</button>
      <button onClick={() => onDelete(user.id)}>삭제</button>
    </div>
  );
};
```

### 2. 컨테이너 컴포넌트 (Container Components)

**컨테이너 컴포넌트**는 '어떻게 동작하는가'에 초점을 맞추며, 데이터를 가져오거나 상태를 관리하는 **비즈니스 로직**을 담당합니다. 자식 컴포넌트(프레젠테이셔널)에 데이터를 전달합니다.

```jsx
// UserListContainer.jsx - 컨테이너 컴포넌트
const UserListContainer = () => {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    loadUsers();
  }, []);

  const loadUsers = async () => {
    setLoading(true);
    const userData = await fetchUsers();
    setUsers(userData);
    setLoading(false);
  };

  return (
    <div className="user-list">
      <UserCard key={user.id} user={user} />
    </div>
  );
};
```
