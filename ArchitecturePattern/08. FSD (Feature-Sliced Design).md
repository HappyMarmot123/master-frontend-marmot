# FSD (Feature-Sliced Design)

## 📖 개요

FSD의 가장 기본적인 원칙은 코드를 **비즈니스 기능(feature)** 단위로 분리하는 것입니다. 기존 아키텍처가 파일 타입(`components`, `pages` 등)을 기준으로 폴더를 나누는 것과 달리, FSD는 로그인, 게시물 작성, 결제와 같은 특정 기능을 기준으로 코드를 묶습니다. 이렇게 하면 관련된 로직, 컴포넌트, 상태 관리 코드가 한곳에 모여 개발자가 필요한 코드를 빠르게 찾고 이해할 수 있습니다.

FSD는 레이어(계층) 간의 의존성 방향을 **단방향**으로 엄격하게 관리합니다. 예를 들어, 상위 계층(`features`)은 하위 계층(`entities`)에 의존할 수 있지만, 그 반대는 허용되지 않습니다. 이 원칙은 코드 흐름의 예측 가능성을 높입니다.

각 기능(feature)은 다른 기능으로부터 독립적으로 개발되고 테스트될 수 있도록 설계됩니다. 따라서 특정 기능에 대한 수정이나 버그 해결이 다른 기능에 미치는 영향을 최소화하여 전체 시스템의 안정성을 보장합니다.

FSD 구조는 애플리케이션의 크기가 커질수록 진가를 발휘합니다. 위에서 설명한 원칙 덕분에 새로운 기능을 추가하거나 기존 기능을 수정할 때, 전체 구조를 다시 고민할 필요 없이 해당 기능에만 집중할 수 있습니다. 이는 복잡성이 기하급수적으로 증가하는 것을 막아주며, 시간이 지나도 코드베이스가 복잡성에 잠식되지 않고 확장성을 유지할 수 있게 합니다.

### 1. 기존 아키텍처의 한계점

**전통적인 폴더 구조의 문제**:

- **기술별 분리**: `components/`, `services/`, `utils/` 등 기술적 기준에 따라 분리되어 있습니다.
- **도메인 분산**: 하나의 기능을 구현하는 코드가 여러 폴더에 흩어져 있어 파악하기 어렵습니다.
- **의존성 혼재**: 서로 다른 기능 간에 무분별한 의존성이 발생하기 쉽습니다.
- **확장성 부족**: 새로운 기능을 추가할 때 기존 구조에 영향을 미치기 쉽습니다.

**실제 문제 사례**:

```
// 전통적인 구조의 문제점
src/
├── components/
│   ├── UserProfile.jsx     // 사용자 관련
│   ├── ProductCard.jsx     // 상품 관련
│   └── OrderHistory.jsx    // 주문 관련
├── services/
│   ├── userService.js      // 사용자 API
│   ├── productService.js   // 상품 API
│   └── orderService.js     // 주문 API
└── utils/
    ├── userUtils.js        // 사용자 유틸리티
    └── validation.js       // 공통 검증

// 문제: 하나의 기능을 수정하려면 여러 폴더를 오가야 합니다.
```

## 🏗️ FSD 아키텍처 구조

### 레이어 구조 (상위 → 하위)

```
src/
├── app/          # 애플리케이션 설정, 라우팅, 글로벌 스타일
├── pages/        # 페이지 컴포넌트
├── widgets/      # 독립적인 UI 블록 (헤더, 사이드바, 폼 등)
├── features/     # 비즈니스 기능 (로그인, 검색, 필터링 등)
├── entities/     # 비즈니스 엔티티 (사용자, 상품, 주문 등)
└── shared/       # 공유 유틸리티, UI 컴포넌트, API 등
```

### 의존성 규칙

```
app → pages → widgets → features → entities → shared
```

- **상위 레이어**는 **하위 레이어**에만 의존할 수 있습니다.
- **하위 레이어**는 **상위 레이어**에 의존할 수 없습니다.
- **같은 레이어** 내에서는 **순환 의존성**이 금지됩니다.
