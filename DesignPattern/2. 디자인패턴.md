# 디자인 패턴

디자인 패턴을 공부하다 보면 **`abstract` (추상), `concrete` (구체), 그리고 `super()`** 라는 용어가 자주 등장합니다. 이 세 가지는 모두 객체 지향 프로그래밍의 핵심 개념이며, 특히 상속과 관련하여 중요한 역할을 합니다.

### Abstract (추상)

`abstract`는 미완성된 설계도와 같습니다. 객체 지향에서 `abstract` 키워드는 추상 클래스(Abstract Class)나 추상 메서드(Abstract Method)를 정의할 때 사용됩니다.

- **추상 클래스** : 인스턴스를 직접 생성할 수 없고, 반드시 다른 클래스가 상속받아 **완성해야만** 사용할 수 있는 클래스입니다.
- **추상 메서드** : 메서드의 선언부(이름, 매개변수)만 있고 구현부(메서드 본문)는 없는 메서드입니다. 하위 클래스가 이 메서드를 반드시 오버라이드(재정의)하도록 강제하는 역할을 합니다.

  **목적** : 알고리즘의 뼈대나 공통적인 속성을 정의하여, 하위 클래스들이 따라야 할 **규칙**을 제시하는 데 사용됩니다. 템플릿 메서드 패턴이 대표적인 예입니다.

### Concrete (구체)

`concrete`는 완성된 설계도입니다. 이는 구체 클래스(Concrete Class)를 의미하며, 추상 클래스와 반대되는 개념입니다.

- **구체 클래스** : 모든 메서드가 구현되어 있어, **바로 인스턴스를 생성하여 사용할 수 있는** 클래스입니다.
- `abstract` 클래스를 상속받은 경우, 모든 추상 메서드를 반드시 구현해야만 `concrete` 클래스가 될 수 있습니다.

  **목적** : 추상 클래스나 인터페이스가 제시한 규칙에 따라 **실제 기능**을 구현하여, 객체로 사용할 수 있게 만드는 데 사용됩니다.

### `super()`

`super()`는 **부모 클래스(상위 클래스)를 참조하는 키워드**입니다. 👨‍👧 자식 클래스가 부모 클래스의 메서드나 생성자에 접근할 때 사용됩니다.

- **생성자 호출** : `super()`를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 호출할 수 있습니다. 이는 자식 객체가 생성될 때 부모 객체의 초기화 로직도 함께 수행되도록 보장합니다.
- **메서드 호출** : 자식 클래스가 부모 클래스의 메서드를 오버라이드한 후, 부모의 원래 메서드를 호출하고 싶을 때 `super.메서드이름()` 형태로 사용됩니다. 이는 부모의 공통 로직을 재사용하면서 자식 클래스만의 추가적인 로직을 구현할 수 있게 해줍니다.

  **목적** : 상속 관계에서 **부모 클래스의 기능을 확장하거나 재사용**하는 데 필수적인 역할을 합니다.

```javascript
// --- 부모 클래스 ---
class Parent {
  constructor(name) {
    this.name = name;
    console.log(`[부모 생성자] 이름: ${this.name}으로 설정되었습니다.`);
  }
}

// --- 자식 클래스 ---
// 'extends' 키워드를 사용하여 Parent 클래스를 상속받습니다.
class Child extends Parent {
  constructor(name, hobby) {
    // 1. super()를 사용하여 부모 클래스의 생성자를 호출합니다.
    //    'this'를 사용하기 전에 반드시 super()를 먼저 호출해야 합니다.
    super(name);

    // 2. 부모 생성자가 실행된 후, 자식 클래스만의 속성을 초기화합니다.
    this.hobby = hobby;
    console.log(`[자식 생성자] 취미: ${this.hobby}가 추가되었습니다.`);
  }
}

const child = new Child("철수", "코딩");
// [부모 생성자] 이름: 철수으로 설정되었습니다.
// [자식 생성자] 취미: 코딩가 추가되었습니다.
```
