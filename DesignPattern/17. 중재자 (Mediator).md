# 중재자 (Mediator)

## 개요

**객체 간의 복잡한 통신과 상호작용을 캡슐화하고, 이를 중재자 객체에게 위임하는** 행동 패턴입니다. 이 패턴을 사용하면 여러 객체가 서로를 직접 참조하지 않고 중재자 객체를 통해서만 소통하로 결합도를 낮추게 됩니다. 복잡한 통신 로직을 중재자 객체에 집중시켜, 개별 객체(동료)의 코드를 단순하게 만듭니다.

## 프론트엔드 활용 아이디어

- **채팅방**: 웹소켓 커넥션만 연결하고 내부 로직은 캡슐화 된 상태
- **대시보드 필터링**: UI 컴포넌트와 전역상태(중재자) 필터 로직을 분리

## 백엔드/전체 활용 아이디어

- **마이크로서비스 통신**: 서비스 간 메시지 라우팅
- **항공 교통**: 비행기(동료) / 관제탑(중재자)
- **이벤트 버스**: 중재자(이벤트 버스)가 이벤트를 구독하는(subscribe) 모든 객체에 알림

## 구조

- Mediator(중재자), ConcreteMediator(구체 중제자)
- Colleague(동료)

## React 예제

전역상태가 곧 중재자 패턴입니다. 껄껄

```javascript
import React, { useState, useEffect, createContext, useContext } from "react";

// 중재자 컨텍스트 생성
const FilterContext = createContext();

// 중재자 (Mediator): 모든 필터의 상태를 관리하고, 제품 리스트에 반영
const FilterMediator = ({ children }) => {
  const [filters, setFilters] = useState({
    category: "all",
    priceRange: "all",
    inStock: false,
  });

  const updateFilter = (newFilters) => {
    setFilters((prevFilters) => ({ ...prevFilters, ...newFilters }));
  };

  return (
    <FilterContext.Provider value={{ filters, updateFilter }}>
      <div>{children}</div>
    </FilterContext.Provider>
  );
};

// 동료 (Colleague): 카테고리 필터
const CategoryFilter = () => {
  const { filters, updateFilter } = useContext(FilterContext);
  return (
    <div>
      <select
        value={filters.category}
        onChange={(e) => updateFilter({ category: e.target.value })}
      >
        <option value="all">전체</option>
        <option value="electronics">전자제품</option>
        <option value="books">도서</option>
      </select>
    </div>
  );
};

// 동료 (Colleague): 재고 필터
const InStockFilter = () => {
  const { filters, updateFilter } = useContext(FilterContext);
  return (
    <div>
      <input
        id="inStock"
        type="checkbox"
        checked={filters.inStock}
        onChange={(e) => updateFilter({ inStock: e.target.checked })}
      />
      <label htmlFor="inStock">재고 있음</label>
    </div>
  );
};

// 동료 (Colleague): 제품 리스트 (필터 상태에 따라 렌더링)
const ProductList = () => {
  const { filters } = useContext(FilterContext);
  const allProducts = [
    {
      id: 1,
      name: "노트북",
      category: "electronics",
      price: 1200,
      inStock: true,
    },
    {
      id: 2,
      name: "스마트폰",
      category: "electronics",
      price: 800,
      inStock: false,
    },
    { id: 3, name: "패턴 디자인", category: "books", price: 25, inStock: true },
  ];

  const filteredProducts = allProducts.filter((product) => {
    const categoryMatch =
      filters.category === "all" || product.category === filters.category;
    const stockMatch = !filters.inStock || product.inStock;
    return categoryMatch && stockMatch;
  });

  return (
    <div>
      <h3>제품 목록</h3>
      {filteredProducts.map((product) => (
        <div key={product.id}>
          <p>{product.name}</p>
          <p>
            {product.category} - ${product.price}
          </p>
          <p
            className={`${product.inStock ? "text-green-600" : "text-red-600"}`}
          >
            {product.inStock ? "재고 있음" : "재고 없음"}
          </p>
        </div>
      ))}
    </div>
  );
};
```
