# 빌더 (Builder)

## 개요

빌더 패턴은 복잡한 객체를 생성하는 과정과 객체를 표현하는 방법을 분리하여, 동일한 생성 절차를 통해 다양한 형태의 객체를 만들 수 있게 해주는 디자인 패턴입니다. 이는 특히 생성자에 인자가 많아지는 문제를 해결하는 데 유용합니다.

복잡한 객체를 생성할 때, 객체의 구성 요소를 단계별로 조립하는 방식을 사용합니다. 각 구성 요소는 빌더 객체의 메서드를 통해 설정되며, 최종적으로 `build()`와 같은 메서드를 호출하여 완성된 객체를 얻습니다.

## 프론트엔드 활용 아이디어

- **URL/QueryString 빌더**: 필터/정렬/페이지 파라미터 조립
- **FormData 빌더**: 멀티파트 업로드 구성
- **className/style 빌더**: 조건부 스타일 안전 조립

## 백엔드/전체 활용 아이디어

- **쿼리 빌더**: SQL 쿼리 단계적 구성
- **API 요청**: 복잡한 요청 페이로드 단계적 구성
- **설정 객체**: 옵션이 많은 설정 객체 생성

## 구조

- Builder(단계 API), ConcreteBuilder(단계 구현/결과 보유)
- Director(절차/순서 통제), Product(완성 결과)

## 장단점

- **장점**: 생성 절차와 결과 분리, 단계별 유효성 검증, 가독성 향상
- **단점**: 보일러플레이트 증가, 단순 객체에는 과도

## 구현 팁

- 불변 객체를 원하면 build() 후 내부 상태 초기화로 재사용 가능
- 필수 단계는 Director에서 강제

## JavaScript 예제

```javascript
class QueryBuilder {
  constructor() {
    this._select = [];
    this._from = "";
    this._where = [];
  }
  select(...cols) {
    this._select.push(...cols);
    return this;
  } // 체이닝 지원
  from(table) {
    this._from = table;
    return this;
  }
  where(cond) {
    this._where.push(cond);
    return this;
  }
  build() {
    // 최종 문자열 조립(부작용 없이 생성)
    const s = `SELECT ${this._select.join(", ") || "*"} FROM ${this._from}`;
    const w = this._where.length ? ` WHERE ${this._where.join(" AND ")}` : "";
    return s + w;
  }
}

// Director를 별도로 둘 수도 있으나 간단 예시는 생략
const sql = new QueryBuilder()
  .select("id", "name")
  .from("users")
  .where("active=1")
  .build();
console.log(sql);
```

## 🎨 리액트 예제

```javascript
// 간단한 유틸리티 함수
function cn(...classes) {
  return classes.filter(Boolean).join(" ");
}

// 조건부 클래스 추가
function cnIf(condition, trueClass, falseClass = "") {
  return condition ? trueClass : falseClass;
}

// 사용 예시
const buttonClass = cn(
  "px-4 py-2 rounded-lg font-medium",
  "bg-blue-500 hover:bg-blue-600",
  "text-white transition-colors",
  cnIf(isLoading, "opacity-50 cursor-not-allowed", "hover:shadow-md")
);

// 출력: "px-4 py-2 rounded-lg font-medium bg-blue-500 hover:bg-blue-600 text-white transition-colors hover:shadow-md"
```

이러한 className 빌더를 사용하면:

✅ **가독성 향상**: 복잡한 조건부 스타일을 명확하게 표현
✅ **재사용성**: 컴포넌트별 스타일을 체계적으로 관리
✅ **유지보수성**: 스타일 변경 시 한 곳에서 수정
✅ **타입 안전성**: 잘못된 클래스명 사용 방지
✅ **성능 최적화**: 불필요한 클래스 재계산 방지
