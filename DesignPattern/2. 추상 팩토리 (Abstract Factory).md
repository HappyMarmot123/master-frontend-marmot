# 추상 팩토리 (Abstract Factory)

## 개요

추상 팩토리 패턴은 **서로 관련성이 있는 여러 객체들을 묶어서** 한 번에 생성하는 인터페이스를 제공하는 디자인 패턴입니다. 클라이언트 코드는 구체적인 클래스에 직접 의존하지 않고, 추상 팩토리 인터페이스를 통해 객체들을 생성하고 사용합니다.

이 패턴의 핵심은 **객체들의 '패밀리'**를 만드는 데 있습니다. 예를 들어, UI 디자인 시스템에서 다크 모드와 라이트 모드 테마를 구현한다고 가정해 봅시다.

- **문제점:** 만약 다크 모드 `Button`과 다크 모드 `Checkbox`, 그리고 라이트 모드 `Button`과 라이트 모드 `Checkbox`를 각각 `new`로 생성하면, 코드가 특정 테마에 종속되어 새로운 테마를 추가하거나 변경할 때마다 코드를 대대적으로 수정해야 합니다.
- **해결책:** 추상 팩토리 패턴을 사용하면, `UIFactory`라는 추상 팩토리를 정의하고, 이 팩토리가 `createButton()`과 `createCheckbox()`와 같은 객체 생성 메서드를 갖도록 합니다.

## 프론트엔드 활용 아이디어

- **테마별 UI 컴포넌트 팩토리**: 라이트/다크 테마 버튼·모달 일관 생성
- **플랫폼별 위젯**: Web/Desktop/Mobile 제품군 교체
- **국제화(i18n) 포맷터**: 날짜/통화/숫자 포맷터 패밀리

## 백엔드/전체 활용 아이디어

- **데이터 저장소 추상화**: 관계형/NoSQL/파일 스토리지 교체
- **외부 시스템 통합**: API 클라이언트, 메시지 브로커 교체
- **환경별 설정**: 개발/스테이징/프로덕션 환경별 팩토리

## 구조

- AbstractFactory(제품군 생성 인터페이스)
- ConcreteFactory(구체 제품군 생성)
- AbstractProduct/ConcreteProduct(제품 인터페이스/구현)
- Client(추상 타입에만 의존)

## 장단점

- **장점**: 일관성 있는 제품군 생성, 구체 클래스 은닉, 교체 용이
- **단점**: 제품 종류 추가가 어려움(모든 팩토리/인터페이스 수정)

## 구현 팁

- 제품군 간 일관성 규칙을 인터페이스 수준에서 강제
- IoC 컨테이너로 팩토리 바인딩을 환경별로 주입

## JavaScript 예제

```javascript
// 추상 제품: 버튼, 체크박스
class Button {
  render() {}
}
class Checkbox {
  toggle() {}
}

// 구체 제품: Windows 구현
class WinButton extends Button {
  render() {
    console.log("WinButton");
  }
}
class WinCheckbox extends Checkbox {
  toggle() {
    console.log("WinCheckbox");
  }
}

// 구체 제품: Mac 구현
class MacButton extends Button {
  render() {
    console.log("MacButton");
  }
}
class MacCheckbox extends Checkbox {
  toggle() {
    console.log("MacCheckbox");
  }
}

// 추상 팩토리: 제품군 생성 API
class WidgetFactory {
  createButton() {
    throw new Error("not impl");
  }
  createCheckbox() {
    throw new Error("not impl");
  }
}

// 구체 팩토리: Windows 제품군 생성
class WinFactory extends WidgetFactory {
  createButton() {
    return new WinButton();
  }
  createCheckbox() {
    return new WinCheckbox();
  }
}

// 구체 팩토리: Mac 제품군 생성
class MacFactory extends WidgetFactory {
  createButton() {
    return new MacButton();
  }
  createCheckbox() {
    return new MacCheckbox();
  }
}

// 클라이언트: 추상 팩토리에만 의존(구체 구현은 주입으로 교체)
function renderDialog(factory) {
  const btn = factory.createButton();
  const chk = factory.createCheckbox();
  btn.render(); // 구체 구현에 상관없이 동일 호출
  chk.toggle();
}

renderDialog(new WinFactory());
renderDialog(new MacFactory());
```
