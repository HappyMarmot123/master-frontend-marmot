# 템플릿 메서드 (Template Method)

## 개요

템플릿 메서드(Template Method) 패턴은 **알고리즘의 뼈대(구조)는 미리 정의해 두고, 각 단계의 구체적인 구현은 하위 클래스에 맡기는** 행동 디자인 패턴입니다.

이 패턴을 사용하면 알고리즘의 전체적인 흐름은 변하지 않으면서도, 특정 단계의 구현만 다양하게 변경할 수 있습니다. 예를 들어, 라면 끓이기를 생각해 보세요. "물 끓이기 - 스프 넣기 - 면 넣기 - 끓이기"라는 전체적인 순서는 항상 같지만, 스프 넣기나 면 넣기의 구체적인 방식은 라면 종류에 따라 다를 수 있습니다.

## 전체 활용 아이디어

- **유형에 따라 바뀌는 방식**: 사용자 인증
- **UI 렌더링 템플릿**: 불러오기 → 정규화 → 리사이즈 → 저장

## 장단점

- **장점**: 코드 재사용/일관성, 훅으로 확장 포인트 제공
- **단점**: 상속 결합, 하위 클래스 남용 가능

## JavaScript 예제

```javascript

// 추상 클래스: 로그인 절차의 뼈대
class Authenticator {
    authenticate(credentials) {
        const user = this.verifyUser(credentials);
        if (user) {
            this.onLoginSuccess(user);
        }

        return user;
    }

    // 훅 메서드 (Hook Method): 하위 클래스가 재정의할 부분
    verifyUser(credentials) {
        throw new Error("verifyUser() 메서드를 구현해야 합니다.");
    }

    // 훅 메서드 (선택적): 하위 클래스가 필요하면 재정의
    onLoginSuccess(user) {
        console.log("✅ 공통 처리: 사용자 세션 생성");
    }
}

---

// 구체 클래스 1: 이메일/비밀번호 인증
class EmailAuthenticator extends Authenticator {
    verifyUser(credentials) {
        console.log("📧 이메일/비밀번호로 사용자 인증 중...");
        if (credentials.email === "test@example.com" && credentials.password === "1234") {
            return { name: "테스터" };
        }
        return null;
    }
}

// 구체 클래스 2: 구글 OAuth2 인증
class GoogleAuthenticator extends Authenticator {
    verifyUser(credentials) {
        if (credentials.token === "valid_google_token") {
            return { name: "구글 유저" };
        }
        return null;
    }

    onLoginSuccess(user) {
        super.onLoginSuccess(user);
    }
}

---

// 1단계: 이메일 인증기로 로그인
const emailAuth = new EmailAuthenticator();
console.log("--- 이메일 로그인 시도 ---");
emailAuth.authenticate({ email: "test@example.com", password: "1234" });

// 2단계: 구글 인증기로 로그인
const googleAuth = new GoogleAuthenticator();
console.log("\n--- 구글 로그인 시도 ---");
googleAuth.authenticate({ token: "valid_google_token" });
```

## 추상 팩토리(Abstract Factory) 패턴과의 차이점

템플릿 메서드 패턴과 추상 팩토리 패턴은 모두 디자인 패턴으로서 유연성을 제공하지만, 그 목적과 핵심 '관심사'가 본질적으로 다릅니다.

- **템플릿 메서드 패턴:** **"어떻게 동작할까?"** 에 집중합니다. 즉, 알고리즘의 전체적인 '구조'나 '흐름'을 정의하고, 특정 단계의 구현만 하위 클래스에 위임하여 '행동'의 변화에 유연하게 대응합니다.

  - **핵심 책임:** 알고리즘의 뼈대를 정의하고, 하위 클래스가 재정의할 '훅(Hook) 메서드'를 제공합니다.
  - **예시:** 로그인 절차(템플릿)는 동일하지만, 인증 방식(구체적인 단계)이 이메일, Google OAuth 등으로 달라질 때 사용합니다.

- **추상 팩토리 패턴:** **"무엇을 만들까?"** 에 집중합니다. 즉, 관련성이 있거나 의존적인 객체들의 '집합'을 생성하는 인터페이스를 제공하고, 구체적인 팩토리 클래스에서 특정 제품군(Family of objects)을 생성하도록 위임합니다. 이는 '객체 생성'의 변화에 유연하게 대응합니다.
  - **핵심 책임:** 객체들의 제품군을 생성하는 데 필요한 인터페이스를 정의합니다.
  - **예시:** OS별 UI 구성 요소(버튼, 체크박스) 세트를 생성하거나, DB 종류별 커넥션, 쿼리 생성 객체들을 묶어 생성할 때 사용합니다.
