# 어댑터 (Adapter)

## 개요

어댑터 패턴은 **한 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하는** 디자인 패턴입니다. 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동하도록 돕습니다.

이 패턴은 주로 이미 존재하는 클래스를 재사용하고 싶지만, 그 클래스의 인터페이스가 현재 시스템의 요구 사항과 맞지 않을 때 사용됩니다. 어댑터는 '번역기' 역할을 하여, 원래 클래스를 수정하지 않고도 클라이언트 코드와 소통할 수 있게 해줍니다

한 줄 요약: 구형 충전기를 C타입에 연결하기 위해 젠더(어댑터)를 사용합니다.

## 프론트엔드 활용 아이디어

- **API 래퍼 어댑터**: fetch/XHR/GraphQL 클라이언트를 공통 HttpClient 인터페이스로 통일
- **저장소 어댑터**: localStorage/SessionStorage/IndexedDB를 공통 Storage 인터페이스로 변환
- **외부 SDK 통합**: Google Analytics/Amplitude 등 이벤트 스키마 통합

## 백엔드/전체 활용 아이디어

- **레거시 시스템 통합**: 구형 API를 새로운 시스템에 맞게 변환
- **데이터베이스 드라이버**: 다양한 DB를 공통 인터페이스로 추상화
- **외부 API 클라이언트**: REST/SOAP/GraphQL 등 다양한 프로토콜 통합

## 장단점

- **장점**: 레거시 재사용, 결합도 감소, 점진적 마이그레이션 가능
- **단점**: 객체 수 증가, 간접 호출로 디버깅 경로 길어짐

## JavaScript 예제

```javascript
// Target: 클라이언트가 기대하는 인터페이스
class HttpClient {
  // 표준화된 GET 메서드
  get(url) {
    throw new Error("Not implemented");
  }
}

// Adaptee: 레거시/외부 라이브러리 - 시그니처가 다름
class LegacyFetcher {
  // fetchJson(url): Promise<any>
  fetchJson(url) {
    return fetch(url).then((res) => {
      return res.json();
    });
  }
}

// Adapter: Target을 구현하고 내부적으로 Adaptee를 사용
class LegacyFetcherAdapter extends HttpClient {
  constructor(legacy) {
    super();
    this.legacy = legacy; // 구성(Composition)을 통한 위임
  }
  // 클라이언트는 get만 알면 됨
  get(url) {
    // 필요 시 헤더/에러 모델/응답 스키마 변환도 수행
    return this.legacy.fetchJson(url);
  }
}

// 사용 예: 의존 역전 원칙을 지키며 교체 용이
const client = new LegacyFetcherAdapter(new LegacyFetcher());
client
  .get("/api/users") // Target 인터페이스만 의존
  .then((data) => {
    // data 후처리(스키마 정규화 등)도 어댑터에서 할 수 있음
    console.log("users:", data);
  })
  .catch((err) => {
    // 표준화된 에러 처리 경로 확보
    console.error("request failed:", err.message);
  });
```
