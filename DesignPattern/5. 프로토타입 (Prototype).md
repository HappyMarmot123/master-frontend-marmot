# 프로토타입 (Prototype)

## 📖 개요

프로토타입 패턴은 **기존 객체를 복제하여 새로운 객체를 생성**하는 패턴입니다. `new` 키워드를 사용하여 객체를 직접 생성하는 대신, 이미 만들어진 **'원형(prototype)' 객체**를 복사(clone)하여 새로운 객체를 만드는 방식입니다. 이 패턴은 객체 생성 비용이 크거나, 객체를 직접 생성하기 어려운 경우에 유용합니다.

게임을 예시로 들면, 본인의 능력치를 그대로 복사한 분신이 생기는 것, 그러나 생긴 이후엔 분신과 본체의 체력 감소는 각각 이루어져야 한다. 만약 체력이 서로 동기화된 상태라면? 그것은 **얕은 복사** 상태, 프로토타입으로 복제한 객체가 원본(프로토타입)에 영향을 주지 않으려면 **깊은 복사(Deep Copy)** 를 사용해야 합니다.

## ✅ 장점

- **생성 비용 절감**: 복잡한 초기화 과정 생략

## ❌ 단점

- **복사 복잡성**: 깊은 복사 시 순환 참조 처리 어려움
- **메모리 사용량**: 큰 객체 복사 시 메모리 사용량 증가
- **성능 오버헤드**: 복잡한 객체 구조 복사 시 성능 저하 가능

## 🚀 실용적 예제

### 1. 게임 캐릭터 프로토타입 (바닐라 자바스크립트)

```javascript
// 깊은 복사 유틸리티 함수
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((item) => deepClone(item));

  const cloned = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  return cloned;
}

// 게임 캐릭터 프로토타입
class GameCharacter {
  constructor(name, stats) {
    this.name = name;
    this.stats = stats;
  }

  clone() {
    return deepClone(this);
  }

  takeDamage(damage) {
    this.stats.health -= damage;
  }
}

// 사용 예시
const original = new GameCharacter("용사", { health: 100, mana: 50 });
const cloned = original.clone();
cloned.name = "용사의 분신";

// 독립성 테스트
original.takeDamage(20);
cloned.takeDamage(30);
```

### 2. 설정 템플릿 프로토타입 (Lodash 사용)

```javascript
// 설정 템플릿 프로토타입
class ConfigTemplate {
  constructor(name, settings, environment) {
    this.name = name;
    this.settings = settings;
    this.environment = environment;
  }

  cloneWithLodash() {
    if (typeof _ !== "undefined" && _.cloneDeep) {
      return _.cloneDeep(this);
    }
    return JSON.parse(JSON.stringify(this));
  }

  applyEnvironment(env) {
    if (this.environment[env]) {
      Object.assign(this.settings, this.environment[env]);
    }
  }
}

// 사용 예시
const baseConfig = new ConfigTemplate(
  "Production",
  {
    database: { host: "localhost", port: 5432 },
    api: { port: 3000 },
  },
  {
    development: { database: { host: "dev-db" }, api: { port: 3001 } },
    staging: { database: { host: "staging-db" }, api: { port: 3002 } },
  }
);

const devConfig = baseConfig.cloneWithLodash();
devConfig.name = "Development";
devConfig.applyEnvironment("development");

console.log("개발 환경 호스트:", devConfig.settings.database.host); // dev-db
```

### 🔧 구현 팁

### 1. **깊은 복사 방법 선택**

- **바닐라 JS**: `JSON.parse(JSON.stringify())` - 간단하지만 제한적
- **Lodash**: `_.cloneDeep()` - 안전하고 완전한 깊은 복사
- **Structured Clone API**: `structuredClone()` - 최신 브라우저 지원

### 2. **순환 참조 처리**

```javascript
function deepCloneWithCircular(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== "object") return obj;
  if (hash.has(obj)) return hash.get(obj);

  const cloned = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloned);

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepCloneWithCircular(obj[key], hash);
    }
  }

  return cloned;
}
```
