# 객체 지향 프로그래밍 (Object-Oriented Programming)

## 📖 개요

**객체 지향 프로그래밍(OOP)** 은 현대 소프트웨어 개발의 핵심 패러다임 중 하나입니다. 데이터와 그 데이터를 조작하는 메서드를 하나의 단위(객체)로 묶어 프로그램을 구성하는 방식으로, 코드의 재사용성, 유지보수성, 확장성을 크게 향상시킵니다.

**클래스**는 객체를 생성하기 위한 템플릿으로, 객체가 가져야 할 속성과 메서드를 정의합니다.

**객체**는 클래스의 인스턴스로, 실제 메모리에 할당되어 동작하는 실체입니다.

## 🔍 객체 지향의 4대 원칙

#### 캡슐화(Encapsulation)

- **정보 은닉**: 구현 세부사항을 외부에 노출하지 않음
- **접근 제어**: public, private, protected 등의 접근 제한자 사용

#### 상속(Inheritance)

- **코드 재사용**: 기존 클래스의 기능을 새로운 클래스에서 재사용
- **다형성 기반**: 상속을 통한 다형성 구현

#### 다형성(Polymorphism)

- **다형성:** 하나의 클래스나 메서드가 다양한 형태를 가질 수 있는 성질을 의미합니다
- **오버라이딩**: 자식 클래스에서 부모 클래스의 메서드 재정의
- **오버로딩**: 동일한 이름의 메서드를 다른 매개변수로 정의

#### 추상화(Abstraction)

- **복잡성 감소**: 복잡한 시스템을 단순한 모델로 표현
- **구현 분리**: 추상화된 인터페이스와 구체적인 구현을 분리

## 🎯 SRP (Single Responsibility Principle)

SRP는 단일 책임 원칙으로, 하나의 클래스는 하나의 책임만 가져야 한다는 원칙입니다. 즉, 클래스가 변경되어야 하는 이유는 오직 하나여야 합니다.

### 왜 중요한가?

- 코드의 응집도를 높이고 결합도를 낮춥니다.
- 변경 사유가 명확해져 유지보수가 쉬워집니다.
- 테스트가 용이해지고 재사용성이 향상됩니다.

### 냄새 나는 설계(나쁜 예)

하나의 클래스가 여러 책임을 가지고 있는 경우입니다.

```javascript
// 사용자 관리, 이메일 발송, 로깅을 모두 담당하는 클래스 (SRP 위반)
class UserManager {
  constructor() {
    this.users = [];
  }

  addUser(user) {
    this.users.push(user);
    this.sendWelcomeEmail(user); // 이메일 발송 책임
    this.logUserCreation(user); // 로깅 책임
  }

  sendWelcomeEmail(user) {
    // 이메일 발송 로직
    console.log(`Welcome email sent to ${user.email}`);
  }

  logUserCreation(user) {
    // 로깅 로직
    console.log(`User ${user.name} created at ${new Date()}`);
  }
}
```

### SRP 준수(좋은 예)

각 클래스가 하나의 책임만 가지도록 분리합니다.

```javascript
// 사용자 관리만 담당
class UserManager {
  constructor() {
    this.users = [];
  }

  addUser(user) {
    this.users.push(user);
  }

  getUsers() {
    return this.users;
  }
}

// 이메일 발송만 담당
class EmailService {
  sendWelcomeEmail(user) {
    console.log(`Welcome email sent to ${user.email}`);
  }
}

// 로깅만 담당
class Logger {
  logUserCreation(user) {
    console.log(`User ${user.name} created at ${new Date()}`);
  }
}

// 사용: 각 서비스를 조합하여 사용
class UserService {
  constructor(userManager, emailService, logger) {
    this.userManager = userManager;
    this.emailService = emailService;
    this.logger = logger;
  }

  createUser(user) {
    this.userManager.addUser(user);
    this.emailService.sendWelcomeEmail(user);
    this.logger.logUserCreation(user);
  }
}

// 사용 예시
const userManager = new UserManager();
const emailService = new EmailService();
const logger = new Logger();
const userService = new UserService(userManager, emailService, logger);

userService.createUser({ name: "John", email: "john@example.com" });
```

### 적용 가이드

- 규칙: 클래스가 변경되어야 하는 이유가 하나인지 확인하세요.
- 분리 기준: 기능적 응집도가 높은 메서드들을 하나의 클래스로 묶으세요.
- 의존성: 각 클래스는 필요한 최소한의 의존성만 가져야 합니다.

### 안티패턴

- 거대한 클래스(God Class)
- 여러 책임을 가진 클래스
- 변경 사유가 여러 개인 클래스

## 🧱 OCP (Open-Closed Principle)

OCP는 소프트웨어 개체(클래스, 모듈, 함수 등)가 확장에는 열려(Open) 있고 변경에는 닫혀(Closed) 있어야 한다는 원칙입니다. 즉, 기존 코드를 수정하지 않고도 새로운 기능을 추가(확장)할 수 있어야 합니다.

### 왜 중요한가?

- 변경 범위를 최소화하여 회귀 버그를 줄입니다.
- 공통 규약(추상화)에 의존함으로써 기능을 플러그인처럼 교체·추가할 수 있습니다.
- 테스트 용이성 및 유지보수성이 향상됩니다.

### 냄새 나는 설계(나쁜 예)

요구사항이 추가될 때마다 조건문을 수정해야 하는 구조는 OCP를 위반합니다.

```javascript
// 결제 타입이 늘어날 때마다 이 함수 자체를 수정해야 함 (OCP 위반)
function pay(amount, method) {
  if (method === "card") {
    // ... 카드 결제 로직
  } else if (method === "paypal") {
    // ... 페이팔 결제 로직
  } else if (method === "crypto") {
    // ... 암호화폐 결제 로직
  } else {
    throw new Error("지원하지 않는 결제 방식");
  }
}
```

### OCP 준수(좋은 예)

공통 인터페이스(추상화)에 의존하고, 구체 구현을 추가로 제공하여 기능을 확장합니다. 기존 코드는 수정하지 않습니다.

```javascript
// 공통 인터페이스(프로토콜)
class PaymentStrategy {
  pay(amount) {
    throw new Error("pay를 구현해야 합니다.");
  }
}

class CardPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[CARD] ${amount}원 결제`);
  }
}

class PaypalPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[PAYPAL] ${amount}원 결제`);
  }
}

// 새로운 방식 추가 시, 기존 코드 수정 없이 클래스만 추가
class CryptoPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`[CRYPTO] ${amount}원 결제`);
  }
}

class PaymentProcessor {
  constructor(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }
  setStrategy(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }
  process(amount) {
    this.paymentStrategy.pay(amount);
  }
}

// 사용
const processor = new PaymentProcessor(new CardPayment());
processor.process(10000);
processor.setStrategy(new PaypalPayment());
processor.process(20000);
```

### 적용 가이드

- 규칙: "변하는 것"과 "변하지 않는 것"을 분리하고, 변하는 축을 추상화로 캡슐화합니다.
- 의존성 방향: 구체 구현이 아닌 추상화(인터페이스/추상 클래스/프로토콜)에 의존합니다.
- 확장 포인트: 팩토리, 전략 패턴, 템플릿 메서드, 의존성 주입(DI), 플러그인 아키텍처를 활용합니다.

### 안티패턴

- 거대한 if/switch 분기
- 열거형(enum) 값 추가할 때마다 로직 곳곳을 수정
- 추상화 없이 구체 구현에 직접 의존

변화에 유연하게 대응하려면 "수정"보다 "확장"을 설계하세요.

추상화에 의존하고, 구체 구현은 교체 가능하게 만드세요.
