# 브리지 (Bridge)

## 개요

브리지(Bridge) 패턴은 **구현부**와 **추상부**를 분리하여 각 부분을 독립적으로 확장할 수 있게 하는 구조 패턴입니다.

브리지 패턴은 **두 개 이상의 클래스**들을 조합할 때 매우 효과적입니다. 이 패턴의 핵심은 클래스 간의 강력한 결합을 느슨하게 만들어 유연성을 높이는 것입니다. 추상부 클래스는 구현부 인터페이스의 객체를 **참조**로 가집니다.

예를 들어, `알림` 추상 클래스가 있고, 그 아래에 `경고알림`, `정보알림` 같은 구체적인 클래스가 있다고 가정해 봅시다. 만약 알림을 `이메일`, `휴대폰` 과 같이 SMS으로 전송하는 기능이 필요하다면 브리지 패턴이 적합합니다.

## 프론트엔드 활용 아이디어

- **렌더러 브리지**: React/Vue/Canvas/SVG 렌더러 교체
- **네트워크 브리지**: REST/GraphQL/WebSocket 전송 구현 교체
- **저장소 브리지**: 메모리/로컬/원격 저장 구현을 추상화

## 백엔드/전체 활용 아이디어

- **데이터베이스 드라이버**: 다양한 DB 엔진을 공통 인터페이스로 추상화
- **파일 시스템**: 로컬/클라우드/네트워크 스토리지 구현 교체
- **메시징 시스템**: 큐/이벤트/웹훅 등 다양한 전송 방식 지원

## 구조

- Abstraction(고수준 API) → Implementor(구현 인터페이스)에 위임
- RefinedAbstraction(기능 확장)
- ConcreteImplementor(구체 구현체)

## 장단점

- **장점**: 독립 확장, 배포 영향 축소, 클래스 폭발 방지
- **단점**: 간접성 증가로 복잡도 상승

## 구현 팁

- Abstraction은 구현체 생명주기 관리(주입, 교체) 책임을 갖게 함
- 성능 민감 경로는 호출 비용을 측정해 인라인 최적화 고려

## JavaScript 예제

```javascript
// 구현부 Messenger 인터페이스
class Messenger {
  send(message) {
    throw new Error('This method should be overridden!');
  }
}

// 이메일, SMS
class EmailMessenger extends Messenger {
  send(message) {
    console.log(`[이메일로 전송] ${message}`);
  }
}
class SmsMessenger extends Messenger {
  send(message) {
    console.log(`[SMS로 전송] ${message}`);
  }
}

---

// 추상부 Notifier 클래스
class Notifier {
  constructor(messenger) {
    this.messenger = messenger; // 구현부 객체 참조
  }
  notify(message) {
    throw new Error('This method should be overridden!');
  }
}

// 구체적인 추상부: 경고, 정보 알림
class WarningNotifier extends Notifier {
  constructor(messenger) {
    super(messenger);
  }
  notify(message) {
    this.messenger.send(`경고: ${message}`);
  }
}
class InfoNotifier extends Notifier {
  constructor(messenger) {
    super(messenger);
  }
  notify(message) {
    this.messenger.send(`정보: ${message}`);
  }
}

---

const emailMessenger = new EmailMessenger();
const smsMessenger = new SmsMessenger();

const warningEmail = new WarningNotifier(emailMessenger);
warningEmail.notify('시스템에 문제가 발생했습니다.');

const infoSms = new InfoNotifier(smsMessenger);
infoSms.notify('새로운 공지사항이 있습니다.');
```
