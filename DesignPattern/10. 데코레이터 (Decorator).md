# 데코레이터 (Decorator)

## 개요

데코레이터(Decorator) 패턴은 **객체에 기능(책임)을 동적으로 추가하거나 제거하는** 디자인 패턴입니다. 이는 상속을 사용하지 않고도 기존 객체의 기능을 확장할 수 있게 해줍니다.

데코레이터 패턴의 핵심은 **기존 객체를 래퍼(Wrapper)로 감싸서** 기능을 추가하는 것입니다. 마치 크리스마스 트리에 장식(데코레이터)을 추가하는 것처럼, 원본 객체는 그대로 둔 채 새로운 기능만 더하는 방식이죠. 이는 다음과 같은 상황에서 유용합니다.

- 상속을 통해 기능을 확장하면 클래스가 기하급수적으로 늘어날 수 있을 때
- 컴파일 시점이 아닌 **실행(런타임) 시점**에 객체의 기능을 유연하게 변경하고 싶을 때

### ⭐ 알고 계셨나요? ⭐

NestJS 데코레이터와 Java 어노테이션은 모두 데코레이터 디자인 패턴에서 영감을 받아 구현된 유용한 기능입니다! 원본 코드를 수정하지 않고도 기능을 확장할 수 있죠. 리액트에서는 데코레이터 패턴으로 HOC(High Order Component) 고차 컴포넌트를 사용합니다!

- **데코레이터**: 객체가 데코레이터에 래핑되어, 원본을 수정하지 않고도 확장/복원이 쉽습니다.
- **브리지**: 두 개의 계층(추상부/구현부) 간의 관계를 연결합니다. 결합도가 존재합니다.

## 프론트엔드 활용 아이디어

- **fetch 래퍼**: 로깅/리트라이/캐싱 데코레이터 조합
- **컴포넌트**: 접근 제어/측정/에러 경계 기능 주입

## 백엔드/전체 활용 아이디어

- **미들웨어 체인**: 로깅/인증/캐싱/로드밸런싱
- **데이터베이스**: 트랜잭션/로깅/캐싱 레이어
- **API 엔드포인트**: 권한/속도 제한/로깅 기능 추가

## 구현 팁

- 데코레이터 체인이 길어지면 로깅으로 추적 가능성 확보
- 성능 민감 경로는 중복 전/후처리 최소화

## JavaScript 예제

```javascript
class Coffee {
  cost() {
    return 1000; // 아메리카노 단가
  }
}

// 공통 데코레이터: 기본 위임 로직 제공
class Decorator extends Coffee {
  constructor(base) {
    super();
    this.base = base;
  }
  cost() {
    return this.base.cost();
  }
}

// 구체 데코레이터: 기능을 누적
class Milk extends Decorator {
  cost() {
    return super.cost() + 300;
  }
}
class Sugar extends Decorator {
  cost() {
    return super.cost() + 100;
  }
}

let drink = new Coffee(); // 런타임 조합 순서에 따라 결과가 달라질 수 있음
drink = new Milk(drink);
drink = new Sugar(drink);

// 두 개의 데코레이터가 래핑된 상태, 원재료값에 따라 추가 금액이 달라짐
console.log(drink.cost()); // 1400
```
