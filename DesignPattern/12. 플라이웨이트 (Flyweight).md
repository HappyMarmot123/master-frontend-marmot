# 플라이웨이트 (Flyweight)

## 개요

플라이웨이트(Flyweight) 패턴은 많은 수의 객체를 생성해야 하지만 대부분의 상태가 동일할 때 **여러 객체가 공유할 수 있는 부분을 찾아 메모리를 절약하는** 구조 패턴입니다.

## 플라이웨이트 패턴의 목적과 작동 방식

이 패턴의 핵심은 **내부 상태(Intrinsic State)**와 **외부 상태(Extrinsic State)**를 분리하는 것입니다.

- **내부 상태 (Intrinsic State)** : 여러 객체가 공유할 수 있는 **변하지 않는 속성**입니다. 이 상태는 플라이웨이트 객체에 저장됩니다. (예: 게임 캐릭터의 `모습`, `유형`)
- **외부 상태 (Extrinsic State)** : 객체마다 **고유하고 변할 수 있는 속성**입니다. 이 상태는 플라이웨이트 객체가 아닌 클라이언트 코드나 외부 컨텍스트에 저장됩니다. (예: 게임 캐릭터의 `좌표`, `체력`)

플라이웨이트 패턴은 **플라이웨이트 팩토리(Flyweight Factory)**라는 중앙 관리자를 통해 플라이웨이트 객체를 생성하고 공유합니다. 클라이언트가 특정 플라이웨이트 객체를 요청하면, 팩토리는 캐시에서 이미 생성된 객체가 있는지 확인하고, 있으면 그것을 반환하고 없으면 새로 생성해서 반환합니다.

## 프로토타입 vs 플라이웨이트

- **프로토타입**: 객체를 복사하고 새 인스턴스가 생성될 때마다 메모리 비용을 지불합니다.
- **플라이웨이트**: 패턴은 객체를 공유함으로써 이러한 비용을 피하도록 특별히 설계되었습니다.

### 주요 차이점

가장 큰 차이점은 **목적과 상태를 처리하는 방법** 에 있습니다 .

- **프로토타입(복사):** 프로토타입 패턴의 목표는 기존 객체를 복제하여 **새롭고 독립적인 객체를 생성하는 것** 입니다 . 생성 과정이 복잡하거나 비용이 많이 들 때 효율적으로 새 인스턴스를 생성하는 데 중점을 둡니다. 복제된 각 객체는 고유한 상태를 가진 별도의 엔티티입니다.

  - **상태:** 공유 상태와 고유한 상태를 포함한 객체의 전체 상태가 복사됩니다.
  - **사용 사례:** 각 새 사용자에 대해 새 사용자 프로필 객체를 생성합니다. 기본 구조는 동일하지만, 각 프로필에는 고유한 데이터(예: 이름, 나이, 선호도)가 있으며, 이러한 데이터는 독립적으로 수정해야 합니다.

- **플라이웨이트(공유):** 플라이웨이트 패턴의 목표는 동일하고 변하지 않는 상태를 가진 객체를 공유하여 **메모리를 절약하는 것** 입니다 . 최소한의 객체 사용을 극대화하는 것이 목적이며, **고유 상태(공유)** 와 **고유 상태(고유)** 를 분리하여 이를 달성합니다 .

  - **상태: 모든 객체는 \*\***내재적 상태** 만 공유합니다. **외재적 상태는\*\* 클라이언트가 외부에서 저장하고 관리합니다.
  - **사용 사례:** 숲 장면에 수천 개의 동일한 나무 객체를 표시합니다. `Tree`객체의 내재적 상태(모델, 텍스처, 잎 색상)는 공유되지만, 외재적 상태(맵 상의 좌표)는 게임 엔진에서 관리됩니다.

## 전체 활용 아이디어

- 두개의 모델 차량을 100대 생성할 때
- 하나의 나무 객체를 여러개 생성할때

## JavaScript 예제

```javascript
// 1. 플라이웨이트 (공유 가능한) 객체
// 여러 객체가 공유할 수 있는 변하지 않는 속성(내부 상태)을 가집니다.
class CarType {
  constructor(type, model) {
    this.type = type;
    this.model = model;
  }
}

// 2. 플라이웨이트 팩토리
// 플라이웨이트 객체의 캐시를 관리하고 공유하는 역할을 합니다.
const CarFactory = (function () {
  const flyweights = {}; // 캐시 역할 객체

  return {
    // 요청된 타입의 플라이웨이트 객체를 반환하거나 새로 생성합니다.
    getCarType: function (type, model) {
      const key = `${type}-${model}`;
      if (!flyweights[key]) {
        flyweights[key] = new CarType(type, model);
        console.log(`새로운 자동차 타입 생성: ${type} ${model}`);
      }
      return flyweights[key];
    },
    // 캐시에 저장된 객체 수를 반환합니다.
    getCreatedCount: function () {
      return Object.keys(flyweights).length;
    },
  };
})();

// 3. 클라이언트 코드
// 외부 상태(색상)를 관리하며, 플라이웨이트 팩토리를 사용합니다.
const carFleet = [];

// 2가지 고유한 타입으로 100대의 자동차를 생성합니다.
for (let i = 0; i < 100; i++) {
  const type = i % 2 === 0 ? "세단" : "SUV";
  const model = i % 2 === 0 ? "모델 X" : "모델 Y";
  const color = i % 3 === 0 ? "빨강" : "파랑"; // 고유한 외부 상태

  // 공유된 플라이웨이트 객체를 가져옵니다.
  const carType = CarFactory.getCarType(type, model);

  // 공유된 플라이웨이트와 고유한 외부 상태를 함께 저장합니다.
  carFleet.push({ carType, color });
}

// 실제 메모리에 생성된 자동차는 단 2대뿐입니다. 생성된 100대의 차량은 별도로 관리되어 메모리 사용량을 크게 절약합니다.
console.log(`총 자동차 수: ${carFleet.length}`);
console.log(`실제로 생성된 타입 객체 수: ${CarFactory.getCreatedCount()}`);
```
