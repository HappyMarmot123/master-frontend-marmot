# Sequelize ORM

Sequelize는 Node.js 환경에서 사용하는 ORM(Object-Relational Mapping) 라이브러리입니다. ORM은 객체 지향 프로그래밍의 세계(클래스, 객체)와 관계형 데이터베이스의 세계(테이블, 행/열)를 매끄럽게 연결해 주는 기술입니다. SQL을 직접 작성하지 않고도 자바스크립트 코드로 데이터베이스 작업을 수행할 수 있게 해줍니다.

- 모델 정의, 마이그레이션, 관계 설정, 트랜잭션, 검증, 훅(hook) 등 실무에서 필요한 기능이 폭넓게 제공됩니다.

## 2) 핵심 개념 한눈에 보기

- 모델(Model): 데이터베이스의 테이블을 표현하는 자바스크립트 클래스입니다. 컬럼(필드), 자료형, 기본값, 제약조건 등을 선언합니다.
- 인스턴스(Instance): 테이블의 한 행(row)을 표현하는 객체입니다. 생성, 수정, 삭제, 검증 등의 동작을 수행합니다.
- 연관관계(Association): 테이블 간 관계를 표현합니다. 일대일(1:1), 일대다(1:N), 다대다(N:M)를 지원합니다.
- 마이그레이션(Migration): 데이터베이스 스키마(테이블/컬럼/인덱스 등)의 변경 이력을 코드로 관리합니다.
- 시드(Seed): 초기 데이터나 테스트 데이터를 주입하기 위한 스크립트입니다.
- 트랜잭션(Transaction): 여러 데이터 변경을 하나의 단위로 묶어 모두 성공하거나 모두 실패하도록 보장합니다.

## 3) 모델링: 테이블을 코드로 표현하기

모델은 테이블 설계서와 같습니다. 어떤 컬럼이 있고, 자료형은 무엇이며, 필수인지 선택인지, 기본값은 무엇인지, 고유(unique)해야 하는지 등을 선언합니다. 또한 타임스탬프 관리(createdAt, updatedAt), 소프트 삭제(논리 삭제)를 위한 deletedAt 같은 컬럼도 자동으로 관리할 수 있습니다.

간단 예시 (핵심만)

```js
// User 모델 정의: 필수/고유/기본값 예시
const User = sequelize.define(
  "User",
  {
    email: { type: DataTypes.STRING, allowNull: false, unique: true },
    name: { type: DataTypes.STRING, allowNull: false },
    role: { type: DataTypes.ENUM("USER", "ADMIN"), defaultValue: "USER" },
  },
  {
    timestamps: true, // createdAt, updatedAt 자동
    paranoid: true, // deletedAt으로 소프트 삭제
  }
);
```

## 4) 연관관계: 데이터 간 연결 그리기

관계형 데이터베이스의 강점은 테이블 간 관계입니다. Sequelize는 다음을 지원합니다.

- 1:1(One-To-One): 예) 사용자-프로필. 한 사용자에 하나의 프로필만 연결.
- 1:N(One-To-Many): 예) 사용자-게시글. 한 사용자는 여러 게시글을 가질 수 있음.
- N:M(Many-To-Many): 예) 게시글-태그. 중간 조인 테이블을 통해 다대다를 구현.

연관관계를 정의하면, 관련 데이터를 함께 가져오기(조인)나, 연결/해제 같은 작업을 간편하게 처리할 수 있습니다. 단, 무분별한 즉시 로딩은 성능 이슈(N+1 문제)를 유발할 수 있으므로 주의가 필요합니다.

간단 예시 (핵심만)

```js
// 1:N: User hasMany Post, Post belongsTo User
User.hasMany(Post, { foreignKey: "userId" });
Post.belongsTo(User, { foreignKey: "userId" });

// N:M: Post belongsToMany Tag through PostTag
Post.belongsToMany(Tag, { through: "PostTag", foreignKey: "postId" });
Tag.belongsToMany(Post, { through: "PostTag", foreignKey: "tagId" });
```

## 5) 쿼리: 데이터를 찾고, 만들고, 바꾸고, 지우기

Sequelize는 CRUD를 읽기 쉬운 메서드 세트로 제공합니다.
쿼리 빌더 스타일로 옵션을 조합하여 작성하기 때문에, 코드를 통해 의도를 드러내고 재사용성을 높일 수 있습니다.

삭제에는 두 가지 방식이 있습니다.

- 소프트 삭제(논리 삭제): 레코드를 실제로 지우지 않고 `deletedAt`에 시간이 기록되어 비활성화 처리됩니다. 모델 옵션에서 `paranoid: true`가 필요합니다. 기본 조회에서는 제외되며, `paranoid: false` 옵션으로 포함할 수 있고 `restore()`로 복구 가능합니다.
- 하드 삭제(물리 삭제): 데이터가 실제로 제거됩니다. 모델이 `paranoid: true`여도 `force: true` 옵션을 주면 강제 삭제됩니다.

간단 예시 (핵심만)

```js
// 조건 조회 + 정렬 + 페이징 + 부분 컬럼
const page = 1,
  pageSize = 10;
const items = await Post.findAll({
  order: [["createdAt", "DESC"]],
  limit: pageSize,
  offset: (page - 1) * pageSize,
  attributes: ["id", "title", "createdAt"],
});

// 생성과 검증
const user = await User.create({ email: "a@b.com", name: "A" });

// 부분 업데이트
await Post.update({ title: "새 제목" }, { where: { id: 1 } });

// 소프트 삭제 (paranoid)
await Post.destroy({ where: { id: 1 } });

// 하드 삭제 (실제 데이터 제거)
await Post.destroy({ where: { id: 2 }, force: true });

// 소프트 삭제된 행까지 포함해서 조회
const allIncludingDeleted = await Post.findAll({ paranoid: false });

// 소프트 삭제 레코드 복구
const deleted = await Post.findOne({ where: { id: 1 }, paranoid: false });
await deleted.restore();
```

## 6) 마이그레이션과 시드: 스키마와 데이터의 이력 관리

마이그레이션(Migration)은 DB 스키마를 코드로 정의하고, 이를 실행함으로써 실제 데이터베이스 구조를 변경하는 작업입니다. 날짜별 변경 이력을 남기고, 롤백도 가능하며 협업과 배포에 유리합니다.

생성: npx sequelize-cli migration:generate --name create-users
--마이그레이션 작성 후--
반영: npx sequelize-cli db:migrate
롤백: npx sequelize-cli db:migrate:undo

## 7) 트랜잭션: 일관성 유지의 핵심

트랜잭션은 여러 DB 작업을 하나의 단위로 묶어, 일부만 반영되는 불일치 상태를 방지합니다. 예를 들어 결제-재고-주문 생성이 함께 성공하거나, 함께 실패하도록 만들 수 있습니다.

간단 예시 (핵심만)

```js
// 결제/주문/재고를 하나의 트랜잭션으로 처리
await sequelize.transaction(async (t) => {
  await Payment.create({ orderId, amount }, { transaction: t });
  await Order.create({ userId, status: "PAID" }, { transaction: t });
  await Inventory.decrement("stock", { by: 1, where: { sku }, transaction: t });
}); // 내부에서 에러 발생 시 자동 롤백
```
