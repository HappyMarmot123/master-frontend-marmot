# 트랜잭션 (Transaction)

데이터베이스에서 '트랜잭션(Transaction)'은 데이터베이스의 상태를 변경시키는 하나 이상의 논리적인 작업 단위입니다. 예를 들어, 은행 계좌 이체는 'A 계좌에서 돈을 인출'하고 'B 계좌에 돈을 입금'하는 두 가지 작업을 포함하는데, 이 두 작업은 모두 성공하거나 모두 실패해야만 데이터의 무결성이 보장됩니다. 트랜잭션은 이처럼 여러 작업을 묶어 하나의 단위로 처리함으로써 데이터 일관성과 무결성을 지키는 중요한 메커니즘입니다.

## 1. 트랜잭션의 특징 (ACID 속성)

성공적인 트랜잭션은 다음 네 가지 속성(ACID)을 만족해야 합니다.

### 1.1. 원자성 (Atomicity)

- **개념:** 트랜잭션을 구성하는 모든 연산은 완전히 실행되거나, 아니면 전혀 실행되지 않아야 합니다. 'All or Nothing' 원칙을 따릅니다. 중간에 오류가 발생하면 이전에 수행했던 모든 작업을 취소(Rollback)하고 트랜잭션 이전 상태로 되돌립니다.
- **예시:** 계좌 이체 시, 인출과 입금 중 하나라도 실패하면 전체 이체는 취소되어야 합니다.

### 1.2. 일관성 (Consistency)

- **개념:** 트랜잭션이 성공적으로 완료되면, 데이터베이스는 언제나 일관된 상태를 유지해야 합니다. 트랜잭션 실행 전과 후의 데이터베이스 제약 조건(예: 외래 키 제약, 무결성 제약)은 항상 유효해야 합니다.
- **예시:** 계좌 이체 후, 두 계좌의 총 잔액은 변경 전과 같아야 합니다.

### 1.3. 격리성 (Isolation)

- **개념:** 동시에 실행되는 여러 트랜잭션은 서로에게 영향을 미치지 않고 독립적으로 실행되어야 합니다. 각 트랜잭션은 마치 혼자 실행되는 것처럼 동작해야 합니다. 이는 여러 사용자가 동시에 데이터를 수정하더라도 데이터의 정확성이 유지되도록 합니다.
- **예시:** 여러 사람이 동시에 같은 계좌의 잔액을 조회하거나 변경하려 할 때, 각 트랜잭션은 서로의 작업에 의해 영향을 받지 않아야 합니다.

### 1.4. 지속성 (Durability)

- **개념:** 트랜잭션이 성공적으로 완료(Commit)되면, 해당 변경 내용은 시스템 오류(예: 시스템 다운, 전원 손실)가 발생하더라도 영구적으로 데이터베이스에 반영되어야 합니다. `COMMIT`된 내용은 기록되어 손실되지 않습니다.
- **예시:** 계좌 이체가 완료되어 `COMMIT`되면, 시스템에 문제가 생겨도 변경된 잔액은 유지되어야 합니다.

## 2. 트랜잭션의 상태

트랜잭션은 다음과 같은 상태 변화를 가집니다.

1.  **활동 (Active):** 트랜잭션이 실행 중인 초기 상태.
2.  **부분 완료 (Partially Committed):** 마지막 연산까지 실행되었으나, 아직 `COMMIT`되지 않은 상태.
3.  **실패 (Failed):** 정상적인 실행을 더 이상 계속할 수 없는 상태 (오류 발생).
4.  **철회 (Aborted):** 트랜잭션이 실패하여 `Rollback`된 상태. 데이터베이스는 트랜잭션 시작 전 상태로 되돌아갑니다.
5.  **완료 (Committed):** 트랜잭션이 성공적으로 실행되어 `Commit`된 상태. 모든 변경 사항이 데이터베이스에 영구적으로 반영됩니다.

## 3. `COMMIT`과 `ROLLBACK`

- **COMMIT:** 트랜잭션을 성공적으로 완료하고, 모든 변경 사항을 데이터베이스에 영구적으로 저장하는 명령어입니다.
- **ROLLBACK:** 트랜잭션 실행 중 오류가 발생하거나 사용자가 취소할 경우, 트랜잭션 시작 이전의 상태로 데이터베이스를 되돌리는 명령어입니다.

## 4. 예제 (SQL)

다음은 SQL에서 트랜잭션을 사용하여 계좌 이체 작업을 처리하는 간단한 예시입니다.

```sql
-- Account 테이블 생성 (간단한 예시를 위해)
CREATE TABLE Accounts (
    account_id INT PRIMARY KEY,
    balance DECIMAL(10, 2) NOT NULL
);

-- 초기 데이터 삽입
INSERT INTO Accounts (account_id, balance) VALUES
(1, 1000.00), -- 김철수 계좌
(2, 500.00);  -- 박영희 계좌

-- 트랜잭션 시작
START TRANSACTION;

-- 1. 김철수 계좌에서 200원 인출
UPDATE Accounts
SET balance = balance - 200.00
WHERE account_id = 1;

-- 2. 박영희 계좌에 200원 입금
UPDATE Accounts
SET balance = balance + 200.00
WHERE account_id = 2;

-- 모든 작업이 성공했다고 가정하고 트랜잭션 커밋
COMMIT;

-- 결과 확인:
-- SELECT * FROM Accounts;
-- account_id | balance
-- -----------|---------
-- 1          | 800.00
-- 2          | 700.00


-- 실패하는 트랜잭션 예시 (ROLLBACK)
START TRANSACTION;

-- 1. 김철수 계좌에서 300원 인출
UPDATE Accounts
SET balance = balance - 300.00
WHERE account_id = 1;

-- 의도적인 오류 발생 (예: 존재하지 않는 계좌에 입금 시도 또는 잔액 부족 등 가정)
-- 이 예시에서는 설명을 위해 논리적으로 오류가 발생했다고 가정합니다.
-- 실제로는 에러 처리 로직이 필요합니다.

-- 오류가 발생하여 트랜잭션 철회
ROLLBACK;

-- 결과 확인 (김철수 계좌 잔액은 변경 전인 800원으로 유지됩니다):
-- SELECT * FROM Accounts;
-- account_id | balance
-- -----------|---------
-- 1          | 800.00
-- 2          | 700.00
```

**코드 설명:**

1.  `START TRANSACTION;` 또는 `BEGIN;`으로 트랜잭션을 시작합니다.
2.  첫 번째 `UPDATE` 문은 `account_id` 1번 계좌에서 잔액을 200원 감소시킵니다.
3.  두 번째 `UPDATE` 문은 `account_id` 2번 계좌에 잔액을 200원 증가시킵니다.
4.  모든 작업이 성공적으로 완료되면 `COMMIT;`을 실행하여 변경 사항을 데이터베이스에 영구적으로 반영합니다.
5.  두 번째 예시에서는 `ROLLBACK;`을 통해 트랜잭션이 시작되기 전 상태로 되돌아가, 김철수 계좌의 잔액이 변경되지 않고 800원으로 유지됨을 보여줍니다.
