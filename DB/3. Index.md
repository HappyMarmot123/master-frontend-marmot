# 인덱스 (Index)

데이터베이스에서 '인덱스(Index)'는 테이블의 특정 컬럼(들)에 대해 생성되는 특별한 구조로, 데이터를 더 빠르게 검색하고 정렬할 수 있도록 돕는 역할을 합니다. 책의 색인(찾아보기)과 유사하게, 원하는 데이터를 찾기 위해 전체 테이블을 처음부터 끝까지 스캔하는 대신, 인덱스를 통해 효율적으로 데이터를 찾을 수 있습니다.

## 1. 인덱스의 필요성

- **빠른 데이터 검색:** `WHERE` 절이나 `JOIN` 조건에서 자주 사용되는 컬럼에 인덱스를 생성하면 쿼리 성능이 크게 향상됩니다.
- **빠른 데이터 정렬:** `ORDER BY` 절에서 사용되는 컬럼에 인덱스가 있으면 정렬 작업의 부하를 줄일 수 있습니다.
- **데이터 무결성 유지:** `PRIMARY KEY`나 `UNIQUE` 제약조건을 설정하면 데이터베이스 시스템이 자동으로 인덱스를 생성하여 데이터의 유일성을 보장합니다.

## 2. 인덱스의 동작 방식 (B-Tree)

대부분의 관계형 데이터베이스에서 인덱스는 주로 B-Tree (B-트리) 구조로 구현됩니다. B-Tree는 균형 트리(Balanced Tree)의 일종으로, 어떤 노드에서든 리프 노드까지의 거리가 항상 같도록 유지됩니다. 이로 인해 모든 데이터에 대한 접근 시간이 일정하게 유지되어 탐색 성능이 좋습니다.

- **루트 노드 (Root Node):** 트리의 가장 상단에 있는 노드입니다.
- **브랜치 노드 (Branch Node):** 중간 단계의 노드로, 다음 하위 노드(자식 노드)에 대한 포인터와 키 값을 포함합니다.
- **리프 노드 (Leaf Node):** 트리의 가장 하단에 있는 노드로, 실제 데이터가 저장된 위치(ROWID)를 가리키거나, 경우에 따라 실제 데이터 자체를 포함합니다.

**데이터 검색 과정:**

1.  루트 노드에서 시작하여 원하는 키 값을 찾을 때까지 자식 노드로 이동합니다.
2.  각 노드에서는 자신의 키 값들과 검색할 키 값을 비교하여 다음으로 이동할 브랜치를 결정합니다.
3.  최종적으로 리프 노드에 도달하면, 해당 리프 노드의 정보(예: ROWID)를 사용하여 실제 테이블에서 데이터를 찾아 가져옵니다.

## 3. 인덱스의 종류

### 3.1. 클러스터형 인덱스 (Clustered Index)

- **개념:** 테이블의 물리적인 저장 순서와 인덱스의 논리적인 순서가 일치하도록 정렬하는 인덱스입니다. 테이블당 하나만 생성할 수 있습니다.
- **특징:**
  - 테이블 자체가 인덱스로 정렬되므로, 인덱스에 따라 물리적인 데이터 정렬이 이루어집니다.
  - 기본 키(Primary Key)를 설정하면 대부분의 데이터베이스에서 자동으로 클러스터형 인덱스가 생성됩니다.
  - 데이터 읽기 성능이 매우 빠릅니다 (특히 범위 검색).
- **단점:** 삽입, 삭제, 갱신 시 물리적인 데이터 재정렬이 발생할 수 있어 성능 저하가 일어날 수 있습니다.

### 3.2. 비클러스터형 인덱스 (Non-Clustered Index)

- **개념:** 인덱스와 테이블의 물리적인 저장 순서가 독립적입니다. 테이블당 여러 개를 생성할 수 있습니다.
- **특징:**
  - 인덱스만 정렬되어 있고, 실제 데이터는 별도의 공간에 원래 순서대로 저장됩니다.
  - 인덱스 리프 노드는 실제 데이터 레코드의 물리적인 주소(ROWID)를 가리킵니다.
  - 기본 키가 아닌 컬럼에 `UNIQUE` 또는 `INDEX` 제약조건을 설정하면 자동으로 비클러스터형 인덱스가 생성됩니다.
- **단점:** 데이터를 찾기 위해 인덱스를 먼저 탐색한 후, 인덱스가 가리키는 실제 데이터 블록으로 다시 이동해야 하므로 클러스터형 인덱스보다 검색이 한 단계 더 필요합니다.

## 4. 인덱스 생성 시 고려사항

인덱스는 항상 좋은 것만은 아닙니다. 다음과 같은 점들을 고려해야 합니다.

- **성능 저하:** 데이터의 삽입(INSERT), 삭제(DELETE), 갱신(UPDATE) 작업 시 인덱스도 함께 갱신되어야 하므로 이들 작업의 성능이 저하될 수 있습니다.
- **추가 공간:** 인덱스를 저장하기 위한 추가적인 디스크 공간이 필요합니다.
- **선택적 활용:** `SELECT` 문에서 `WHERE` 절, `JOIN` 절, `ORDER BY` 절 등에 자주 사용되는 컬럼에만 인덱스를 생성하는 것이 좋습니다.
- **카디널리티 (Cardinality):** 컬럼의 값 종류가 다양할수록(카디널리티가 높을수록) 인덱스의 효율성이 높아집니다. (예: 성별 같은 카디널리티가 낮은 컬럼은 인덱스 효율이 낮을 수 있습니다.)

## 5. 예제 (SQL)

다음은 SQL에서 인덱스를 생성하는 간단한 예시입니다.

```sql
-- Students 테이블 생성 (이전 예시와 동일)
CREATE TABLE Students (
    student_id INT PRIMARY KEY, -- PRIMARY KEY는 자동으로 클러스터형 인덱스 생성 (MySQL의 InnoDB 기준)
    student_name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE, -- UNIQUE 제약조건은 자동으로 비클러스터형 인덱스 생성
    age INT
);

-- student_name 컬럼에 비클러스터형 인덱스 생성
CREATE INDEX idx_student_name ON Students (student_name);

-- age 컬럼에 비클러스터형 인덱스 생성
CREATE INDEX idx_student_age ON Students (age);

-- 인덱스를 활용하는 쿼리 예시
-- WHERE 절에서 인덱스 사용
SELECT * FROM Students WHERE student_name = '김철수';

-- ORDER BY 절에서 인덱스 사용
SELECT * FROM Students ORDER BY age DESC;

-- JOIN 조건에서 인덱스 사용 (Enrollments 테이블이 Students.student_id를 FK로 가질 때)
-- 이전 예시의 Enrollments 테이블과 유사하게 구성되어 있다고 가정
-- SELECT S.student_name, E.enrollment_date
-- FROM Students S
-- JOIN Enrollments E ON S.student_id = E.student_id
-- WHERE S.student_id = 1;

-- 인덱스 제거 예시
-- DROP INDEX idx_student_name ON Students;
```

**코드 설명:**

- `student_id INT PRIMARY KEY`: `PRIMARY KEY`는 테이블의 물리적 저장 순서를 결정하는 클러스터형 인덱스를 생성합니다 (MySQL의 InnoDB 엔진 기준).
- `email VARCHAR(100) UNIQUE`: `UNIQUE` 제약조건은 `email` 컬럼의 고유성을 보장하기 위해 비클러스터형 인덱스를 자동으로 생성합니다.
- `CREATE INDEX idx_student_name ON Students (student_name);`: `student_name` 컬럼에 `idx_student_name`이라는 이름의 비클러스터형 인덱스를 명시적으로 생성합니다.
- `SELECT * FROM Students WHERE student_name = '김철수';`: 이 쿼리는 `student_name` 컬럼에 생성된 인덱스를 활용하여 빠르게 데이터를 검색할 수 있습니다.
- `SELECT * FROM Students ORDER BY age DESC;`: `age` 컬럼에 인덱스가 있으면 정렬 작업의 효율성이 높아집니다.
