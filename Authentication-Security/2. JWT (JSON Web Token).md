# JWT (JSON Web Token)

## ğŸ“– ê°œìš”

**JWT (JSON Web Token)**ëŠ” ë‹¹ì‚¬ì ê°„ì— ì •ë³´ë¥¼ JSON ê°ì²´ë¡œ ì•ˆì „í•˜ê²Œ ì „ì†¡í•˜ê¸° ìœ„í•œ ì»´íŒ©íŠ¸í•˜ê³  ë…ë¦½ì ì¸ ë°©ë²•ì„ ì •ì˜í•œ ê°œë°©í˜• í‘œì¤€(RFC 7519)ì…ë‹ˆë‹¤. JWTëŠ” ì¸ì¦, ì •ë³´ êµí™˜, ì„¸ì…˜ ê´€ë¦¬ ë“± ë‹¤ì–‘í•œ ìš©ë„ë¡œ ì‚¬ìš©ë˜ë©°, íŠ¹íˆ RESTful APIì—ì„œ í† í° ê¸°ë°˜ ì¸ì¦ì˜ í‘œì¤€ìœ¼ë¡œ ìë¦¬ì¡ê³  ìˆìŠµë‹ˆë‹¤.

**JWTê°€ í˜„ëŒ€ ì›¹ ê°œë°œì—ì„œ ì¤‘ìš”í•œ ì´ìœ :**

- **ë¬´ìƒíƒœì„±**: ì„œë²„ê°€ ì‚¬ìš©ì ì„¸ì…˜ì„ ì €ì¥í•  í•„ìš”ê°€ ì—†ì–´ í™•ì¥ì„±ì´ ë›°ì–´ë‚©ë‹ˆë‹¤
- **í‘œì¤€í™”**: RFC 7519ë¡œ í‘œì¤€í™”ë˜ì–´ ë‹¤ì–‘í•œ ì–¸ì–´ì™€ í”Œë«í¼ì—ì„œ ì§€ì›ë©ë‹ˆë‹¤
- **íš¨ìœ¨ì„±**: HTTP í—¤ë”ë‚˜ URL íŒŒë¼ë¯¸í„°ë¡œ ì‰½ê²Œ ì „ì†¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- **ìì²´ í¬í•¨**: í•„ìš”í•œ ëª¨ë“  ì •ë³´ê°€ í† í° ë‚´ë¶€ì— í¬í•¨ë˜ì–´ ìˆì–´ ë³„ë„ ì¡°íšŒê°€ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤

## ğŸ—ï¸ JWT êµ¬ì¡°

JWTëŠ” ì„¸ ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±ë˜ë©°, ê° ë¶€ë¶„ì€ ì (.)ìœ¼ë¡œ êµ¬ë¶„ë©ë‹ˆë‹¤:

```
Header.Payload.Signature
```

### 1. **Header (í—¤ë”)**

í† í°ì˜ íƒ€ì…ê³¼ ì‚¬ìš©ëœ ì„œëª… ì•Œê³ ë¦¬ì¦˜ì„ ì •ì˜í•©ë‹ˆë‹¤.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**ì£¼ìš” í•„ë“œ:**

- **alg**: ì„œëª… ì•Œê³ ë¦¬ì¦˜ (HS256, RS256, ES256 ë“±)
- **typ**: í† í° íƒ€ì… (í•­ìƒ "JWT")
- **kid**: í‚¤ ID (ì—¬ëŸ¬ í‚¤ë¥¼ ì‚¬ìš©í•  ë•Œ)

### 2. **Payload (í˜ì´ë¡œë“œ)**

ì‹¤ì œ ë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ë¶€ë¶„ìœ¼ë¡œ, í´ë ˆì„(claim)ì´ë¼ê³  ë¶ˆë¦½ë‹ˆë‹¤.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622
}
```

**í‘œì¤€ í´ë ˆì„ (Registered Claims):**

- **sub**: ì£¼ì²´ (Subject) - í† í°ì˜ ì£¼ì¸
- **iss**: ë°œê¸‰ì (Issuer) - í† í°ì„ ë°œê¸‰í•œ ì£¼ì²´
- **aud**: ëŒ€ìƒ (Audience) - í† í°ì˜ ìˆ˜ì‹ ì
- **exp**: ë§Œë£Œ ì‹œê°„ (Expiration Time) - í† í°ì˜ ë§Œë£Œ ì‹œì 
- **nbf**: ì‹œì‘ ì‹œê°„ (Not Before) - í† í°ì´ ìœ íš¨í•´ì§€ëŠ” ì‹œì 
- **iat**: ë°œê¸‰ ì‹œê°„ (Issued At) - í† í°ì´ ë°œê¸‰ëœ ì‹œì 
- **jti**: JWT ID - í† í°ì˜ ê³ ìœ  ì‹ë³„ì

**ì‚¬ìš©ì ì •ì˜ í´ë ˆì„ (Custom Claims):**

```json
{
  "sub": "1234567890",
  "role": "admin",
  "permissions": ["read", "write", "delete"],
  "department": "engineering"
}
```

### 3. **Signature (ì„œëª…)**

í—¤ë”ì™€ í˜ì´ë¡œë“œì˜ ë¬´ê²°ì„±ì„ ë³´ì¥í•˜ëŠ” ì„œëª…ì…ë‹ˆë‹¤.

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

## ğŸ” JWT ì„œëª… ì•Œê³ ë¦¬ì¦˜

### 1. **HMAC (ëŒ€ì¹­í‚¤ ì•”í˜¸í™”)**

- **HS256**: HMAC SHA-256
- **HS384**: HMAC SHA-384
- **HS512**: HMAC SHA-512

**íŠ¹ì§•:**

- ë™ì¼í•œ ë¹„ë°€í‚¤ë¡œ ì„œëª… ìƒì„± ë° ê²€ì¦
- ë¹ ë¥¸ ì²˜ë¦¬ ì†ë„
- í‚¤ ê´€ë¦¬ì˜ ë³µì¡ì„±

**ì‚¬ìš© ì˜ˆì‹œ:**

```javascript
const jwt = require("jsonwebtoken");

// í† í° ìƒì„±
const token = jwt.sign({ userId: 123, role: "user" }, "your-secret-key", {
  algorithm: "HS256",
  expiresIn: "1h",
});

// í† í° ê²€ì¦
const decoded = jwt.verify(token, "your-secret-key");
```

### 2. **RSA (ë¹„ëŒ€ì¹­í‚¤ ì•”í˜¸í™”)**

- **RS256**: RSA SHA-256
- **RS384**: RSA SHA-384
- **RS512**: RSA SHA-512

**íŠ¹ì§•:**

- ê³µê°œí‚¤ë¡œ ê²€ì¦, ê°œì¸í‚¤ë¡œ ì„œëª…
- ë†’ì€ ë³´ì•ˆì„±
- í‚¤ ê´€ë¦¬ì˜ ìš©ì´ì„±

**ì‚¬ìš© ì˜ˆì‹œ:**

```javascript
const jwt = require("jsonwebtoken");
const fs = require("fs");

// ê°œì¸í‚¤ì™€ ê³µê°œí‚¤ ë¡œë“œ
const privateKey = fs.readFileSync("private.key");
const publicKey = fs.readFileSync("public.key");

// í† í° ìƒì„± (ê°œì¸í‚¤ ì‚¬ìš©)
const token = jwt.sign({ userId: 123, role: "user" }, privateKey, {
  algorithm: "RS256",
  expiresIn: "1h",
});

// í† í° ê²€ì¦ (ê³µê°œí‚¤ ì‚¬ìš©)
const decoded = jwt.verify(token, publicKey);
```

## ğŸ’¡ í”„ë¡ íŠ¸ì—”ë“œ í™œìš© ì•„ì´ë””ì–´

### 1. **í† í° ì €ì¥ ë° ê´€ë¦¬**

```javascript
// JWT í† í° ê´€ë¦¬ í´ë˜ìŠ¤
class TokenManager {
  constructor() {
    this.accessToken = null;
  }

  // í† í° ì €ì¥
  setTokens(accessToken, refreshToken) {
    this.accessToken = accessToken;
    this.setHttpOnlyCookie("refresh_token", refreshToken);
  }

  // í† í° ìœ íš¨ì„± ê²€ì‚¬
  isTokenValid(token) {
    if (!token) return false;
    try {
      const decoded = this.decodeToken(token);
      return decoded.exp > Date.now() / 1000;
    } catch (error) {
      return false;
    }
  }

  // HttpOnly ì¿ í‚¤ ì„¤ì •
  setHttpOnlyCookie(name, value) {
    document.cookie = `${name}=${value}; HttpOnly; Secure; SameSite=Strict`;
  }
}
```

### 2. **API ìš”ì²­ ì¸í„°ì…‰í„°**

```javascript
// Axios ì¸í„°ì…‰í„°ë¥¼ ì‚¬ìš©í•œ JWT ìë™ ì²˜ë¦¬
class JWTInterceptor {
  constructor(apiClient, tokenManager) {
    this.apiClient = apiClient;
    this.tokenManager = tokenManager;
    this.setupInterceptors();
  }

  setupInterceptors() {
    // ìš”ì²­ ì¸í„°ì…‰í„°: í† í° ìë™ ì¶”ê°€
    this.apiClient.interceptors.request.use((config) => {
      const token = this.tokenManager.accessToken;
      if (token && this.tokenManager.isTokenValid(token)) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // ì‘ë‹µ ì¸í„°ì…‰í„°: í† í° ë§Œë£Œ ì²˜ë¦¬
    this.apiClient.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          const newToken = await this.refreshToken();
          if (newToken) {
            error.config.headers.Authorization = `Bearer ${newToken}`;
            return this.apiClient.request(error.config);
          }
        }
        return Promise.reject(error);
      }
    );
  }
}
```

### 3. **React Contextë¥¼ ì‚¬ìš©í•œ ì¸ì¦ ìƒíƒœ ê´€ë¦¬**

```javascript
// React Contextë¥¼ ì‚¬ìš©í•œ JWT ì¸ì¦ ìƒíƒœ ê´€ë¦¬
import React, { createContext, useContext, useReducer, useEffect } from "react";

const AuthContext = createContext();

const authReducer = (state, action) => {
  switch (action.type) {
    case "LOGIN":
      return {
        ...state,
        isAuthenticated: true,
        user: action.payload.user,
        accessToken: action.payload.accessToken,
      };
    case "LOGOUT":
      return {
        ...state,
        isAuthenticated: false,
        user: null,
        accessToken: null,
      };
    default:
      return state;
  }
};

export const AuthProvider = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, {
    isAuthenticated: false,
    user: null,
    accessToken: null,
  });

  const login = async (credentials) => {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });

      if (response.ok) {
        const { user, accessToken } = await response.json();
        localStorage.setItem("access_token", accessToken);
        dispatch({ type: "LOGIN", payload: { user, accessToken } });
        return { success: true };
      }
    } catch (error) {
      return { success: false, error: "Network error" };
    }
  };

  return (
    <AuthContext.Provider value={{ ...state, login }}>
      {children}
    </AuthContext.Provider>
  );
};
```

## ğŸ”§ ë°±ì—”ë“œ/ì „ì²´ í™œìš© ì•„ì´ë””ì–´

### 1. **JWT ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„**

```javascript
// Express.js JWT ë¯¸ë“¤ì›¨ì–´
class JWTMiddleware {
  constructor(secretKey) {
    this.secretKey = secretKey;
  }

  // í† í° ê²€ì¦ ë¯¸ë“¤ì›¨ì–´
  verifyToken(req, res, next) {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return res.status(401).json({ error: "Access token required" });
    }

    const token = authHeader.split(" ")[1]; // "Bearer TOKEN"

    if (!token) {
      return res.status(401).json({ error: "Invalid token format" });
    }

    try {
      const decoded = jwt.verify(token, this.secretKey);
      req.user = decoded;
      next();
    } catch (error) {
      if (error.name === "TokenExpiredError") {
        return res.status(401).json({ error: "Token expired" });
      } else if (error.name === "JsonWebTokenError") {
        return res.status(401).json({ error: "Invalid token" });
      }

      return res.status(500).json({ error: "Token verification failed" });
    }
  }

  // ì—­í•  ê¸°ë°˜ ê¶Œí•œ ê²€ì¦
  requireRole(requiredRole) {
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      if (req.user.role !== requiredRole && req.user.role !== "admin") {
        return res.status(403).json({ error: "Insufficient permissions" });
      }

      next();
    };
  }

  // ì»¤ìŠ¤í…€ í´ë ˆì„ ê²€ì¦
  requireClaim(claimName, claimValue) {
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      if (req.user[claimName] !== claimValue) {
        return res.status(403).json({ error: "Required claim not satisfied" });
      }

      next();
    };
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const jwtMiddleware = new JWTMiddleware(process.env.JWT_SECRET);

app.get(
  "/api/admin/users",
  jwtMiddleware.verifyToken,
  jwtMiddleware.requireRole("admin"),
  (req, res) => {
    // ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥í•œ ì‚¬ìš©ì ëª©ë¡ API
  }
);
```

### 2. **í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬**

```javascript
// JWT í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
class TokenBlacklist {
  constructor() {
    this.blacklistedTokens = new Set();
    this.redis = null; // Redis ì—°ê²° (ì„ íƒì‚¬í•­)
  }

  // Redis ì—°ê²° ì„¤ì •
  async connectRedis() {
    try {
      this.redis = await redis.createClient();
      console.log("Redis connected for token blacklist");
    } catch (error) {
      console.warn("Redis not available, using in-memory storage");
    }
  }

  // í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
  async blacklistToken(token, expiresAt) {
    const tokenId = this.extractTokenId(token);

    if (this.redis) {
      // Redisì— ì €ì¥ (TTL ìë™ ì„¤ì •)
      const ttl = Math.floor((expiresAt * 1000 - Date.now()) / 1000);
      await this.redis.setex(`blacklist:${tokenId}`, ttl, "1");
    } else {
      // ë©”ëª¨ë¦¬ì— ì €ì¥
      this.blacklistedTokens.add(tokenId);

      // ë§Œë£Œ ì‹œê°„ì— ìë™ ì œê±°
      setTimeout(() => {
        this.blacklistedTokens.delete(tokenId);
      }, expiresAt * 1000 - Date.now());
    }
  }

  // í† í°ì´ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ”ì§€ í™•ì¸
  async isTokenBlacklisted(token) {
    const tokenId = this.extractTokenId(token);

    if (this.redis) {
      const result = await this.redis.get(`blacklist:${tokenId}`);
      return result === "1";
    } else {
      return this.blacklistedTokens.has(tokenId);
    }
  }

  // í† í° ID ì¶”ì¶œ (jti í´ë ˆì„ ë˜ëŠ” í† í° í•´ì‹œ)
  extractTokenId(token) {
    try {
      const decoded = jwt.decode(token);
      return decoded.jti || this.hashToken(token);
    } catch (error) {
      return this.hashToken(token);
    }
  }

  // í† í° í•´ì‹œ ìƒì„±
  hashToken(token) {
    return crypto.createHash("sha256").update(token).digest("hex");
  }
}

// ë¡œê·¸ì•„ì›ƒ ì‹œ í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
app.post("/api/auth/logout", jwtMiddleware.verifyToken, async (req, res) => {
  try {
    const token = req.headers.authorization.split(" ")[1];
    const decoded = jwt.decode(token);

    // í† í°ì„ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
    await tokenBlacklist.blacklistToken(token, decoded.exp);

    res.json({ message: "Logged out successfully" });
  } catch (error) {
    res.status(500).json({ error: "Logout failed" });
  }
});
```

### 3. **JWT í† í° ê°±ì‹  ì‹œìŠ¤í…œ**

```javascript
// JWT í† í° ê°±ì‹  ì„œë¹„ìŠ¤
class TokenRefreshService {
  constructor(secretKey, refreshSecretKey) {
    this.secretKey = secretKey;
    this.refreshSecretKey = refreshSecretKey;
  }

  // ì•¡ì„¸ìŠ¤ í† í° ìƒì„±
  generateAccessToken(user) {
    return jwt.sign(
      {
        userId: user.id,
        email: user.email,
        role: user.role,
        permissions: user.permissions,
      },
      this.secretKey,
      {
        expiresIn: "15m", // ì§§ì€ ë§Œë£Œ ì‹œê°„
        issuer: "your-app",
        audience: "your-app-users",
      }
    );
  }

  // ë¦¬í”„ë ˆì‹œ í† í° ìƒì„±
  generateRefreshToken(user) {
    return jwt.sign(
      {
        userId: user.id,
        tokenVersion: user.tokenVersion || 0,
      },
      this.refreshSecretKey,
      {
        expiresIn: "7d", // ê¸´ ë§Œë£Œ ì‹œê°„
        issuer: "your-app",
        audience: "your-app-users",
      }
    );
  }

  // í† í° ê°±ì‹ 
  async refreshTokens(refreshToken) {
    try {
      // ë¦¬í”„ë ˆì‹œ í† í° ê²€ì¦
      const decoded = jwt.verify(refreshToken, this.refreshSecretKey);

      // ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
      const user = await this.getUserById(decoded.userId);

      // í† í° ë²„ì „ í™•ì¸ (í† í° ë¬´íš¨í™”ë¥¼ ìœ„í•œ)
      if (user.tokenVersion !== decoded.tokenVersion) {
        throw new Error("Token version mismatch");
      }

      // ìƒˆë¡œìš´ í† í° ìƒì„±
      const newAccessToken = this.generateAccessToken(user);
      const newRefreshToken = this.generateRefreshToken(user);

      return {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
        },
      };
    } catch (error) {
      throw new Error("Invalid refresh token");
    }
  }

  // í† í° ë¬´íš¨í™” (ë³´ì•ˆ ê°•í™”)
  async invalidateUserTokens(userId) {
    try {
      // ì‚¬ìš©ìì˜ í† í° ë²„ì „ ì¦ê°€
      await this.updateUserTokenVersion(userId);

      // ê¸°ì¡´ í† í°ë“¤ì„ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
      // (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •êµí•œ ê´€ë¦¬ í•„ìš”)

      return true;
    } catch (error) {
      throw new Error("Token invalidation failed");
    }
  }
}

// í† í° ê°±ì‹  API
app.post("/api/auth/refresh", async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return res.status(400).json({ error: "Refresh token required" });
    }

    const tokenService = new TokenRefreshService(
      process.env.JWT_SECRET,
      process.env.JWT_REFRESH_SECRET
    );

    const newTokens = await tokenService.refreshTokens(refreshToken);

    res.json(newTokens);
  } catch (error) {
    res.status(401).json({ error: "Token refresh failed" });
  }
});
```

## ğŸ›¡ï¸ JWT ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 1. **í† í° í¬ê¸° ì œí•œ**

JWTëŠ” í—¤ë”ì— í¬í•¨ë˜ë¯€ë¡œ í¬ê¸°ê°€ ì œí•œì ì…ë‹ˆë‹¤.

**ê¶Œì¥ì‚¬í•­:**

- í˜ì´ë¡œë“œì— í•„ìš”í•œ ìµœì†Œí•œì˜ ì •ë³´ë§Œ í¬í•¨
- ë¯¼ê°í•œ ì •ë³´ëŠ” í† í°ì— í¬í•¨í•˜ì§€ ì•ŠìŒ
- ì‚¬ìš©ì ID, ì—­í• , ê¶Œí•œ ë“± í•µì‹¬ ì •ë³´ë§Œ í¬í•¨

### 2. **í† í° ë§Œë£Œ ì‹œê°„ ê´€ë¦¬**

```javascript
// í† í° ë§Œë£Œ ì‹œê°„ ì„¤ì • ê°€ì´ë“œ
const tokenExpiration = {
  accessToken: "15m", // ì§§ì€ ë§Œë£Œ ì‹œê°„ (ë³´ì•ˆ ê°•í™”)
  refreshToken: "7d", // ê¸´ ë§Œë£Œ ì‹œê°„ (ì‚¬ìš©ì í¸ì˜ì„±)
  rememberMe: "30d", // ìë™ ë¡œê·¸ì¸ í† í°
};

// í† í° ë§Œë£Œ ì‹œê°„ì— ë”°ë¥¸ ìë™ ê°±ì‹ 
setInterval(async () => {
  const token = tokenManager.getAccessToken();
  if (token && tokenManager.isTokenExpiringSoon(token)) {
    await tokenManager.refreshToken();
  }
}, 60000); // 1ë¶„ë§ˆë‹¤ ì²´í¬
```

### 3. **HTTPS ì‚¬ìš© í•„ìˆ˜**

JWTëŠ” í‰ë¬¸ìœ¼ë¡œ ì „ì†¡ë˜ë¯€ë¡œ ë°˜ë“œì‹œ HTTPSë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

```javascript
// ë³´ì•ˆ í—¤ë” ì„¤ì •
app.use(
  helmet({
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  })
);

// ì¿ í‚¤ ë³´ì•ˆ ì„¤ì •
app.use(
  session({
    cookie: {
      secure: true, // HTTPSì—ì„œë§Œ ì „ì†¡
      httpOnly: true, // JavaScript ì ‘ê·¼ ë°©ì§€
      sameSite: "strict", // CSRF ê³µê²© ë°©ì§€
    },
  })
);
```

## ğŸ¯ ê²°ë¡ 

JWTëŠ” í˜„ëŒ€ì ì¸ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ í† í° ê¸°ë°˜ ì¸ì¦ì˜ í‘œì¤€ìœ¼ë¡œ ìë¦¬ì¡ê³  ìˆìœ¼ë©°, ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„í•˜ë©´ ì•ˆì „í•˜ê³  í™•ì¥ ê°€ëŠ¥í•œ ì¸ì¦ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì„±ê³µì ì¸ JWT êµ¬í˜„ì„ ìœ„í•œ í•µì‹¬ ìš”ì†Œ:**

1. **ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ**: ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ì„œëª… ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
2. **í† í° ë§Œë£Œ ì‹œê°„ ê´€ë¦¬**: ë³´ì•ˆê³¼ ì‚¬ìš©ì ê²½í—˜ì˜ ê· í˜• ìœ ì§€
3. **ë³´ì•ˆ í—¤ë” ì„¤ì •**: HTTPS, HttpOnly ì¿ í‚¤ ë“± ë³´ì•ˆ ê°•í™”
4. **í† í° ë¬´íš¨í™”**: ë¡œê·¸ì•„ì›ƒ ì‹œ í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
5. **ì •ê¸°ì  ë³´ì•ˆ ê²€í† **: ì•Œë ¤ì§„ ì·¨ì•½ì ì— ëŒ€í•œ ì§€ì†ì  ëª¨ë‹ˆí„°ë§

JWTëŠ” ê°•ë ¥í•œ ë„êµ¬ì´ì§€ë§Œ, ë³´ì•ˆì„ ê³ ë ¤í•œ ì‹ ì¤‘í•œ êµ¬í˜„ì´ í•„ìš”í•©ë‹ˆë‹¤. ê°œë°œìëŠ” JWTì˜ íŠ¹ì„±ì„ ì´í•´í•˜ê³ , ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ì ì ˆí•œ êµ¬í˜„ì„ í†µí•´ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ ì¸ì¦ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•´ì•¼ í•©ë‹ˆë‹¤.
