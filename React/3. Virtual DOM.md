## 가상 DOM

가상 DOM(Virtual DOM)은 실제 DOM(Document Object Model)의 추상화된 경량 복사본으로, React가 UI를 효율적으로 업데이트하기 위해 사용하는 개념입니다. 실제 DOM은 브라우저에서 웹 페이지의 구조를 나타내는 객체 모델이며, DOM을 직접 조작하는 것은 비용이 많이 드는 작업입니다.

### 2. 가상 DOM이 필요한 이유 (등장 배경)

웹 애플리케이션의 규모가 커지고 복잡해지면서, UI 업데이트가 빈번하게 발생하게 됩니다. 이때 실제 DOM을 직접 조작하게 되면 다음과 같은 문제점이 발생합니다.

- **성능 저하**: 실제 DOM 조작은 브라우저의 렌더링 엔진에 많은 부하를 주어 성능 저하를 일으킬 수 있습니다. 특히 잦은 DOM 변경은 리플로우(Reflow)와 리페인트(Repaint)를 발생시켜 사용자 경험을 저해합니다.
- **복잡성**: 실제 DOM을 직접 관리하는 것은 코드의 복잡성을 증가시키고, 개발자가 UI 상태를 예측하기 어렵게 만듭니다.

---

React는 이러한 문제점을 해결하기 위해 가상 DOM을 도입했습니다. 가상 DOM은 메모리에 존재하며, 실제 DOM 조작을 최소화하여 애플리케이션 성능을 향상시키고 개발의 편의성을 높입니다.

### 가상 DOM의 작동 방식 (재조정 과정)

가상 DOM은 '재조정(Reconciliation)'이라는 과정을 통해 작동합니다. 이 과정은 크게 세 단계로 나눌 수 있습니다.

1.  **새로운 가상 DOM 생성**: React 컴포넌트의 상태(state)가 변경되거나 프롭스(props)가 업데이트되면, React는 새로운 요소 트리를 생성합니다. 이 새로운 요소 트리가 바로 새로운 가상 DOM입니다.

2.  **이전 가상 DOM과 비교 (Diffing)**: React는 새로 생성된 가상 DOM과 이전의 가상 DOM을 비교하여 어떤 부분이 변경되었는지 식별합니다. 이 비교 과정을 'Diffing Algorithm'이라고 부릅니다. React는 최소한의 변경 사항만을 찾아내기 위해 효율적인 휴리스틱(Heuristic) 알고리즘을 사용합니다. 예를 들어, 다른 타입의 엘리먼트가 발견되면 이전 트리를 완전히 버리고 새로 빌드합니다. 리스트의 자식 엘리먼트를 비교할 때는 `key` 프롭스를 통해 효율적으로 비교합니다.

3.  **실제 DOM 업데이트**: 이전 가상 DOM과 새로운 가상 DOM의 비교를 통해 변경된 부분(diff)이 발견되면, React는 이 변경 사항만을 실제 DOM에 적용합니다. 이 과정은 브라우저의 렌더링 성능을 최적화하기 위해 배치(batch)로 이루어집니다. 즉, 여러 변경 사항을 한 번에 묶어서 실제 DOM에 반영하여 리플로우와 리페인트는 최소화합니다.

### 사용자가 리액트 파일을 요청하면 일어나는 프로세스

사용자가 웹 브라우저에서 React 애플리케이션의 URL을 입력하여 요청했을 때부터 화면에 UI가 렌더링되기까지의 과정은 다음과 같습니다. 이 프로세스는 클라이언트 측 렌더링(CSR)을 기준으로 설명하며, 서버 사이드 렌더링(SSR)의 경우 일부 단계가 달라질 수 있습니다.

1.  **초기 요청 (Initial Request)**

    - 사용자가 브라우저 주소창에 URL을 입력하거나 링크를 클릭하여 웹 서버에 React 애플리케이션을 요청합니다.

2.  **서버 응답 (Server Response)**

    - 웹 서버는 요청을 받아 React 애플리케이션의 엔트리 포인트인 `index.html` 파일을 응답으로 보냅니다.
    - 이 `index.html` 파일은 일반적으로 비어있는 `<div>` 요소와 번들된 JavaScript 파일을 로드하는 `<script>` 태그를 포함합니다.

3.  **브라우저 파싱 및 리소스 로드 (Browser Parsing & Resource Loading)**

    - 브라우저는 서버로부터 받은 `index.html` 파일을 파싱하기 시작합니다.
    - HTML을 파싱하면서 `<link>` 태그로 연결된 CSS 파일이나 `<script>` 태그로 연결된 JavaScript 파일을 발견하면, 해당 리소스들을 서버에 요청하고 다운로드합니다. 이 과정에서 브라우저는 DOM 트리를 구축합니다.

4.  **JavaScript 실행 (JavaScript Execution)**

    - 다운로드된 JavaScript 파일이 브라우저의 JavaScript 엔진에 의해 실행됩니다.
    - 이 시점에서 React는 아직 실제 DOM에 아무것도 렌더링하지 않습니다.

5.  **React 애플리케이션 초기화 (React Application Initialization)**

    - 애플리케이션의 엔트리 파일에서 `render()` 함수가 호출됩니다.
    - 이 함수는 React 컴포넌트 트리와 렌더링될 실제 DOM 요소를 인자로 받습니다.
    - React는 이 컴포넌트 트리를 기반으로 첫 번째 **가상 DOM** 트리를 메모리에 생성합니다.

6.  **초기 렌더링 (Initial Rendering)**

    - React는 메모리에 생성된 첫 번째 가상 DOM 트리를 실제 브라우저의 DOM에 반영합니다. 이 과정에서 실제 DOM 노드가 생성되고 브라우저에 의해 화면에 그려집니다.

7.  **이벤트 처리 및 상태 변화 (Event Handling & State Changes)**

    - 사용자가 웹 페이지와 상호작용합니다(버튼 클릭, 텍스트 입력 등).
    - React는 이벤트를 감지하고 해당 컴포넌트의 이벤트 핸들러를 실행합니다.
    - 이벤트 핸들러 내에서 `setState`나 `useState`와 같은 함수를 통해 컴포넌트의 상태(state)가 변경됩니다.

8.  **재조정 (Reconciliation) 및 업데이트 (Update)**

    - 컴포넌트의 상태나 프롭스(props)가 변경되면, React는 해당 컴포넌트를 다시 렌더링(re-render)하고 새로운 **가상 DOM** 트리를 생성합니다.
    - React는 이 새로운 가상 DOM 트리를 이전 가상 DOM 트리와 비교합니다 (Diffing Algorithm). 이 과정에서 변경된 부분(diff)만을 효율적으로 찾아냅니다.
    - 찾아낸 최소한의 변경 사항(diff)만을 모아서 실제 DOM에 한 번에 적용합니다 (Batch Update). 이는 실제 DOM 조작 횟수를 최소화하여 브라우저의 렌더링 성능을 최적화합니다.

9.  **브라우저 렌더링 (Browser Rendering)**
    - React에 의해 실제 DOM이 업데이트되면, 브라우저는 변경된 부분에 대해 다시 레이아웃을 계산하고(Reflow), 픽셀을 다시 그리는(Repaint) 과정을 거쳐 사용자에게 최신 UI를 보여줍니다.

이러한 과정을 통해 React는 선언적인 방식으로 UI를 관리하면서도 효율적인 업데이트를 제공하여 사용자 경험을 향상시킵니다.
