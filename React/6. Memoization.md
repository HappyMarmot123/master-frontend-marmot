## 메모이제이션 (Memoization)

### 메모이제이션의 원리

메모이제이션은 컴퓨터 프로그램 최적화 기법 중 하나로, 동일한 계산을 반복해야 할 때 이전에 계산한 값을 메모리에 저장(캐싱)해 두었다가 필요할 때 다시 계산하지 않고 저장된 값을 재사용하는 방식입니다.

즉, 메모이제이션은 "기억하기"라는 의미처럼, 컴포넌트가 특정 조건을 만족할 때 이전 렌더링 결과를 "기억"하고 있다가 재사용함으로써 불필요한 작업을 최소화하는 전략입니다.

---

### 컴포넌트 렌더링 사이클과 성능 문제

React에서 컴포넌트의 렌더링은 부모-자식 관계를 따라 워터폴이 발생합니다. 즉, 부모 컴포넌트가 재렌더링되면, 기본적으로 모든 하위(자식) 컴포넌트도 함께 재렌더링을 시도합니다. 이는 하위 컴포넌트의 `props`나 `state`가 실제로 변경되지 않았더라도 마찬가지입니다.

**렌더링 사이클의 작동 방식:**

1.  **상태(State) 또는 프롭스(Props) 변경**: 어떤 컴포넌트의 내부 `state`가 변경되거나, 부모로부터 전달받는 `props`가 변경되면 해당 컴포넌트는 재렌더링 대상이 됩니다.
2.  **재렌더링 전파**: React는 재렌더링 대상이 된 컴포넌트부터 시작하여 그 아래에 있는 모든 자식 컴포넌트들을 재렌더링합니다. 이때 React는 새로운 가상 DOM 트리를 생성하고 이전 가상 DOM 트리와 비교하는 재조정(Reconciliation) 과정을 거칩니다.

**성능 저하의 원인:**

문제는 하위 컴포넌트의 실제 `props`나 `state`가 변경되지 않았음에도 불구하고 불필요하게 재렌더링 과정(가상 DOM 생성 및 비교)을 거치게 된다는 점입니다.

컴포넌트 트리의 깊이가 깊고, 자식 컴포넌트의 수가 많으며, 각 컴포넌트의 렌더링 비용이 높을수록 이러한 불필요한 재렌더링은 애플리케이션의 성능 저하로 이어집니다.

이러한 불필요한 렌더링을 방지하고 애플리케이션의 성능을 최적화하기 위해 메모이제이션 기법이 사용됩니다.

---

### 메모이제이션 최적화 기법

React에서 컴포넌트 및 값의 불필요한 재계산을 방지하고 렌더링 성능을 최적화하기 위해 세 가지 주요 메모이제이션 기법을 제공합니다.

### 3.1. `React.memo` (컴포넌트 메모이제이션)

`React.memo`는 함수형 컴포넌트의 렌더링 결과를 메모이제이션하여, 특정 조건에서 불필요한 재렌더링을 방지합니다. `React.memo`로 감싸진 컴포넌트는 `props`가 변경되지 않는 한 재렌더링되지 않습니다.

**원리:** `React.memo`는 기본적으로 `props`의 얕은 비교(shallow comparison)를 수행합니다. 즉, `props`로 전달된 값이 이전 렌더링 시점의 값과 동일한 참조를 가지고 있는지 확인합니다. 만약 모든 `props`가 동일하다면, React는 해당 컴포넌트의 렌더링을 건너뛰고 이전에 렌더링된 결과를 재사용합니다.

**주의사항:**

- `props`가 복잡한 객체나 배열인 경우, 얕은 비교만으로는 변경을 제대로 감지하지 못할 수 있습니다.
- `React.memo`는 `props`가 자주 변경되는 컴포넌트에는 오히려 오버헤드가 될 수 있습니다. 메모이제이션 비교 비용이 컴포넌트 렌더링 비용보다 커질 수 있기 때문입니다.

### 3.2. `useMemo` (값 메모이제이션)

`useMemo` 훅은 **계산량이 많은 함수의 결과 값**을 메모이제이션합니다. 의존성 배열(dependency array)에 있는 값이 변경되지 않는 한, 이전에 계산된 값을 재사용하고 함수를 다시 실행하지 않습니다.

**원리:** `useMemo`는 첫 번째 인자로 콜백 함수를 받고, 두 번째 인자로 의존성 배열을 받습니다. 의존성 배열 내의 값이 변경되었을 때만 콜백 함수를 다시 실행하고 새로운 값을 반환합니다. 그렇지 않으면 메모리에 저장된 이전 값을 반환합니다.

**사용 시점:**

- 컴포넌트 내에서 생성되는 객체나 배열을 자식 컴포넌트의 `props`로 전달할 때, `React.memo`가 적용된 자식 컴포넌트의 불필요한 재렌더링을 방지하기 위해 사용합니다. (객체나 배열은 매 렌더링마다 새로운 참조를 가지므로 `React.memo`가 작동하지 않을 수 있습니다.)

### 3.3. `useCallback` (함수 메모이제이션)

`useCallback` 훅은 **함수 자체**를 메모이제이션합니다. `useMemo`와 유사하게 의존성 배열에 있는 값이 변경되지 않는 한, 이전에 생성된 함수를 재사용하고 함수를 다시 생성하지 않습니다.

**원리:** JavaScript에서 함수는 객체이므로, 컴포넌트가 재렌더링될 때마다 새로운 함수 인스턴스가 생성됩니다. `useCallback`은 이 새로운 함수 인스턴스 생성을 막아, 의존성 배열의 값이 변경되지 않는 한 항상 동일한 함수 참조를 반환하도록 합니다.

---

이러한 메모이제이션 기법들은 React 애플리케이션의 성능을 최적화하는 강력한 도구이지만, 과도한 사용은 오히려 코드를 복잡하게 만들고 디버깅을 어렵게 할 수 있습니다. 따라서 실제 성능 저하가 확인되는 지점에 선택적으로 적용하는 것이 중요합니다.
