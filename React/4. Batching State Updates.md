## 상태 업데이트의 일괄 처리 (Batching State Updates)

**사용자 질문:** "하나의 상태가 함수 내부에서 여러 번 바뀌어도, 동기적으로 실행되는 코드 블록(예: 이벤트 핸들러, `useEffect` 콜백)이 한 번 끝나야 딱 한 번 적용되던데, 그건 왜 그런가요?"

이 현상은 React의 **상태 업데이트 일괄 처리(Batching State Updates)** 메커니즘 때문입니다. React는 성능 최적화를 위해 여러 개의 `setState` 호출을 하나의 리렌더링(re-render)으로 묶어서 처리합니다.

**일괄 처리의 원리:**

1.  **불필요한 리렌더링 방지**: 만약 함수 내부에서 `setState`가 여러 번 호출될 때마다 즉시 리렌더링이 발생한다면, 매번 가상 DOM 비교 및 실제 DOM 업데이트가 이루어져서 성능 저하를 초래할 수 있습니다.
2.  **단일 커밋**: React는 여러 상태 업데이트를 모아서 한 번의 재조정(Reconciliation) 과정과 실제 DOM 업데이트(Commit)를 수행합니다. 이를 통해 브라우저의 리플로우(Reflow)와 리페인트(Repaint)를 최소화하여 애플리케이션의 응답성을 향상시킵니다.

**일괄 처리의 작동 방식:**

- React 18 이전에는 이벤트 핸들러(예: `onClick`, `onChange`) 내부에서 발생하는 동기적인 상태 업데이트만 일괄 처리되었습니다. `setTimeout`, Promise 콜백 또는 네이티브 이벤트 핸들러(`addEventListener`) 내의 업데이트는 기본적으로 일괄 처리되지 않아 각각 별도의 리렌더링을 유발할 수 있었습니다.

---

**React 18부터는 모든 업데이트가 자동으로 일괄 처리됩니다:**

이는 `setTimeout`, Promise 콜백, 네이티브 이벤트 핸들러 등 React 외부에서 발생하는 업데이트까지 포함하여, 단일 이벤트 루프 틱 내에서 발생하는 모든 상태 업데이트가 하나의 리렌더링으로 묶여 처리됨을 의미합니다.

이로써 React 애플리케이션의 성능이 더욱 향상되고 예측 가능성이 높아졌습니다.

**예시 (React 18 이상):**

```javascript
import React from "react";
import ReactDOM from "react-dom/client";

function Counter() {
  const [count, setCount] = React.useState(0);
  const [name, setName] = React.useState("React");

  const handleClick = () => {
    // 이 두 개의 setState 호출은 단 한 번의 리렌더링으로 일괄 처리됩니다.
    setCount((c) => c + 1); // 첫 번째 업데이트
    setName("React World"); // 두 번째 업데이트
    console.log("State updates scheduled");
  };

  // setTimeout 내의 업데이트도 React 18에서는 자동으로 일괄 처리됩니다.
  const handleAsyncClick = () => {
    setTimeout(() => {
      setCount((c) => c + 1);
      setName("Async React");
    }, 0);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <p>Name: {name}</p>
      <button onClick={handleClick}>Increment and Change Name (Sync)</button>
      <button onClick={handleAsyncClick}>
        Increment and Change Name (Async)
      </button>
    </div>
  );
}

const rootElement = document.getElementById("root");
if (rootElement) {
  const root = ReactDOM.createRoot(rootElement);
  root.render(<Counter />);
}
```
