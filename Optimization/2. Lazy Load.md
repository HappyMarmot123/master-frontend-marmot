# Lazy Load (ì§€ì—° ë¡œë”©)

## ğŸ“– ê°œìš”

**Lazy Load(ì§€ì—° ë¡œë”©)**ëŠ” ì›¹ í˜ì´ì§€ì˜ ë¦¬ì†ŒìŠ¤(ì´ë¯¸ì§€, ë¹„ë””ì˜¤, ìŠ¤í¬ë¦½íŠ¸ ë“±)ë¥¼ ì‚¬ìš©ìê°€ ì‹¤ì œë¡œ í•„ìš”ë¡œ í•  ë•Œê¹Œì§€ ë¡œë”©ì„ ì§€ì—°ì‹œí‚¤ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì´ˆê¸° í˜ì´ì§€ ë¡œë”© ì‹œê°„ì„ ë‹¨ì¶•í•˜ê³ , ë¶ˆí•„ìš”í•œ ë¦¬ì†ŒìŠ¤ ë‹¤ìš´ë¡œë“œë¥¼ ë°©ì§€í•˜ì—¬ ì›¹ ì„±ëŠ¥ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ğŸ¯ Lazy Loadì˜ í•„ìš”ì„±

### 1. ê¸°ì¡´ ë¡œë”© ë°©ì‹ì˜ ë¬¸ì œì 

**ì¦‰ì‹œ ë¡œë”©(Immediate Loading)ì˜ í•œê³„**:

- **ì´ˆê¸° ë¡œë”© ì§€ì—°**: ëª¨ë“  ë¦¬ì†ŒìŠ¤ë¥¼ í•œ ë²ˆì— ë‹¤ìš´ë¡œë“œí•˜ì—¬ í˜ì´ì§€ ë¡œë”© ì‹œê°„ ì¦ê°€
- **ë¶ˆí•„ìš”í•œ ë°ì´í„° ì „ì†¡**: ë·°í¬íŠ¸ ë°–ì— ìˆëŠ” ì´ë¯¸ì§€ë‚˜ ì½˜í…ì¸ ë„ ì¦‰ì‹œ ë¡œë“œ
- **ëŒ€ì—­í­ ë‚­ë¹„**: ì‚¬ìš©ìê°€ ë³´ì§€ ì•ŠëŠ” ì½˜í…ì¸ ê¹Œì§€ ë‹¤ìš´ë¡œë“œ
- **ëª¨ë°”ì¼ ì„±ëŠ¥ ì €í•˜**: ì œí•œëœ ë„¤íŠ¸ì›Œí¬ í™˜ê²½ì—ì„œ í° ë¦¬ì†ŒìŠ¤ íŒŒì¼ ë‹¤ìš´ë¡œë“œ

**ì‹¤ì œ ì„±ëŠ¥ ì˜í–¥**:

```javascript
// ì¦‰ì‹œ ë¡œë”© ë°©ì‹ì˜ ë¬¸ì œ
// ì´ ì´ë¯¸ì§€ ìˆ˜: 50ê°œ
// ì´ˆê¸° ë¡œë”© ì‹œê°„: 8.5ì´ˆ
// ì´ ë‹¤ìš´ë¡œë“œ í¬ê¸°: 15.2MB
// First Contentful Paint: 3.8ì´ˆ
// Largest Contentful Paint: 12.3ì´ˆ
```

### 2. Lazy Loadì˜ í•´ê²°ì±…

**ì§€ì—° ë¡œë”©ì˜ ì´ì **:

- **ì´ˆê¸° ë¡œë”© ì‹œê°„ ë‹¨ì¶•**: ë·°í¬íŠ¸ì— ë³´ì´ëŠ” ì½˜í…ì¸ ë§Œ ìš°ì„  ë¡œë“œ
- **ëŒ€ì—­í­ ì ˆì•½**: ì‚¬ìš©ìê°€ ì‹¤ì œë¡œ í•„ìš”ë¡œ í•˜ëŠ” ë¦¬ì†ŒìŠ¤ë§Œ ë‹¤ìš´ë¡œë“œ
- **ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ**: í˜ì´ì§€ ë¡œë”© ì™„ë£Œê¹Œì§€ì˜ ëŒ€ê¸° ì‹œê°„ ê°ì†Œ
- **ëª¨ë°”ì¼ ìµœì í™”**: ì œí•œëœ ë„¤íŠ¸ì›Œí¬ í™˜ê²½ì—ì„œì˜ íš¨ìœ¨ì  ë¦¬ì†ŒìŠ¤ ê´€ë¦¬

**ì„±ëŠ¥ í–¥ìƒ íš¨ê³¼**:

```javascript
// Lazy Load ì ìš© í›„
// ì´ˆê¸° ë¡œë”© ì‹œê°„: 2.1ì´ˆ (75% ê°œì„ )
// ì´ˆê¸° ë‹¤ìš´ë¡œë“œ í¬ê¸°: 2.8MB (82% ê°ì†Œ)
// First Contentful Paint: 1.2ì´ˆ (68% ê°œì„ )
// Largest Contentful Paint: 4.8ì´ˆ (61% ê°œì„ )
```

## ğŸ”§ Lazy Load êµ¬í˜„ ë°©ë²•

### 1. ì´ë¯¸ì§€ Lazy Loading

**Intersection Observer API í™œìš©**:

```javascript
// utils/lazyImage.js
class LazyImageLoader {
  constructor() {
    this.imageObserver = null;
    this.init();
  }

  init() {
    // Intersection Observer ì§€ì› í™•ì¸
    if ("IntersectionObserver" in window) {
      this.imageObserver = new IntersectionObserver(
        this.handleIntersection.bind(this),
        {
          rootMargin: "50px 0px", // ë·°í¬íŠ¸ 50px ì „ì— ë¯¸ë¦¬ ë¡œë“œ
          threshold: 0.01,
        }
      );
    }
  }

  handleIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        this.loadImage(img);
        this.imageObserver.unobserve(img);
      }
    });
  }

  loadImage(img) {
    const src = img.dataset.src;
    if (src) {
      img.src = src;
      img.classList.remove("lazy");
      img.classList.add("loaded");
    }
  }

  observe(image) {
    if (this.imageObserver) {
      this.imageObserver.observe(image);
    } else {
      // í´ë°±: ì¦‰ì‹œ ë¡œë“œ
      this.loadImage(image);
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const lazyLoader = new LazyImageLoader();

document.addEventListener("DOMContentLoaded", () => {
  const lazyImages = document.querySelectorAll("img[data-src]");
  lazyImages.forEach((img) => lazyLoader.observe(img));
});
```

**HTMLì—ì„œì˜ ì‚¬ìš©**:

```html
<!-- ê¸°ë³¸ Lazy Loading -->
<img
  data-src="images/product1.jpg"
  alt="ìƒí’ˆ ì´ë¯¸ì§€ 1"
  class="lazy"
  loading="lazy"
/>

<!-- ê³ ê¸‰ Lazy Loading -->
<img
  data-src="images/product1.jpg"
  data-srcset="images/product1-small.jpg 300w, images/product1-medium.jpg 600w, images/product1-large.jpg 900w"
  data-sizes="(max-width: 768px) 300px, (max-width: 1200px) 600px, 900px"
  alt="ìƒí’ˆ ì´ë¯¸ì§€ 1"
  class="lazy"
  loading="lazy"
/>

<!-- í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ -->
<img
  data-src="images/product1.jpg"
  src="images/placeholder.jpg"
  alt="ìƒí’ˆ ì´ë¯¸ì§€ 1"
  class="lazy"
  loading="lazy"
/>
```

**CSS ìŠ¤íƒ€ì¼ë§**:

```css
/* Lazy Loading ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ */
.lazy {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  filter: blur(5px);
}

.lazy.loaded {
  opacity: 1;
  filter: blur(0);
}

/* ë¡œë”© ìƒíƒœ í‘œì‹œ */
.lazy::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin: -10px 0 0 -10px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
```

### 2. Reactì—ì„œì˜ Lazy Loading

**ì»¤ìŠ¤í…€ Hook í™œìš©**:

```jsx
// hooks/useLazyLoad.js
import { useEffect, useRef, useState } from "react";

export const useLazyLoad = (options = {}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [isLoaded, setIsLoaded] = useState(false);
  const elementRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.unobserve(entry.target);
        }
      },
      {
        rootMargin: options.rootMargin || "50px",
        threshold: options.threshold || 0.01,
      }
    );

    if (elementRef.current) {
      observer.observe(elementRef.current);
    }

    return () => {
      if (elementRef.current) {
        observer.unobserve(elementRef.current);
      }
    };
  }, [options.rootMargin, options.threshold]);

  const handleLoad = () => {
    setIsLoaded(true);
  };

  return {
    elementRef,
    isVisible,
    isLoaded,
    handleLoad,
  };
};

// ì‚¬ìš© ì˜ˆì‹œ
function LazyImage({ src, alt, placeholder }) {
  const { elementRef, isVisible, isLoaded, handleLoad } = useLazyLoad();

  return (
    <div ref={elementRef} className="lazy-image-container">
      {!isVisible && (
        <img src={placeholder} alt="ë¡œë”© ì¤‘..." className="placeholder" />
      )}

      {isVisible && (
        <img
          src={src}
          alt={alt}
          onLoad={handleLoad}
          className={`lazy-image ${isLoaded ? "loaded" : ""}`}
        />
      )}
    </div>
  );
}
```

**React ì»´í¬ë„ŒíŠ¸ì—ì„œì˜ í™œìš©**:

```jsx
// components/ProductGrid.jsx
import React from "react";
import LazyImage from "./LazyImage";

function ProductGrid({ products }) {
  return (
    <div className="product-grid">
      {products.map((product) => (
        <div key={product.id} className="product-card">
          <LazyImage
            src={product.image}
            alt={product.name}
            placeholder="/images/placeholder.jpg"
          />
          <h3>{product.name}</h3>
          <p>{product.price}</p>
        </div>
      ))}
    </div>
  );
}

export default ProductGrid;
```

### 3. Vue.jsì—ì„œì˜ Lazy Loading

**Vue Directive í™œìš©**:

```javascript
// directives/lazyLoad.js
export const lazyLoad = {
  mounted(el, binding) {
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.classList.remove("lazy");
          imageObserver.unobserve(img);
        }
      });
    });

    imageObserver.observe(el);
  },
};

// main.jsì—ì„œ ì „ì—­ ë“±ë¡
import { createApp } from "vue";
import App from "./App.vue";
import { lazyLoad } from "./directives/lazyLoad";

const app = createApp(App);
app.directive("lazy", lazyLoad);
app.mount("#app");
```

**Vue ì»´í¬ë„ŒíŠ¸ì—ì„œì˜ ì‚¬ìš©**:

```vue
<!-- ProductCard.vue -->
<template>
  <div class="product-card">
    <img
      v-lazy
      :data-src="product.image"
      :alt="product.name"
      class="product-image lazy"
      loading="lazy"
    />
    <h3>{{ product.name }}</h3>
    <p>{{ product.price }}</p>
  </div>
</template>

<script>
export default {
  name: "ProductCard",
  props: {
    product: {
      type: Object,
      required: true,
    },
  },
};
</script>

<style scoped>
.lazy {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.lazy:not([src=""]):not([src*="placeholder"]) {
  opacity: 1;
}
</style>
```

## ğŸš€ ê³ ê¸‰ ìµœì í™” ê¸°ë²•

### 1. ê°€ìƒ ìŠ¤í¬ë¡¤ë§(Virtual Scrolling)

**ëŒ€ìš©ëŸ‰ ë¦¬ìŠ¤íŠ¸ ìµœì í™”**:

```jsx
// components/VirtualList.jsx
import React, { useState, useEffect, useRef } from "react";

function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // ë³´ì´ëŠ” ì•„ì´í…œë§Œ ë Œë”ë§
  const visibleItemCount = Math.ceil(containerHeight / itemHeight);
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleItemCount + 1, items.length);

  const visibleItems = items.slice(startIndex, endIndex);
  const totalHeight = items.length * itemHeight;
  const offsetY = startIndex * itemHeight;

  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  return (
    <div
      ref={containerRef}
      style={{ height: containerHeight, overflow: "auto" }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: "relative" }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{ height: itemHeight }}
              className="virtual-list-item"
            >
              {item.content}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

export default VirtualList;
```

**ì‚¬ìš© ì˜ˆì‹œ**:

```jsx
// App.jsx
import VirtualList from "./components/VirtualList";

function App() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    content: `ì•„ì´í…œ ${i}`,
  }));

  return (
    <div className="app">
      <h1>ê°€ìƒ ìŠ¤í¬ë¡¤ë§ ì˜ˆì‹œ</h1>
      <VirtualList items={items} itemHeight={50} containerHeight={400} />
    </div>
  );
}
```

### 2. ë¬´í•œ ìŠ¤í¬ë¡¤(Infinite Scroll)

**í˜ì´ì§€ë„¤ì´ì…˜ ëŒ€ì‹  ë¬´í•œ ë¡œë”©**:

```jsx
// hooks/useInfiniteScroll.js
import { useState, useEffect, useCallback } from "react";

export const useInfiniteScroll = (fetchData, options = {}) => {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;

    setLoading(true);
    try {
      const newItems = await fetchData(page);

      if (newItems.length === 0) {
        setHasMore(false);
      } else {
        setItems((prev) => [...prev, ...newItems]);
        setPage((prev) => prev + 1);
      }
    } catch (error) {
      console.error("ë°ì´í„° ë¡œë”© ì‹¤íŒ¨:", error);
    } finally {
      setLoading(false);
    }
  }, [fetchData, page, loading, hasMore]);

  useEffect(() => {
    const handleScroll = () => {
      if (
        window.innerHeight + document.documentElement.scrollTop >=
        document.documentElement.offsetHeight - options.threshold
      ) {
        loadMore();
      }
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, [loadMore, options.threshold]);

  return { items, loading, hasMore, loadMore };
};

// ì‚¬ìš© ì˜ˆì‹œ
function ProductList() {
  const fetchProducts = async (page) => {
    const response = await fetch(`/api/products?page=${page}&limit=20`);
    return response.json();
  };

  const { items, loading, hasMore } = useInfiniteScroll(fetchProducts, {
    threshold: 100,
  });

  return (
    <div className="product-list">
      {items.map((product) => (
        <ProductCard key={product.id} product={product} />
      ))}

      {loading && <div className="loading">ë¡œë”© ì¤‘...</div>}
      {!hasMore && <div className="end">ëª¨ë“  ìƒí’ˆì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</div>}
    </div>
  );
}
```

### 3. ìŠ¤ë§ˆíŠ¸ í”„ë¦¬ë¡œë”©(Smart Preloading)

**ì‚¬ìš©ì í–‰ë™ ì˜ˆì¸¡ì„ í†µí•œ í”„ë¦¬ë¡œë”©**:

```javascript
// utils/smartPreloader.js
class SmartPreloader {
  constructor() {
    this.preloadQueue = new Map();
    this.observer = null;
    this.init();
  }

  init() {
    // ë§ˆìš°ìŠ¤ ì›€ì§ì„ ê°ì§€
    this.observeMouseMovement();

    // ìŠ¤í¬ë¡¤ ë°©í–¥ ê°ì§€
    this.observeScrollDirection();
  }

  observeMouseMovement() {
    let mouseX = 0;
    let mouseY = 0;
    let direction = "none";

    document.addEventListener("mousemove", (e) => {
      const deltaX = e.clientX - mouseX;
      const deltaY = e.clientY - mouseY;

      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        direction = deltaX > 0 ? "right" : "left";
      } else {
        direction = deltaY > 0 ? "down" : "up";
      }

      mouseX = e.clientX;
      mouseY = e.clientY;

      this.predictAndPreload(direction, e.clientX, e.clientY);
    });
  }

  observeScrollDirection() {
    let lastScrollTop = 0;

    window.addEventListener("scroll", () => {
      const scrollTop = window.pageYOffset;
      const direction = scrollTop > lastScrollTop ? "down" : "up";

      this.preloadVisibleContent(direction);
      lastScrollTop = scrollTop;
    });
  }

  predictAndPreload(direction, x, y) {
    // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ê¸°ë°˜ìœ¼ë¡œ ë‹¤ìŒì— ë³´ì¼ ì½˜í…ì¸  ì˜ˆì¸¡
    const predictions = this.getPredictions(direction, x, y);

    predictions.forEach((prediction) => {
      if (!this.preloadQueue.has(prediction.id)) {
        this.preloadQueue.set(prediction.id, prediction);
        this.preloadResource(prediction);
      }
    });
  }

  preloadVisibleContent(direction) {
    const visibleElements = this.getVisibleElements();

    visibleElements.forEach((element) => {
      const nextElement = this.getNextElement(element, direction);
      if (nextElement) {
        this.preloadElement(nextElement);
      }
    });
  }

  preloadResource(prediction) {
    if (prediction.type === "image") {
      const img = new Image();
      img.src = prediction.src;
    } else if (prediction.type === "component") {
      // ì»´í¬ë„ŒíŠ¸ í”„ë¦¬ë¡œë”©
      import(prediction.path);
    }
  }

  getPredictions(direction, x, y) {
    // ë°©í–¥ê³¼ ìœ„ì¹˜ ê¸°ë°˜ ì˜ˆì¸¡ ë¡œì§
    const predictions = [];

    if (direction === "right") {
      // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ ì¤‘ì´ë©´ ë‹¤ìŒ ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”©
      const nextImage = this.findNextImage(x, y);
      if (nextImage) {
        predictions.push({
          id: nextImage.id,
          type: "image",
          src: nextImage.src,
        });
      }
    }

    return predictions;
  }

  getVisibleElements() {
    // í˜„ì¬ í™”ë©´ì— ë³´ì´ëŠ” ìš”ì†Œë“¤ ë°˜í™˜
    return Array.from(document.querySelectorAll("[data-preload]"));
  }

  getNextElement(currentElement, direction) {
    // ë°©í–¥ì— ë”°ë¥¸ ë‹¤ìŒ ìš”ì†Œ ì°¾ê¸°
    const selector =
      direction === "down" ? "nextElementSibling" : "previousElementSibling";
    return currentElement[selector];
  }

  preloadElement(element) {
    const preloadData = element.dataset.preload;
    if (preloadData) {
      const { type, src, path } = JSON.parse(preloadData);
      this.preloadResource({ type, src, path });
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const smartPreloader = new SmartPreloader();
```

## ğŸ“Š ì„±ëŠ¥ ì¸¡ì •ê³¼ ëª¨ë‹ˆí„°ë§

### 1. Lazy Loading ì„±ëŠ¥ ì¸¡ì •

**Intersection Observer ì„±ëŠ¥ ì¸¡ì •**:

```javascript
// utils/performanceMonitor.js
export const measureLazyLoadingPerformance = () => {
  const metrics = {
    totalImages: 0,
    lazyLoadedImages: 0,
    averageLoadTime: 0,
    totalLoadTime: 0,
  };

  const imageLoadTimes = [];
  const startTime = performance.now();

  // ì´ë¯¸ì§€ ë¡œë”© ì‹œê°„ ì¸¡ì •
  const measureImageLoad = (img) => {
    const loadStart = performance.now();

    img.addEventListener("load", () => {
      const loadTime = performance.now() - loadStart;
      imageLoadTimes.push(loadTime);
      metrics.totalLoadTime += loadTime;
      metrics.averageLoadTime = metrics.totalLoadTime / imageLoadTimes.length;
    });
  };

  // ëª¨ë“  ì´ë¯¸ì§€ì— ì¸¡ì • ì´ë²¤íŠ¸ ì¶”ê°€
  document.querySelectorAll("img").forEach((img) => {
    metrics.totalImages++;
    if (img.classList.contains("lazy")) {
      metrics.lazyLoadedImages++;
    }
    measureImageLoad(img);
  });

  return metrics;
};
```

**ì‚¬ìš©ì ê²½í—˜ ë©”íŠ¸ë¦­ ìˆ˜ì§‘**:

```javascript
// utils/userExperienceMetrics.js
export const collectUXMetrics = () => {
  const metrics = {
    firstImageLoad: 0,
    lastImageLoad: 0,
    scrollDepth: 0,
    timeOnPage: 0,
  };

  let firstImageLoaded = false;
  let pageStartTime = performance.now();

  // ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ë¡œë”© ì‹œê°„
  document.addEventListener("DOMContentLoaded", () => {
    const firstImage = document.querySelector("img");
    if (firstImage) {
      firstImage.addEventListener("load", () => {
        if (!firstImageLoaded) {
          metrics.firstImageLoad = performance.now() - pageStartTime;
          firstImageLoaded = true;
        }
      });
    }
  });

  // ìŠ¤í¬ë¡¤ ê¹Šì´ ì¸¡ì •
  let maxScrollDepth = 0;
  window.addEventListener("scroll", () => {
    const scrollTop = window.pageYOffset;
    const documentHeight = document.documentElement.scrollHeight;
    const windowHeight = window.innerHeight;

    const scrollDepth = (scrollTop + windowHeight) / documentHeight;
    maxScrollDepth = Math.max(maxScrollDepth, scrollDepth);
    metrics.scrollDepth = maxScrollDepth;
  });

  // í˜ì´ì§€ ì´íƒˆ ì‹œ ë©”íŠ¸ë¦­ ì „ì†¡
  window.addEventListener("beforeunload", () => {
    metrics.timeOnPage = performance.now() - pageStartTime;
    metrics.lastImageLoad = performance.now() - pageStartTime;

    // ë©”íŠ¸ë¦­ ì „ì†¡
    navigator.sendBeacon("/api/metrics", JSON.stringify(metrics));
  });

  return metrics;
};
```

### 2. A/B í…ŒìŠ¤íŠ¸ë¥¼ í†µí•œ ê²€ì¦

**Lazy Loading ì ìš© ì „í›„ ë¹„êµ**:

```javascript
// utils/abTest.js
export const runLazyLoadingABTest = () => {
  const isLazyLoadingEnabled = Math.random() < 0.5; // 50% í™•ë¥ 

  if (isLazyLoadingEnabled) {
    // Lazy Loading ì ìš©
    enableLazyLoading();
  } else {
    // ì¦‰ì‹œ ë¡œë”© ë°©ì‹
    enableImmediateLoading();
  }

  // ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘
  const performanceData = {
    variant: isLazyLoadingEnabled ? "lazy-loading" : "immediate-loading",
    metrics: {},
  };

  // Core Web Vitals ì¸¡ì •
  if ("PerformanceObserver" in window) {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === "largest-contentful-paint") {
          performanceData.metrics.lcp = entry.startTime;
        }
      });
    });

    observer.observe({ entryTypes: ["largest-contentful-paint"] });
  }

  // í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ ì‹œ ë°ì´í„° ì „ì†¡
  window.addEventListener("load", () => {
    performanceData.metrics.loadTime = performance.now();

    // ë¶„ì„ ì„œë²„ë¡œ ì „ì†¡
    sendPerformanceData(performanceData);
  });

  return isLazyLoadingEnabled;
};

function enableLazyLoading() {
  // Lazy Loading êµ¬í˜„
  const lazyImages = document.querySelectorAll("img[data-src]");
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        imageObserver.unobserve(img);
      }
    });
  });

  lazyImages.forEach((img) => imageObserver.observe(img));
}

function enableImmediateLoading() {
  // ì¦‰ì‹œ ë¡œë”© êµ¬í˜„
  const lazyImages = document.querySelectorAll("img[data-src]");
  lazyImages.forEach((img) => {
    img.src = img.dataset.src;
  });
}
```

## âš ï¸ ì£¼ì˜ì‚¬í•­ê³¼ ì œí•œì‚¬í•­

### 1. SEO ê³ ë ¤ì‚¬í•­

**ê²€ìƒ‰ ì—”ì§„ ìµœì í™”**:

```html
<!-- SEOë¥¼ ìœ„í•œ ë©”íƒ€ë°ì´í„° -->
<head>
  <!-- ì´ë¯¸ì§€ ì‚¬ì´íŠ¸ë§µ -->
  <link rel="image-sitemap" href="/image-sitemap.xml" />

  <!-- Open Graph ì´ë¯¸ì§€ -->
  <meta property="og:image" content="https://example.com/images/product1.jpg" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />

  <!-- Twitter Card ì´ë¯¸ì§€ -->
  <meta
    name="twitter:image"
    content="https://example.com/images/product1.jpg"
  />
</head>

<!-- êµ¬ì¡°í™”ëœ ë°ì´í„° -->
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Product",
    "name": "ìƒí’ˆëª…",
    "image": "https://example.com/images/product1.jpg",
    "description": "ìƒí’ˆ ì„¤ëª…"
  }
</script>
```

**ì´ë¯¸ì§€ ì‚¬ì´íŠ¸ë§µ ìƒì„±**:

```javascript
// utils/imageSitemapGenerator.js
export const generateImageSitemap = (images) => {
  const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:image="http://www.google.com/schemas/sitemap-image/1.1">
  ${images
    .map(
      (image) => `
  <url>
    <loc>${image.pageUrl}</loc>
    <image:image>
      <image:loc>${image.imageUrl}</image:loc>
      <image:title>${image.title}</image:title>
      <image:caption>${image.caption}</image:caption>
    </image:image>
  </url>
  `
    )
    .join("")}
</urlset>`;

  return sitemap;
};
```

### 2. ì ‘ê·¼ì„± ê³ ë ¤ì‚¬í•­

**ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›**:

```html
<!-- ì ‘ê·¼ì„±ì„ ìœ„í•œ ì†ì„± ì¶”ê°€ -->
<img
  data-src="images/product1.jpg"
  alt="ìƒí’ˆ ì´ë¯¸ì§€ 1 - ìƒì„¸ ì„¤ëª…"
  aria-describedby="product1-description"
  role="img"
  tabindex="0"
/>

<div id="product1-description" class="sr-only">
  ì´ ìƒí’ˆì€ ê³ í’ˆì§ˆ ì†Œì¬ë¡œ ì œì‘ë˜ì—ˆìœ¼ë©°, ë‹¤ì–‘í•œ ìƒ‰ìƒê³¼ ì‚¬ì´ì¦ˆë¥¼ ì œê³µí•©ë‹ˆë‹¤.
</div>

<!-- ë¡œë”© ìƒíƒœ ì•ˆë‚´ -->
<div class="loading-indicator" aria-live="polite" aria-atomic="true">
  ì´ë¯¸ì§€ ë¡œë”© ì¤‘...
</div>
```

**í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ì§€ì›**:

```javascript
// utils/accessibility.js
export const enhanceKeyboardNavigation = () => {
  const lazyImages = document.querySelectorAll("img[data-src]");

  lazyImages.forEach((img) => {
    img.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        // ì´ë¯¸ì§€ ë¡œë”© íŠ¸ë¦¬ê±°
        loadImage(img);
      }
    });

    // í¬ì»¤ìŠ¤ ì‹œ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë”©
    img.addEventListener("focus", () => {
      if (!img.src && img.dataset.src) {
        loadImage(img);
      }
    });
  });
};

function loadImage(img) {
  if (img.dataset.src) {
    img.src = img.dataset.src;
    img.classList.remove("lazy");
    img.classList.add("loaded");
  }
}
```

### 3. ë¸Œë¼ìš°ì € í˜¸í™˜ì„±

**ì§€ì› ë¸Œë¼ìš°ì €**:

- **Intersection Observer**: Chrome 51+, Firefox 55+, Safari 12.1+, Edge 79+
- **loading="lazy"**: Chrome 76+, Firefox 75+, Safari 15.4+, Edge 79+

**í´ë°± ì „ëµ**:

```javascript
// utils/fallback.js
export const createLazyLoadingFallback = () => {
  // Intersection Observer ì§€ì› í™•ì¸
  if (!("IntersectionObserver" in window)) {
    return createScrollBasedFallback();
  }

  // loading="lazy" ì§€ì› í™•ì¸
  if (!("loading" in HTMLImageElement.prototype)) {
    return createIntersectionObserverFallback();
  }

  return createNativeLazyLoading();
};

function createScrollBasedFallback() {
  // ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ ê¸°ë°˜ í´ë°±
  const lazyImages = document.querySelectorAll("img[data-src]");

  const handleScroll = throttle(() => {
    lazyImages.forEach((img) => {
      if (isElementInViewport(img)) {
        loadImage(img);
      }
    });
  }, 100);

  window.addEventListener("scroll", handleScroll);
  window.addEventListener("resize", handleScroll);

  // ì´ˆê¸° ë¡œë“œ
  handleScroll();
}

function createIntersectionObserverFallback() {
  // Intersection Observer ê¸°ë°˜ í´ë°±
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        loadImage(img);
        imageObserver.unobserve(img);
      }
    });
  });

  document.querySelectorAll("img[data-src]").forEach((img) => {
    imageObserver.observe(img);
  });
}

function createNativeLazyLoading() {
  // ë„¤ì´í‹°ë¸Œ lazy loading ì‚¬ìš©
  document.querySelectorAll("img[data-src]").forEach((img) => {
    img.loading = "lazy";
    img.src = img.dataset.src;
  });
}

function isElementInViewport(el) {
  const rect = el.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <=
      (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

function throttle(func, limit) {
  let inThrottle;
  return function () {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}
```

## ğŸ¯ ì‹¤ì œ ì ìš© ì‚¬ë¡€

### 1. E-commerce ì‚¬ì´íŠ¸

**ìƒí’ˆ ëª©ë¡ í˜ì´ì§€ ìµœì í™”**:

```jsx
// components/ProductList.jsx
import React, { useState, useEffect } from "react";
import LazyImage from "./LazyImage";

function ProductList({ category }) {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchProducts(category);
  }, [category]);

  const fetchProducts = async (cat) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/products?category=${cat}`);
      const data = await response.json();
      setProducts(data);
    } catch (error) {
      console.error("ìƒí’ˆ ë¡œë”© ì‹¤íŒ¨:", error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="product-list">
      {loading && <div className="loading">ìƒí’ˆ ë¡œë”© ì¤‘...</div>}

      <div className="product-grid">
        {products.map((product) => (
          <div key={product.id} className="product-card">
            <LazyImage
              src={product.image}
              alt={product.name}
              placeholder="/images/product-placeholder.jpg"
              className="product-image"
            />
            <h3>{product.name}</h3>
            <p className="price">{product.price.toLocaleString()}ì›</p>
          </div>
        ))}
      </div>
    </div>
  );
}

export default ProductList;
```

### 2. ë¸”ë¡œê·¸/ë‰´ìŠ¤ ì‚¬ì´íŠ¸

**ê¸°ì‚¬ ëª©ë¡ í˜ì´ì§€ ìµœì í™”**:

```jsx
// components/ArticleList.jsx
import React from "react";
import LazyImage from "./LazyImage";

function ArticleList({ articles }) {
  return (
    <div className="article-list">
      {articles.map((article) => (
        <article key={article.id} className="article-card">
          <div className="article-image">
            <LazyImage
              src={article.featuredImage}
              alt={article.title}
              placeholder="/images/article-placeholder.jpg"
              className="article-thumbnail"
            />
          </div>

          <div className="article-content">
            <h2>{article.title}</h2>
            <p>{article.excerpt}</p>
            <div className="article-meta">
              <span>{article.author}</span>
              <span>{new Date(article.publishedAt).toLocaleDateString()}</span>
            </div>
          </div>
        </article>
      ))}
    </div>
  );
}

export default ArticleList;
```

## ğŸ“š ê²°ë¡ 

Lazy LoadëŠ” ì›¹ ì„±ëŠ¥ ìµœì í™”ì˜ í•µì‹¬ ê¸°ë²•ìœ¼ë¡œ, ì‚¬ìš©ì ê²½í—˜ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì ìš© ì‹œ ê³ ë ¤ì‚¬í•­**:

- **SEO ìµœì í™”**: ê²€ìƒ‰ ì—”ì§„ì´ ì´ë¯¸ì§€ë¥¼ ì¸ì‹í•  ìˆ˜ ìˆë„ë¡ ì ì ˆí•œ ë©”íƒ€ë°ì´í„° ì œê³µ
- **ì ‘ê·¼ì„±**: ìŠ¤í¬ë¦° ë¦¬ë”ì™€ í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ì§€ì›
- **ë¸Œë¼ìš°ì € í˜¸í™˜ì„±**: êµ¬í˜• ë¸Œë¼ìš°ì €ë¥¼ ìœ„í•œ í´ë°± ì „ëµ ìˆ˜ë¦½
- **ì‚¬ìš©ì ê²½í—˜**: ë¡œë”© ìƒíƒœ í‘œì‹œì™€ ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼

**ì„±ê³µì ì¸ ì ìš©ì„ ìœ„í•œ ì²´í¬ë¦¬ìŠ¤íŠ¸**:

- [ ] Intersection Observer API ë˜ëŠ” í´ë°± êµ¬í˜„
- [ ] ì ì ˆí•œ í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ ì œê³µ
- [ ] SEOë¥¼ ìœ„í•œ ë©”íƒ€ë°ì´í„° ì„¤ì •
- [ ] ì ‘ê·¼ì„± ê°€ì´ë“œë¼ì¸ ì¤€ìˆ˜
- [ ] ì„±ëŠ¥ ì¸¡ì • ë° ëª¨ë‹ˆí„°ë§ ì²´ê³„ êµ¬ì¶•

Lazy Loadë¥¼ ì ì ˆíˆ ì ìš©í•˜ë©´ ì´ˆê¸° í˜ì´ì§€ ë¡œë”© ì‹œê°„ì„ í¬ê²Œ ë‹¨ì¶•í•˜ê³ , ì‚¬ìš©ìì—ê²Œ ë” ë¹ ë¥´ê³  ë°˜ì‘ì„± ì¢‹ì€ ì›¹ ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
