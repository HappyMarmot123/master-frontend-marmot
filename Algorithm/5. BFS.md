# 너비 우선 탐색 (BFS, Breadth-First Search)

**BFS**는 그래프의 모든 노드를 탐색하기 위한 알고리즘으로, 이름 그대로 너비를 우선하여 탐색합니다. 루트 노드(또는 임의의 시작 노드)에서 시작하여, 가까운 노드를 먼저 방문하고 더 멀리 있는 노드를 나중에 방문하는 방식입니다. 더 작은 문제를 먼저 해결함으로 큰 문제를 해결합니다.

### 특징

- **큐(Queue)** 자료구조를 이용하여 구현됩니다.
- 시작 노드에서부터 거리가 가까운 순서대로, 즉 레벨(level) 순으로 노드를 탐색합니다.
- **가중치가 없는 그래프**에서 두 노드 간의 최단 경로를 찾는 데 사용될 수 있습니다.

### 동작 원리

1. 탐색을 시작할 노드를 큐에 넣고, 방문 처리합니다.
2. 큐가 비어있을 때까지 다음 과정을 반복합니다.
3. 큐에서 노드를 하나 꺼냅니다(dequeue).
4. 해당 노드에 연결된 인접 노드 중 아직 방문하지 않은 모든 노드를 큐에 넣고(enqueue), 방문 처리합니다.

### 단점

- **DFS보다 많은 메모리 사용:** 큐에 많은 노드를 저장해야 할 수 있어 DFS보다 더 많은 메모리를 사용할 수 있습니다.
- **구현이 다소 복잡할 수 있습니다.** (재귀 대신 반복문과 큐를 명시적으로 사용해야 하므로)

### 예제 코드 (JavaScript - 인접 리스트, 큐)

```javascript
const graphBFS = {
  A: ["B", "C"],
  B: ["A", "D", "E"],
  C: ["A", "F"],
  D: ["B"],
  E: ["B", "F"],
  F: ["C", "E"],
};

function bfs(graph, startNode) {
  const visited = {}; // 방문 여부를 기록할 객체
  const queue = []; // 탐색할 노드를 저장할 큐
  const result = []; // 탐색 순서를 기록할 배열

  visited[startNode] = true; // 시작 노드 방문 처리
  queue.push(startNode); // 큐에 시작 노드 추가

  while (queue.length > 0) {
    const node = queue.shift(); // 큐에서 노드 꺼내기
    result.push(node); // 결과에 추가

    for (const neighbor of graph[node]) {
      if (!visited[neighbor]) {
        // 방문하지 않은 인접 노드라면
        visited[neighbor] = true; // 방문 처리
        queue.push(neighbor); // 큐에 추가
      }
    }
  }
  return result;
}

// 사용 예시:
// console.log("BFS 탐색 순서:", bfs(graphBFS, 'A')); // BFS 탐색 순서: ['A', 'B', 'C', 'D', 'E', 'F']
```

**코드 설명:**

1. `graphBFS`: 인접 리스트 형태로 그래프를 정의합니다.
2. `bfs` 함수:
   - `visited` 객체는 노드의 방문 여부를 추적합니다.
   - `queue` 배열은 다음에 방문할 노드들을 저장하는 큐로 사용됩니다 (`shift()`와 `push()`를 이용).
   - `result` 배열은 탐색 순서를 저장합니다.
   - 시작 노드를 방문 처리하고 큐에 추가합니다.
   - `while` 루프는 큐가 빌 때까지 반복됩니다.
   - 큐에서 노드를 하나 꺼내 `result`에 추가합니다.
   - 꺼낸 노드의 모든 인접 노드를 순회하며, 방문하지 않은 노드가 있다면 방문 처리하고 큐에 추가합니다.
