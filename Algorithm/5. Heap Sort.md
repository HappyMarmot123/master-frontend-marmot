# 힙 정렬 (Heap Sort)

힙 정렬은 힙(Heap)이라는 자료 구조를 이용하여 정렬하는 알고리즘입니다. 힙은 '최댓값/최솟값'을 빠르게 찾아낼 수 있는 특징을 가진 완전 이진 트리의 한 종류입니다. 힙 정렬은 이 힙의 특성을 활용하여 가장 큰(또는 가장 작은) 요소를 반복적으로 추출하여 정렬합니다.

## 1. 동작 방식

힙 정렬은 크게 두 단계로 나뉩니다:

1.  **힙 구성 (Heapify):** 주어진 배열을 힙 구조로 만듭니다. 주로 '최대 힙(Max Heap)'을 구성하여 가장 큰 요소가 항상 루트(root)에 오도록 합니다. (루트 노드에는 항상 자식 노드보다 큰 값이 저장됩니다.)
2.  **정렬 (Sorting):** 힙에서 가장 큰 요소(루트)를 추출하여 배열의 맨 뒤로 보내고, 나머지 요소들로 다시 힙을 구성하는 과정을 반복합니다. 이 과정을 통해 배열은 오름차순으로 정렬됩니다.

### 1.1. 힙 구성 상세 (Max Heap 기준)

- 리프 노드(자식 노드가 없는 노드)는 이미 힙 속성을 만족한다고 봅니다.
- 배열의 마지막 비-리프 노드부터 시작하여 루트 노드까지 역순으로 올라가면서 '힙 구성(heapify)' 작업을 수행합니다.
- `heapify` 함수는 특정 노드를 루트로 하는 서브트리를 힙 속성에 맞게 정렬하는 역할을 합니다. 즉, 현재 노드를 자식 노드들과 비교하여 가장 큰 값을 찾아 루트로 올리는 작업을 수행합니다.

### 1.2. 정렬 상세

- 힙이 구성된 후, 가장 큰 값은 항상 루트(배열의 첫 번째 요소)에 있습니다.
- 루트 요소와 배열의 마지막 요소를 교환합니다. 이제 가장 큰 요소는 정렬될 위치에 놓이게 됩니다.
- 힙의 크기를 1 줄이고 (마지막 요소는 이제 정렬 완료), 교환된 루트 요소에 대해 다시 `heapify` 작업을 수행하여 나머지 요소들로 다시 힙을 구성합니다.
- 이 과정을 힙의 크기가 1이 될 때까지 반복합니다.

## 2. 장점

- **항상 O(N log N)의 시간 복잡도를 보장합니다.** 데이터의 분포에 상관없이 일정한 성능을 보입니다.
- **제자리 정렬(In-place Sorting) 방식입니다.** 추가적인 메모리 공간을 거의 사용하지 않습니다. (단, 재귀 호출을 사용하지 않는 경우)
- **연결 리스트보다는 배열에 더 효율적입니다.**

## 3. 단점

- **안정 정렬(Stable Sort)이 아닙니다.** 동일한 값을 가진 요소들의 상대적 순서가 정렬 후에는 바뀔 수 있습니다.
- **데이터 접근 패턴이 비효율적입니다.** 임의 접근(random access)이 많아 캐시 효율이 좋지 않을 수 있습니다.
- **구현이 다른 O(N log N) 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)에 비해 다소 복잡할 수 있습니다.**

## 4. 시간 복잡도

- **최선 (Best Case):** O(N log N)
- **평균 (Average Case):** O(N log N)
- **최악 (Worst Case):** O(N log N)

## 5. 예제 코드 (JavaScript)

```javascript
function heapSort(arr) {
  let n = arr.length;

  // 1. 최대 힙 구성 (Build Max Heap)
  // 배열의 마지막 비-리프 노드부터 시작하여 루트까지 heapify 호출
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }

  // 2. 힙에서 요소를 하나씩 추출하여 정렬
  for (let i = n - 1; i > 0; i--) {
    // 루트(가장 큰 요소)와 마지막 요소를 교환
    [arr[0], arr[i]] = [arr[i], arr[0]];

    // 교환된 루트에 대해 다시 heapify 호출 (정렬된 요소 제외)
    heapify(arr, i, 0);
  }
  return arr;
}

// 힙 속성을 만족하도록 서브트리를 재구성하는 함수
function heapify(arr, n, i) {
  let largest = i; // 현재 노드를 가장 큰 요소로 가정
  let left = 2 * i + 1; // 왼쪽 자식 노드의 인덱스
  let right = 2 * i + 2; // 오른쪽 자식 노드의 인덱스

  // 왼쪽 자식이 존재하고 현재 가장 큰 요소보다 크면 largest 갱신
  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }

  // 오른쪽 자식이 존재하고 현재 가장 큰 요소보다 크면 largest 갱신
  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }

  // largest가 현재 노드가 아니면 (즉, 자식 중 더 큰 값이 있으면)
  // 가장 큰 요소와 현재 노드를 교환하고, 변경된 서브트리에 대해 재귀적으로 heapify 호출
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, n, largest);
  }
}

// 사용 예시:
// let array = [12, 11, 13, 5, 6, 7];
// console.log("원본 배열:", array); // 원본 배열: [12, 11, 13, 5, 6, 7]
// console.log("정렬된 배열:", heapSort(array)); // 정렬된 배열: [5, 6, 7, 11, 12, 13]
```

**코드 설명:**

1.  **`heapSort` 함수:**

    - `n`은 배열의 길이입니다.
    - **최대 힙 구성:** `for` 루프를 통해 배열의 마지막 부모 노드부터 시작하여 루트 노드까지 `heapify` 함수를 호출합니다. 이 과정을 통해 배열은 최대 힙 구조를 만족하게 됩니다.
    - **정렬:** 두 번째 `for` 루프에서는 `n-1`부터 `1`까지 반복하며, 힙의 루트(가장 큰 값)를 배열의 끝으로 보내고 나머지 요소들로 다시 힙을 구성하는 과정을 반복합니다.

2.  **`heapify` 함수:**
    - 현재 노드 `i`를 루트로 하는 서브트리를 최대 힙 속성에 맞게 만듭니다.
    - `largest` 변수를 사용하여 현재 노드, 왼쪽 자식, 오른쪽 자식 중 가장 큰 값을 가진 노드의 인덱스를 찾습니다.
    - 만약 `largest`가 `i`와 다르다면(즉, 자식 노드 중 더 큰 값이 있다면), `arr[i]`와 `arr[largest]`를 교환하고, `largest`가 된 서브트리에 대해 재귀적으로 `heapify`를 호출하여 힙 속성을 유지합니다.
