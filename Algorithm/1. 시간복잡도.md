# 시간 복잡도

시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간, 즉 알고리즘의 효율성을 나타내는 척도입니다. 입력 크기에 대한 함수로 표현되며, 주로 빅 O 표기법(Big O notation)을 사용하여 나타냅니다. 입력 데이터가 커질 때 알고리즘이 얼마나 느려질지 예측 가능하고 효율적인 알고리즘을 선택하는 데 도움이 됩니다.

## 1. 빅 O 표기법 (Big O Notation)

빅 O 표기법은 알고리즘의 실행 시간이 입력 크기에 따라 어떻게 증가하는지 나타내는 점근적 표기법입니다. 컴퓨터와 프로그래밍 언어에 따라 편차가 크게 달라지기 때문에 명령어의 실행 횟수를 고려합니다.

**예시:**

- `O(1)`: 상수 시간 복잡도 (입력 크기에 관계없이 항상 같은 시간이 소요)
- `O(log n)`: 로그 시간 복잡도 (입력 크기가 커져도 시간이 조금씩 증가)
- `O(n)`: 선형 시간 복잡도 (입력 크기에 비례하여 시간이 증가)
- `O(n log n)`: 선형 로그 시간 복잡도 (정렬 알고리즘 등에서 자주 나타남)
- `O(n^2)`: 제곱 시간 복잡도 (이중 루프 등에서 자주 나타남)
- `O(2^n)`: 지수 시간 복잡도 (매우 비효율적, 작은 입력에서만 사용 가능)
- `O(n!)`: 팩토리얼 시간 복잡도 (가장 비효율적, 거의 사용되지 않음)

## 2. 시간 복잡도 분석 방법

알고리즘의 시간 복잡도를 분석할 때는 다음 사항을 고려합니다:

1.  **반복문:** 반복문의 횟수가 입력 크기 `n`에 따라 어떻게 변하는지 확인합니다.
    - 단일 반복문: `O(n)`
    - 이중 반복문: `O(n^2)`
2.  **재귀 함수:** 재귀 호출의 깊이와 각 호출에서 수행되는 작업량을 분석합니다. 일반적으로 재귀 깊이에 비례하거나, 이진 탐색처럼 탐색 범위가 절반으로 줄어들면 `O(log n)`과 같이 나타납니다.
3.  **조건문:** 최악의 경우(Worst Case)를 고려하여 실행 시간이 가장 오래 걸리는 경로를 따릅니다. 조건문 자체는 `O(1)`이지만, 조건문 내부의 연산이 전체 시간 복잡도에 영향을 미칩니다.
4.  **자료 구조 연산:** 사용되는 자료 구조의 삽입, 삭제, 검색 등의 연산 시간 복잡도를 고려합니다. 예를 들어, 배열의 요소 접근은 `O(1)`, 연결 리스트의 특정 요소 검색은 `O(n)` 등 각 자료 구조마다 고유한 시간 복잡도를 가집니다.

##

<img width="800" height="600" alt="스크린샷 2025-09-06 152302" src="https://github.com/user-attachments/assets/16e30763-f1fd-42b7-ba09-156faa95161a" />

<img width="800" height="700" alt="스크린샷 2025-09-06 155235" src="https://github.com/user-attachments/assets/da425af8-8c4e-487d-9f78-c47d3579873e" />
