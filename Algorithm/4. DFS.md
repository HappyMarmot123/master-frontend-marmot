# 깊이 우선 탐색 (DFS, Depth-First Search)

**DFS**는 그래프의 모든 노드를 탐색하기 위한 알고리즘으로, 이름 그대로 깊이를 우선하여 탐색합니다. 루트 노드에서 시작해 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식입니다. 더 이상 방문할 노드가 없으면 다른 자식 노드를 탐색합니다.

### 특징

- **스택(Stack)** 자료구조 또는 **재귀 함수**를 이용하여 구현됩니다. (재귀 호출이 내부적으로 함수 호출 스택을 사용합니다.)
- 한 경로를 끝까지 탐색한 후에야 다른 경로를 탐색하므로, 시작점에서 가장 멀리 있는 노드를 먼저 방문할 수도 있습니다.
- 최단 경로를 보장하지 않습니다.

### 동작 방식

1. 탐색을 시작할 노드를 스택에 넣고, 방문 처리합니다.
2. 스택의 최상단에 있는 노드를 확인합니다.
3. 해당 노드에 연결된 인접 노드 중 아직 방문하지 않은 노드가 있다면, 그 노드를 스택에 넣고 방문 처리합니다.
4. 만약 방문하지 않은 인접 노드가 없다면, 스택에서 현재 노드를 꺼냅니다(pop).
5. 스택이 비어있을 때까지 2-4번 과정을 반복합니다.

### 예제 코드 (JavaScript - 인접 리스트, 재귀)

```javascript
const graphDFS = {
  A: ["B", "C"],
  B: ["A", "D", "E"],
  C: ["A", "F"],
  D: ["B"],
  E: ["B", "F"],
  F: ["C", "E"],
};

function dfs(graph, startNode) {
  const visited = new Set(); // 방문 여부를 기록할 객체
  const result = []; // 탐색 순서를 기록할 배열

  function _dfsRecursive(node) {
    if (visited.has(node)) return; // 방문한 노드는 패스
    visited.add(node); // 현재 노드 방문 처리
    result.push(node); // 결과에 추가

    graph[node].forEach((item) => {
      _dfsRecursive(item); // 재귀적으로 탐색
    });
  }

  _dfsRecursive(startNode);
  return result;
}

console.log(dfs(graphDFS, "A")); // 예상 출력: ['A', 'B', 'D', 'E', 'F', 'C']
```

"순서를 바꾸지 않고 적절히 연산"  
"가능한 모든 방법의 수를 찾기"  
DFS나 BFS는 시작점 에서부터 모든 경로를 탐색하므로 모든 경우의 수를 누락 없이 확인하는 데 최적화되어 있습니다.

```javascript
function solution(numbers, target) {
    let answer = 0;

    function dfs(index, sum) {
        if (index >= numbers.length) {
            if (sum === target) answer++;
            return
        }

        const currentNumber = numbers[index];
        dfs(index + 1, sum + currentNumber);
        dfs(index + 1, sum - currentNumber);
    }
    dfs(0,0)
    return answer;
}

1	1 1 1 1 1	+1+1+1+1+1	5	×
2	1 1 1 1 0	+1+1+1+1−1	3	O
3	1 1 1 0 1	+1+1+1−1+1	3	O
4	1 1 1 0 0	+1+1+1−1−1	1	×
---	---	---	---	---
5	1 1 0 1 1	+1+1−1+1+1	3	O
6	1 1 0 1 0	+1+1−1+1−1	1	×
7	1 1 0 0 1	+1+1−1−1+1	1	×
8	1 1 0 0 0	+1+1−1−1−1	-1	×
---	---	---	---	---
9	1 0 1 1 1	+1−1+1+1+1	3	O
10	1 0 1 1 0	+1−1+1+1−1	1	×
```

```javascript
만약 2차원 배열을 다뤄야 할 경우
[[1, 1, 0], [1, 1, 0], [0, 0, 1]]


function solution(n, computers) {
    let networkCount = 0;
    const visited = Array(n).fill(false);

    function dfs(index) {
        visited[index] = true;

        for (let j = 0; j < n; j++) {
            if (computers[index][j] && !visited[j]) {
                dfs(j);
            }
        }
    }

    for (let i = 0; i < n; i++) {
        if(!visited[i]) {
            dfs(i);
            networkCount++;
        }
    }

    return networkCount;
}
```
