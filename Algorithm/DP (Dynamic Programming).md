# 동적 계획법 (Dynamic Programming, DP)

동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 여러 개의 작은 부분 문제로 나누어 해결하는 알고리즘 설계 기법입니다. 이 부분 문제들을 한 번만 풀고 그 결과를 저장해 둠으로써, 같은 부분 문제가 다시 나타날 때 재계산하지 않고 저장된 결과를 재활용하여 전체 문제의 효율적인 해결을 가능하게 합니다. 특히, 최적화 문제나 경우의 수를 세는 문제에서 주로 사용됩니다.

## 1. 기본 개념

동적 계획법이 적용될 수 있는 문제들은 두 가지 중요한 속성을 가집니다.

1.  **최적 부분 구조 (Optimal Substructure):** 전체 문제의 최적 해가 부분 문제의 최적 해들로 구성될 수 있는 경우를 말합니다. 즉, 큰 문제의 해답은 작은 문제의 해답에 의존합니다.
2.  **중복되는 부분 문제 (Overlapping Subproblems):** 동일한 부분 문제가 반복적으로 나타나는 경우를 말합니다. 이 중복되는 부분 문제의 결과를 저장하여 재활용하는 것이 DP의 핵심입니다.

## 2. 동작 방식

동적 계획법을 구현하는 주요 두 가지 방법은 다음과 같습니다.

### 2.1. 메모이제이션 (Memoization - 탑다운 방식)

- **개념:** 재귀 함수를 사용하여 문제를 해결하되, 한 번 계산한 부분 문제의 결과를 메모(배열, 맵 등)에 저장해 두었다가 다시 필요할 때 가져다 쓰는 방식입니다. '하향식' 또는 '탑다운' 방식으로도 불립니다.
- **특징:**
  - 재귀적으로 큰 문제에서 작은 문제로 내려가면서 해결합니다.
  - 모든 부분 문제를 계산하지 않고, 필요한 부분 문제만 계산합니다.
  - 스택 오버플로우가 발생할 수 있습니다.

### 2.2. 타뷸레이션 (Tabulation - 바텀업 방식)

- **개념:** 가장 작은 부분 문제부터 시작하여 점진적으로 큰 문제의 해답을 찾아나가는 방식입니다. 반복문을 사용하여 테이블(배열)에 부분 문제의 해답을 채워나갑니다. '상향식' 또는 '바텀업' 방식으로도 불립니다.
- **특징:**
  - 반복문을 사용하여 작은 문제에서 큰 문제로 올라가면서 해결합니다.
  - 일반적으로 모든 부분 문제를 계산합니다.
  - 스택 오버플로우 걱정이 없습니다.

## 3. 장점

- **효율성:** 중복되는 계산을 제거하여 시간 복잡도를 크게 줄일 수 있습니다.
- **복잡한 문제 해결:** 최적 부분 구조와 중복되는 부분 문제가 있는 복잡한 문제를 효과적으로 해결할 수 있습니다.
- **재귀 방식보다 메모리 효율적일 수 있음:** (타뷸레이션의 경우) 불필요한 스택 공간을 사용하지 않습니다.

## 4. 단점

- **문제 식별의 어려움:** 어떤 문제가 DP로 해결될 수 있는지 파악하기 어렵고, 최적 부분 구조와 중복되는 부분 문제를 찾아내는 통찰력이 필요합니다.
- **초기 상태 설정:** 테이블의 초기 값을 설정하는 것이 까다로울 수 있습니다.
- **메모리 사용:** 모든 부분 문제의 해답을 저장해야 하므로 추가적인 메모리 공간이 필요합니다.

## 5. 시간 복잡도

일반적으로 동적 계획법의 시간 복잡도는 `(부분 문제의 수) * (각 부분 문제를 해결하는 데 걸리는 시간)`으로 결정됩니다. 많은 경우 다항 시간(Polynomial Time) 내에 문제를 해결할 수 있습니다. (예: O(N), O(N^2), O(N\*K) 등)

## 6. 예제 코드 (JavaScript - 피보나치 수열)

피보나치 수열은 대표적인 동적 계획법 예제입니다. `F(n) = F(n-1) + F(n-2)` 이고 `F(0) = 0`, `F(1) = 1` 입니다.

### 6.1. 메모이제이션 (탑다운)

```javascript
function fibMemo(n, memo = {}) {
  if (n in memo) return memo[n]; // 이미 계산된 값이 있으면 반환
  if (n <= 1) return n;

  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); // 결과 저장
  return memo[n];
}

// 사용 예시:
// console.log("fibMemo(10):", fibMemo(10)); // fibMemo(10): 55
// console.log("fibMemo(30):", fibMemo(30)); // fibMemo(30): 832040
```

**코드 설명:**

1.  `memo` 객체를 사용하여 이미 계산된 피보나치 값을 저장합니다.
2.  함수가 호출될 때 `memo`에 `n`에 대한 값이 있는지 확인하고, 있으면 바로 반환합니다.
3.  없으면 재귀적으로 `fibMemo(n-1)`과 `fibMemo(n-2)`를 호출하여 계산하고, 그 결과를 `memo[n]`에 저장한 후 반환합니다.

### 6.2. 타뷸레이션 (바텀업)

```javascript
function fibTab(n) {
  if (n <= 1) return n;

  const dp = new Array(n + 1); // 결과를 저장할 배열
  dp[0] = 0;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]; // 작은 문제부터 해결하여 dp 배열 채우기
  }
  return dp[n];
}

// 사용 예시:
// console.log("fibTab(10):", fibTab(10)); // fibTab(10): 55
// console.log("fibTab(30):", fibTab(30)); // fibTab(30): 832040
```

**코드 설명:**

1.  `dp` 배열을 생성하고 `dp[0]`와 `dp[1]`를 초기화합니다.
2.  `for` 루프를 사용하여 `i = 2`부터 `n`까지 반복합니다.
3.  각 `i`에 대해 `dp[i] = dp[i - 1] + dp[i - 2]`를 계산하여 `dp` 배열을 채워나갑니다. 이는 이전에 계산된 작은 부분 문제의 결과를 활용하는 것입니다.
4.  최종적으로 `dp[n]`에 `n`번째 피보나치 값이 저장되어 반환됩니다.
