# 이진 탐색 (Binary Search)

이진 탐색은 **정렬된 배열(또는 리스트)**에서 특정 값(타겟)을 찾는 데 사용되는 효율적인 탐색 알고리즘입니다. 배열의 중간 값을 타겟 값과 비교하여, 타겟 값이 더 작으면 왼쪽 절반을, 더 크면 오른쪽 절반을 대상으로 탐색을 계속합니다. 이 과정을 반복하면서 탐색 범위를 절반씩 줄여나가므로 값을 빠르게 찾을 수 있습니다.

## 1. 동작 방식

이진 탐색은 다음 단계를 통해 이루어집니다:

1.  **탐색 범위 설정:** 배열의 가장 왼쪽 인덱스(`low`)와 가장 오른쪽 인덱스(`high`)를 설정하여 초기 탐색 범위를 지정합니다.
2.  **중간 값 계산:** `low`와 `high`의 중간 인덱스(`mid`)를 계산합니다. `mid = Math.floor((low + high) / 2)`
3.  **타겟과 중간 값 비교:**
    - 만약 `arr[mid]`가 타겟과 같으면, 탐색 성공! `mid`를 반환합니다.
    - 만약 `arr[mid]`가 타겟보다 작으면, 타겟은 `mid`의 오른쪽에 있으므로 `low`를 `mid + 1`로 업데이트하여 탐색 범위를 오른쪽 절반으로 좁힙니다.
    - 만약 `arr[mid]`가 타겟보다 크면, 타겟은 `mid`의 왼쪽에 있으므로 `high`를 `mid - 1`로 업데이트하여 탐색 범위를 왼쪽 절반으로 좁힙니다.
4.  **반복:** `low`가 `high`보다 작거나 같을 때까지 2~3단계를 반복합니다.
5.  **탐색 실패:** `low`가 `high`보다 커지면 탐색 범위에 더 이상 원소가 없다는 의미이므로, 배열에 타겟 값이 없는 것으로 간주하고 `-1`을 반환합니다.

**핵심:** 탐색할 때마다 탐색 범위가 절반으로 줄어든다는 점입니다.

## 2. 장점

- **매우 빠른 탐색 속도:** O(log N)의 시간 복잡도를 가지므로 대규모 데이터셋에서 선형 탐색(O(N))보다 훨씬 빠릅니다.
- **구현이 상대적으로 간단합니다.**

## 3. 단점

- **반드시 정렬된 배열이어야 합니다.** 정렬되지 않은 배열에는 이진 탐색을 적용할 수 없습니다. (정렬하는 데 추가적인 시간 복잡도가 발생할 수 있습니다.)
- **삽입/삭제가 비효율적입니다.** 배열 중간에 값을 삽입하거나 삭제하면 정렬 상태를 유지하기 위해 많은 요소들을 이동시켜야 합니다.

## 4. 시간 복잡도

- **최선 (Best Case):** O(1) - 중간 값이 바로 타겟과 일치하는 경우.
- **평균 (Average Case):** O(log N)
- **최악 (Worst Case):** O(log N)

## 5. 예제 코드 (JavaScript)

```javascript
function binarySearch(arr, target) {
  let low = 0;
  let high = arr.length - 1;

  while (low <= high) {
    let mid = Math.floor((low + high) / 2);

    if (arr[mid] === target) {
      return mid; // 타겟을 찾으면 인덱스 반환
    } else if (arr[mid] < target) {
      low = mid + 1; // 타겟이 중간 값보다 크면 오른쪽 절반 탐색
    } else {
      high = mid - 1; // 타겟이 중간 값보다 작으면 왼쪽 절반 탐색
    }
  }

  return -1; // 타겟을 찾지 못하면 -1 반환
}

// 사용 예시:
// let sortedArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// console.log("7의 인덱스:", binarySearch(sortedArray, 7)); // 7의 인덱스: 6
// console.log("1의 인덱스:", binarySearch(sortedArray, 1)); // 1의 인덱스: 0
// console.log("10의 인덱스:", binarySearch(sortedArray, 10)); // 10의 인덱스: 9
// console.log("11의 인덱스:", binarySearch(sortedArray, 11)); // 11의 인덱스: -1 (찾지 못함)
```

**코드 설명:**

정렬된 배열 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`에서 타겟 `7`을 찾는 과정입니다.

1. **초기 상태**

   - `low = 0`, `high = 9`
   - `mid = floor((0 + 9) / 2) = 4`
   - `arr[4]`는 `5`입니다. `7 > 5`이므로 `low`를 `mid + 1`인 `5`로 변경합니다.

2. **탐색 범위 [5...9]**

   - `low = 5`, `high = 9`
   - `mid = floor((5 + 9) / 2) = 7`
   - `arr[7]`은 `8`입니다. `7 < 8`이므로 `high`를 `mid - 1`인 `6`으로 변경합니다.

3. **탐색 범위 [5...6]**

   - `low = 5`, `high = 6`
   - `mid = floor((5 + 6) / 2) = 5`
   - `arr[5]`는 `6`입니다. `7 > 6`이므로 `low`를 `mid + 1`인 `6`으로 변경합니다.

4. **탐색 범위 [6...6]**

   - `low = 6`, `high = 6`
   - `mid = floor((6 + 6) / 2) = 6`
   - `arr[6]`은 `7`입니다. 타겟을 찾았으므로 인덱스 `6`을 반환합니다.
