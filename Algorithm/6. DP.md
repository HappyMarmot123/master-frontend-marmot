# 동적 계획법 (Dynamic Programming, DP)

복잡한 문제를 여러 개의 작은 부분 문제로 나누어 해결하는 알고리즘 설계 기법입니다. 이 부분 문제들을 한 번만 풀고 그 결과를 저장해 둠으로써, 같은 부분 문제가 다시 나타날 때 재계산하지 않고 저장된 결과를 재활용하여 전체 문제의 해결을 효율적으로 만듭니다.

### 기본 개념

동적 계획법이 적용될 수 있는 문제들은 두 가지 중요한 속성을 가집니다.

1. **최적 부분 구조 (Optimal Substructure):** 전체 문제의 최적해가 부분 문제들의 최적해로 구성될 수 있는 경우를 말합니다. 즉, 큰 문제의 최적해는 작은 문제들의 최적해를 통해 구할 수 있습니다.
2. **중복되는 부분 문제 (Overlapping Subproblems):** 동일한 부분 문제가 반복적으로 나타나는 경우를 말합니다. 이 중복되는 부분 문제의 결과를 저장하여 재활용하는 것이 DP의 핵심입니다.

### 피보나치 수열

피보나치 수열은 동적 계획법(DP)의 개념을 설명하는 가장 대표적인 예시 중 하나입니다. DP는 큰 문제를 작은 부분 문제로 나누어 해결하고, 부분 문제의 해답을 저장하여 재사용함으로써 효율을 높이는 기법입니다.

- 피보나치 수열은 **이전 두 항의 합이 다음 항이 되는 수열**을 말합니다. 점화식으로는 `F(n) = F(n-1) + F(n-2)`로 표현되며, 일반적으로 `F(0)=0`과 `F(1)=1`을 초기값으로 설정합니다.

> (0, 1, 1, 2, 3, 5, 8, 13, 21, ...)

이 수열은 간단한 규칙을 가지면서도, 재귀적으로 계산할 때 동일한 계산이 반복적으로 발생하여 동적 계획법(DP)의 원리를 설명하는 대표적인 예제로 사용됩니다.

### 탑다운

```javascript
function fibMemo(n, memo = {}) {
  // 1. 이미 계산한 값이 있으면 바로 반환 (캐시 확인)
  if (n in memo) {
    return memo[n];
  }
  // 2. 기본 조건 (n이 0 또는 1일 경우)
  if (n <= 1) {
    return n;
  }
  // 3. 계산 후 결과 저장 (메모이제이션)
  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
  return memo[n];
}

// 사용 예시:
console.log("fibMemo(10):", fibMemo(10)); // fibMemo(10): 55
```

**`fibMemo(10)`이 `55`를 반환하는 이유:**

피보나치 수열은 `F(n) = F(n-1) + F(n-2)`의 규칙을 따릅니다. `F(0)=0`, `F(1)=1`을 시작으로,

- `F(0) = 0`
- `F(1) = 1`
- `F(2) = F(1) + F(0) = 1 + 0 = 1`
- `F(3) = F(2) + F(1) = 1 + 1 = 2`
- `F(4) = F(3) + F(2) = 2 + 1 = 3`
- `F(5) = F(4) + F(3) = 3 + 2 = 5`
- `F(6) = F(5) + F(4) = 5 + 3 = 8`
- `F(7) = F(6) + F(5) = 8 + 5 = 13`
- `F(8) = F(7) + F(6) = 13 + 8 = 21`
- `F(9) = F(8) + F(7) = 21 + 13 = 34`
- `F(10) = F(9) + F(8) = 34 + 21 = 55`

따라서 `fibMemo(10)`을 호출하면 위 과정을 통해 `55`가 계산되어 반환됩니다. 메모이제이션을 통해 중복 계산 없이 효율적으로 이 값을 얻을 수 있습니다.
