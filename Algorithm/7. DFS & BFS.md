# 깊이 우선 탐색 (DFS) & 너비 우선 탐색 (BFS)

깊이 우선 탐색(DFS, Depth-First Search)과 너비 우선 탐색(BFS, Breadth-First Search)은 그래프 또는 트리와 같은 자료 구조를 탐색하는 두 가지 기본적인 알고리즘입니다. 이 두 알고리즘은 데이터를 방문하는 순서와 사용하는 자료 구조에서 차이를 보입니다.

## 1. 깊이 우선 탐색 (DFS, Depth-First Search)

**DFS**는 그래프의 모든 노드를 탐색하기 위한 알고리즘으로, 이름 그대로 깊이를 우선하여 탐색합니다. 루트 노드(또는 임의의 시작 노드)에서 시작해 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식입니다. 즉, 자식 노드를 따라가다가 더 이상 방문할 노드가 없으면, 부모 노드로 돌아가 다른 자식 노드를 탐색합니다.

### 특징

- **스택(Stack)** 자료구조 또는 **재귀 함수**를 이용하여 구현됩니다. (재귀 호출이 내부적으로 함수 호출 스택을 사용합니다.)
- 한 경로를 끝까지 탐색한 후에야 다른 경로를 탐색하므로, 시작점에서 가장 멀리 있는 노드를 먼저 방문할 수도 있습니다.
- 최단 경로를 보장하지 않습니다.

### 동작 방식

1. 탐색을 시작할 노드를 스택에 넣고, 방문 처리합니다.
2. 스택의 최상단에 있는 노드를 확인합니다.
3. 해당 노드에 연결된 인접 노드 중 아직 방문하지 않은 노드가 있다면, 그 노드를 스택에 넣고 방문 처리합니다.
4. 만약 방문하지 않은 인접 노드가 없다면, 스택에서 현재 노드를 꺼냅니다(pop).
5. 스택이 비어있을 때까지 2-4번 과정을 반복합니다.

### 예제 코드 (JavaScript - 인접 리스트, 재귀)

```javascript
const graphDFS = {
  A: ["B", "C"],
  B: ["A", "D", "E"],
  C: ["A", "F"],
  D: ["B"],
  E: ["B", "F"],
  F: ["C", "E"],
};

function dfs(graph, startNode) {
  const visited = {}; // 방문 여부를 기록할 객체
  const result = []; // 탐색 순서를 기록할 배열

  function _dfsRecursive(node) {
    visited[node] = true; // 현재 노드 방문 처리
    result.push(node); // 결과에 추가

    for (const neighbor of graph[node]) {
      if (!visited[neighbor]) {
        // 방문하지 않은 인접 노드라면
        _dfsRecursive(neighbor); // 재귀적으로 탐색
      }
    }
  }

  _dfsRecursive(startNode);
  return result;
}

// 사용 예시:
// console.log("DFS 탐색 순서:", dfs(graphDFS, 'A')); // DFS 탐색 순서: ['A', 'B', 'D', 'E', 'F', 'C']
```

**코드 설명:**

1. `graphDFS`: 인접 리스트 형태로 그래프를 정의합니다.
2. `dfs` 함수:
   - `visited` 객체는 노드의 방문 여부를 추적합니다.
   - `result` 배열은 탐색 순서를 저장합니다.
   - `_dfsRecursive`는 재귀적으로 DFS를 수행하는 내부 함수입니다.
   - `_dfsRecursive`는 현재 노드를 방문 처리하고 `result`에 추가합니다.
   - 현재 노드의 모든 인접 노드를 순회하며, 아직 방문하지 않은 인접 노드가 있다면 재귀적으로 `_dfsRecursive`를 호출합니다.

## 2. 너비 우선 탐색 (BFS, Breadth-First Search)

**BFS**는 그래프의 모든 노드를 탐색하기 위한 알고리즘으로, 이름 그대로 너비를 우선하여 탐색합니다. 루트 노드(또는 임의의 시작 노드)에서 시작하여, 가까운 노드를 먼저 방문하고 더 멀리 있는 노드를 나중에 방문하는 방식입니다. 더 작은 문제를 먼저 해결함으로 큰 문제를 해결합니다.

### 특징

- **큐(Queue)** 자료구조를 이용하여 구현됩니다. (FIFO: First-In, First-Out)
- 시작 노드에서부터 거리가 가까운 순서대로, 즉 레벨(level) 순으로 노드를 탐색합니다.
- **가중치가 없는 그래프**에서 두 노드 간의 최단 경로를 찾는 데 사용될 수 있습니다.

### 동작 원리

1. 탐색을 시작할 노드를 큐에 넣고, 방문 처리합니다.
2. 큐가 비어있을 때까지 다음 과정을 반복합니다.
3. 큐에서 노드를 하나 꺼냅니다(dequeue).
4. 해당 노드에 연결된 인접 노드 중 아직 방문하지 않은 모든 노드를 큐에 넣고(enqueue), 방문 처리합니다.

### 단점

- **DFS보다 많은 메모리 사용:** 큐에 많은 노드를 저장해야 할 수 있어 DFS보다 더 많은 메모리를 사용할 수 있습니다.
- **구현이 다소 복잡할 수 있습니다.** (재귀 대신 반복문과 큐를 명시적으로 사용해야 하므로)

### 예제 코드 (JavaScript - 인접 리스트, 큐)

```javascript
const graphBFS = {
  A: ["B", "C"],
  B: ["A", "D", "E"],
  C: ["A", "F"],
  D: ["B"],
  E: ["B", "F"],
  F: ["C", "E"],
};

function bfs(graph, startNode) {
  const visited = {}; // 방문 여부를 기록할 객체
  const queue = []; // 탐색할 노드를 저장할 큐
  const result = []; // 탐색 순서를 기록할 배열

  visited[startNode] = true; // 시작 노드 방문 처리
  queue.push(startNode); // 큐에 시작 노드 추가

  while (queue.length > 0) {
    const node = queue.shift(); // 큐에서 노드 꺼내기
    result.push(node); // 결과에 추가

    for (const neighbor of graph[node]) {
      if (!visited[neighbor]) {
        // 방문하지 않은 인접 노드라면
        visited[neighbor] = true; // 방문 처리
        queue.push(neighbor); // 큐에 추가
      }
    }
  }
  return result;
}

// 사용 예시:
// console.log("BFS 탐색 순서:", bfs(graphBFS, 'A')); // BFS 탐색 순서: ['A', 'B', 'C', 'D', 'E', 'F']
```

**코드 설명:**

1. `graphBFS`: 인접 리스트 형태로 그래프를 정의합니다.
2. `bfs` 함수:
   - `visited` 객체는 노드의 방문 여부를 추적합니다.
   - `queue` 배열은 다음에 방문할 노드들을 저장하는 큐로 사용됩니다 (`shift()`와 `push()`를 이용).
   - `result` 배열은 탐색 순서를 저장합니다.
   - 시작 노드를 방문 처리하고 큐에 추가합니다.
   - `while` 루프는 큐가 빌 때까지 반복됩니다.
   - 큐에서 노드를 하나 꺼내 `result`에 추가합니다.
   - 꺼낸 노드의 모든 인접 노드를 순회하며, 방문하지 않은 노드가 있다면 방문 처리하고 큐에 추가합니다.

## 3. DFS vs BFS 비교

| 특징              | 깊이 우선 탐색 (DFS)                            | 너비 우선 탐색 (BFS)                                       |
| :---------------- | :---------------------------------------------- | :--------------------------------------------------------- |
| **탐색 방식**     | 깊이를 우선하여 탐색                            | 너비를 우선하여 탐색                                       |
| **구현 자료구조** | 스택 (Stack) 또는 재귀                          | 큐 (Queue)                                                 |
| **최단 경로**     | 보장하지 않음                                   | 보장 (가중치가 없는 그래프의 경우)                         |
| **경로 특징**     | 가능한 한 멀리 가는 경로 탐색                   | 시작점에서 가까운 경로 먼저 탐색                           |
| **메모리 사용**   | 상대적으로 적음 (깊이에 비례)                   | 상대적으로 많음 (너비에 비례)                              |
| **활용 예시**     | 미로에서 모든 경로 탐색, 사이클 탐지, 위상 정렬 | 최단 경로 탐색(미로 찾기), 소셜 네트워크 연결 관계 분석 등 |
