# 동적 계획법 (Dynamic Programming, DP)

동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 여러 개의 작은 부분 문제로 나누어 해결하는 알고리즘 설계 기법입니다. 이 부분 문제들을 한 번만 풀고 그 결과를 저장해 둠으로써, 같은 부분 문제가 다시 나타날 때 재계산하지 않고 저장된 결과를 재활용하여 전체 문제의 해결을 효율적으로 만듭니다. 특히, 최적화 문제나 경우의 수를 세는 문제에서 주로 사용됩니다.

## 1. 기본 개념

동적 계획법이 적용될 수 있는 문제들은 두 가지 중요한 속성을 가집니다.

1. **최적 부분 구조 (Optimal Substructure):** 전체 문제의 최적해가 부분 문제들의 최적해로 구성될 수 있는 경우를 말합니다. 즉, 큰 문제의 최적해는 작은 문제들의 최적해를 통해 구할 수 있습니다.
2. **중복되는 부분 문제 (Overlapping Subproblems):** 동일한 부분 문제가 반복적으로 나타나는 경우를 말합니다. 이 중복되는 부분 문제의 결과를 저장하여 재활용하는 것이 DP의 핵심입니다.

## 2. 동작 방식

동적 계획법을 구현하는 주요 두 가지 방법은 다음과 같습니다.

### 2.1. 메모이제이션 (Memoization - 탑다운 방식)

- **개념:** 재귀 함수를 사용하여 문제를 해결하되, 한 번 계산한 부분 문제의 결과를 메모(배열, 맵 등)에 저장해 두었다가 다시 필요할 때 가져다 쓰는 방식입니다. '하향식' 또는 '탑다운' 방식으로도 불립니다.
- **특징:**
  - 재귀적으로 큰 문제에서 작은 문제로 내려가면서 해결합니다.
  - 모든 문제를 계산하지 않고, 필요한 부분 문제만 계산합니다.
  - 스택 오버플로우가 발생할 수 있습니다.

### 2.2. 타뷸레이션 (Tabulation - 바텀업 방식)

- **개념:** 가장 작은 부분 문제부터 시작하여 점진적으로 큰 문제의 해답을 찾아나가는 방식입니다. 반복문을 사용하여 테이블(배열)에 부분 문제의 해답을 채워나갑니다. '상향식' 또는 '바텀업' 방식으로도 불립니다.
- **특징:**
  - 반복문을 사용하여 작은 문제에서 큰 문제로 올라가면서 해결합니다.
  - 일반적으로 모든 부분 문제를 계산합니다.
  - 스택 오버플로우 걱정이 없습니다.

---

### 피보나치 수열

피보나치 수열은 동적 계획법(DP)의 개념을 설명하는 가장 대표적인 예시 중 하나입니다. DP는 큰 문제를 작은 부분 문제로 나누어 해결하고, 부분 문제의 해답을 저장하여 재사용함으로써 효율을 높이는 기법입니다.

- 피보나치 수열은 **이전 두 항의 합이 다음 항이 되는 수열**을 말합니다. 점화식으로는 `F(n) = F(n-1) + F(n-2)`로 표현되며, 일반적으로 `F(0)=0`과 `F(1)=1`을 초기값으로 설정합니다.

> (0, 1, 1, 2, 3, 5, 8, 13, 21, ...)

이 수열은 간단한 규칙을 가지면서도, 재귀적으로 계산할 때 동일한 계산이 반복적으로 발생하여 동적 계획법(DP)의 원리를 설명하는 대표적인 예제로 사용됩니다.

### 메모이제이션 (탑다운)

```javascript
function fibMemo(n, memo = {}) {
  if (n in memo) return memo[n]; // 이미 계산된 값이 있으면 반환
  if (n <= 1) return n;

  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); // 결과 저장
  return memo[n];
}

// 사용 예시:
// console.log("fibMemo(10):", fibMemo(10)); // fibMemo(10): 55
// console.log("fibMemo(30):", fibMemo(30)); // fibMemo(30): 832040
```

**코드 설명:**

1. `memo` 객체를 사용하여 이미 계산된 피보나치 값을 저장합니다.
2. 함수가 호출될 때 `memo`에 `n`에 대한 값이 있는지 확인하고, 있으면 바로 반환합니다.
3. 없으면 재귀적으로 `fibMemo(n-1)`과 `fibMemo(n-2)`를 호출하여 계산하고, 그 결과를 `memo[n]`에 저장한 후 반환합니다.

### 타뷸레이션 (바텀업)

```javascript
function fibTab(n) {
  if (n <= 1) return n;

  const dp = new Array(n + 1); // 결과를 저장할 배열
  dp[0] = 0;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]; // 작은 문제부터 해결하여 dp 배열 채우기
  }
  return dp[n];
}

// 사용 예시:
// console.log("fibTab(10):", fibTab(10)); // fibTab(10): 55
// console.log("fibTab(30):", fibTab(30)); // fibTab(30): 832040
```

**코드 설명:**

1. `dp` 배열을 생성하고 `dp[0]`와 `dp[1]`를 초기화합니다.
2. `for` 루프를 사용하여 `i = 2`부터 `n`까지 반복합니다.
3. 각 `i`에 대해 `dp[i] = dp[i - 1] + dp[i - 2]`를 계산하여 `dp` 배열을 채워나갑니다. 이는 이전에 계산된 작은 부분 문제의 결과를 활용하는 것입니다.
4. 최종적으로 `dp[n]`에 `n`번째 피보나치 값이 저장되어 반환됩니다.
