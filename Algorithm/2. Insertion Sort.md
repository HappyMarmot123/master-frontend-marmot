# 삽입 정렬 (Insertion Sort)

삽입 정렬은 **이미 정렬된 부분**과 **아직 정렬되지 않은 부분**으로 나누어, 정렬되지 않은 부분의 원소를 하나씩 꺼내 이미 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘입니다.

## 1. 동작 방식

1. 두 번째 원소부터 시작하여, 현재 원소를 `key` 값으로 설정합니다.
2. `key` 값을 이미 정렬된 배열 부분(`key`의 왼쪽에 있는 원소들)과 비교합니다.
3. `key` 값보다 큰 원소들을 오른쪽으로 한 칸씩 이동시킵니다.
4. 자신보다 작거나 같은 원소를 만나거나 배열의 맨 앞에 도달하면, 그 바로 뒷자리에 `key` 값을 삽입합니다.
5. 배열의 마지막 원소까지 이 과정을 반복합니다.

## 2. 시간 복잡도

- **최선**: `O(n)` - 이미 데이터가 정렬된 경우, 외부 루프만 순회하므로 선형 시간이 걸립니다.
- **평균**: `O(n²)`
- **최악**: `O(n²)` - 데이터가 역순으로 정렬된 경우, 모든 원소가 최대 비교와 이동을 수행해야 합니다.

**안정 정렬(Stable Sort)** 이므로 중복된 값의 순서가 유지됩니다. 제자리 정렬(In-place sort)이므로 추가적인 메모리 공간이 거의 필요 없으며, 이미 정렬되었거나 거의 정렬된 데이터에 대해서는 매우 효율적입니다. 단, 데이터의 양이 많아질수록 성능이 급격히 저하됩니다.

## 3. 예제 코드 (JavaScript)

```javascript
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i]; // 현재 삽입할 요소
    let j = i - 1; // 정렬된 부분 배열의 마지막 인덱스

    // 현재 요소(current)가 정렬된 부분 배열의 요소(arr[j])보다 작으면
    // arr[j]를 오른쪽으로 한 칸 이동시키고 j를 감소시킴
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }
    // 올바른 위치에 current 삽입
    arr[j + 1] = current;
  }
  return arr;
}

// 사용 예시:
// let array = [12, 11, 13, 5, 6];
// console.log("원본 배열:", array); // 원본 배열: [12, 11, 13, 5, 6]
// console.log("정렬된 배열:", insertionSort(array)); // 정렬된 배열: [5, 6, 11, 12, 13]
```

**코드 설명:**

1. `for` 루프는 두 번째 요소부터(`i = 1`) 배열의 끝까지 반복합니다.
2. `current` 변수에 현재 삽입할 요소를 저장하고, `j`는 `current`의 바로 왼쪽(이미 정렬된 부분)을 가리킵니다.
3. `while` 루프는 `j`가 배열의 시작(`0`)보다 크거나 같고, `arr[j]`가 `current`보다 크면 계속됩니다.
4. 이 조건이 참이면, `arr[j]`를 한 칸 오른쪽(`arr[j + 1]`)으로 이동시키고 `j`를 감소시켜 왼쪽으로 이동합니다.
5. `while` 루프가 끝나면 `current`가 들어갈 올바른 위치(`j + 1`)가 정해지며, 그곳에 `current`를 삽입합니다.
6. 모든 요소에 대해 이 과정을 반복하면 배열이 완전히 정렬됩니다.
