# 퀵 정렬 (Quick Sort)

퀵 정렬은 대표적인 분할 정복(Divide and Conquer) 방식의 정렬 알고리즘으로, 평균적으로 가장 빠른 정렬 속도를 자랑합니다. 'pivot'이라는 기준 요소를 선정하여 이보다 작은 요소는 왼쪽으로, 큰 요소는 오른쪽으로 분할한 다음, 각 부분 배열에 대해 재귀적으로 퀵 정렬을 수행하여 전체 배열을 정렬합니다.

## 1. 동작 방식

퀵 정렬의 핵심은 **피벗(pivot) 선택**과 **분할(partitioning)** 과정에 있습니다.

1.  **피벗 선택:** 배열 내에서 하나의 요소를 피벗으로 선택합니다. 피벗은 보통 배열의 첫 번째, 마지막, 중간 요소 또는 무작위로 선택될 수 있습니다.
2.  **분할(Partitioning):** 피벗을 기준으로 배열을 두 개의 부분 배열로 나눕니다.
    - 피벗보다 작거나 같은 요소들은 피벗의 왼쪽으로 이동합니다.
    - 피벗보다 큰 요소들은 피벗의 오른쪽으로 이동합니다.
    - 이 과정을 통해 피벗은 최종 정렬 위치에 놓이게 됩니다.
3.  **재귀 호출:** 피벗의 왼쪽 부분 배열과 오른쪽 부분 배열에 대해 재귀적으로 퀵 정렬을 다시 호출합니다. 이 과정은 부분 배열의 크기가 1이하가 될 때까지 반복됩니다.

## 2. 장점

- **평균적으로 가장 빠릅니다.** 대규모 데이터셋에 대한 정렬에 효율적입니다.
- **제자리 정렬(In-place Sorting) 방식입니다.** 대부분의 정렬이 추가적인 메모리 공간을 거의 사용하지 않습니다.
- **캐시 효율이 좋습니다.** 지역성(locality)이 있어 메모리 캐시의 이점을 잘 활용할 수 있습니다.

## 3. 단점

- **최악의 경우 성능이 매우 나쁩니다.** 피벗 선택이 잘못되어 배열이 불균형하게 분할되면 O(N^2)의 시간 복잡도를 가질 수 있습니다 (예: 이미 정렬된 배열에서 첫 번째 요소를 피벗으로 선택하는 경우).
- **불안정 정렬(Unstable Sort)입니다.** 동일한 값을 가진 요소들의 상대적 순서가 정렬 후에는 바뀔 수 있습니다.
- **재귀 호출로 인한 스택 오버플로우:** 매우 큰 배열을 정렬할 때 재귀 호출 깊이가 깊어져 스택 오버플로우가 발생할 수 있습니다.

## 4. 시간 복잡도

- **최선 (Best Case):** O(N log N) - 피벗이 배열을 균등하게 분할하는 경우.
- **평균 (Average Case):** O(N log N)
- **최악 (Worst Case):** O(N^2) - 피벗이 항상 가장 작은 요소나 가장 큰 요소로 선택되어 배열이 불균형하게 분할되는 경우.

## 5. 예제 코드 (JavaScript)

```javascript
function quickSort(arr) {
  if (arr.length <= 1) {
    // 배열의 길이가 1 이하면 이미 정렬된 것으로 간주
    return arr;
  }

  const pivot = arr[0]; // 첫 번째 요소를 피벗으로 선택
  const left = [];
  const right = [];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  // 재귀적으로 왼쪽, 피벗, 오른쪽을 합쳐 반환
  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 사용 예시:
// let array = [3, 0, 2, 5, -1, 4, 1];
// console.log("원본 배열:", array); // 원본 배열: [3, 0, 2, 5, -1, 4, 1]
// console.log("정렬된 배열:", quickSort(array)); // 정렬된 배열: [-1, 0, 1, 2, 3, 4, 5]
```

**코드 설명:**

1.  **기저 조건:** 배열의 길이가 1 이하이면 이미 정렬된 상태이므로 그대로 반환합니다.
2.  **피벗 선택:** 여기서는 배열의 첫 번째 요소를 피벗으로 선택합니다.
3.  **분할:** 피벗을 제외한 나머지 요소들을 순회하며 피벗보다 작은 요소는 `left` 배열에, 큰 요소는 `right` 배열에 넣습니다.
4.  **재귀 호출 및 병합:** `left` 배열과 `right` 배열에 대해 재귀적으로 `quickSort`를 호출하고, 정렬된 `left` 배열, 피벗, 정렬된 `right` 배열을 합쳐 새로운 배열을 반환합니다.
