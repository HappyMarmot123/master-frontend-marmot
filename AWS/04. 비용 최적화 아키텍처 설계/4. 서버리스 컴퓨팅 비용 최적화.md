# 서버리스 컴퓨팅 비용 최적화

## 개요
서버리스 컴퓨팅은 서버 관리 없이 코드를 실행할 수 있는 모델로, 사용한 만큼만 지불하여 유휴 비용을 제거합니다. Lambda, Fargate 등 서버리스 옵션의 비용 최적화 전략을 이해해야 합니다.

## 핵심 개념

### 서버리스란?
**정의**: 서버 관리 없이 코드를 실행하는 컴퓨팅 모델

**특징**:
- 서버 관리 불필요
- 자동 확장
- 사용한 만큼만 지불
- 유휴 비용 없음

**전통적인 방식 vs 서버리스**:
```
전통적인 방식:
EC2 인스턴스 (24/7 실행)
  → 사용하지 않아도 비용 발생
  → 유휴 비용

서버리스:
Lambda 함수 (요청 시에만 실행)
  → 사용한 만큼만 지불
  → 유휴 비용 없음
```

## AWS Lambda 비용 최적화

### Lambda 요금 구조
**요금 구성**:
1. **요청 비용**: 100만 요청당 $0.20
2. **컴퓨팅 비용**: GB-초당 $0.0000166667

**무료 티어**:
- 월 100만 요청
- 월 400,000 GB-초

### 비용 최적화 전략

#### 1. 메모리 할당 최적화
**문제**: 과도한 메모리 할당

**최적화**:
- 실제 필요한 메모리만 할당
- 성능 테스트로 최적 메모리 찾기
- 메모리와 실행 시간 균형

**비용 계산**:
```
함수 실행 시간: 1초
메모리 할당: 512MB → 256MB로 최적화

비용:
- 512MB: 512 GB-초 × $0.0000166667 = $0.0000085
- 256MB: 256 GB-초 × $0.0000166667 = $0.0000043

50% 비용 절감
```

#### 2. 실행 시간 최적화
**전략**:
- 코드 최적화
- 불필요한 작업 제거
- 효율적인 알고리즘 사용

**예시**:
```
최적화 전: 2초 실행
최적화 후: 1초 실행

비용 50% 절감
```

#### 3. 프로비저닝된 동시성
**정의**: 예약된 동시 실행 용량

**사용 사례**:
- 지연 시간이 중요한 함수
- 콜드 스타트 방지

**비용**:
- 프로비저닝된 동시성: GB-초당 $0.0000097222
- 일반 실행보다 비쌈

**최적화**:
- 필요한 경우만 사용
- 비용 고려

#### 3. 예약 동시성 (Reserved Concurrency)
**정의**: 함수의 최대 동시 실행 수 제한

**목적**:
- 다운스트림 리소스 보호
- 비용 제어

**비용 영향**:
- 직접적인 비용 없음
- 다른 함수 실행 제한 가능

### Lambda vs EC2 비용 비교

#### 시나리오: 간헐적 워크로드
```
Lambda:
- 월 10,000 요청
- 평균 실행 시간: 1초
- 메모리: 256MB

비용:
- 요청: $0.002
- 컴퓨팅: $0.043
- 총: $0.045/월

EC2 (t3.micro, 24/7):
- 시간당: $0.0104
- 월간: $7.59

→ Lambda가 99.4% 저렴
```

#### 시나리오: 지속적인 워크로드
```
Lambda:
- 초당 10 요청
- 평균 실행 시간: 1초
- 메모리: 256MB

비용:
- 요청: $5.18
- 컴퓨팅: $1,123.20
- 총: $1,128.38/월

EC2 (c5.large, 24/7):
- 시간당: $0.085
- 월간: $62.05

→ EC2가 94.5% 저렴
```

**결론**: 워크로드 특성에 따라 선택

## AWS Fargate 비용 최적화

### Fargate 요금 구조
**요금 구성**:
- **vCPU**: vCPU-시간당
- **메모리**: GB-시간당

**예시**:
```
0.25 vCPU, 0.5GB 메모리
- vCPU: $0.04048/vCPU-시간
- 메모리: $0.004445/GB-시간

시간당: $0.01012 + $0.00222 = $0.01234
```

### 비용 최적화 전략

#### 1. 리소스 할당 최적화
**전략**:
- 실제 필요한 리소스만 할당
- CPU와 메모리 균형
- 워크로드에 맞는 크기 선택

#### 2. 작업 정의 최적화
**전략**:
- 불필요한 작업 제거
- 효율적인 이미지 사용
- 컨테이너 크기 최소화

#### 3. 스팟 Fargate
**정의**: 할인된 가격의 Fargate 용량

**특징**:
- 최대 70% 할인
- 중단 가능
- 중단 가능한 워크로드에 적합

**사용 사례**:
- 배치 작업
- 테스트 환경
- 개발 환경

### Fargate vs EC2 비용 비교

#### 시나리오: 컨테이너 워크로드
```
Fargate:
- 0.25 vCPU, 0.5GB
- 시간당: $0.01234
- 월간: $9.01

EC2 (t3.small):
- 시간당: $0.0208
- 월간: $15.18

→ Fargate가 40.6% 저렴 (관리 오버헤드 제외)
```

## 서버리스 아키텍처 패턴

### 패턴 1: 이벤트 기반 처리
```
S3 이벤트
  ↓
Lambda 함수
  ↓
처리 완료

비용: 이벤트 발생 시에만 지불
```

### 패턴 2: API 게이트웨이 + Lambda
```
API 요청
  ↓
API Gateway
  ↓
Lambda 함수
  ↓
응답

비용: 요청 시에만 지불
```

### 패턴 3: 스트리밍 처리
```
Kinesis
  ↓
Lambda 함수
  ↓
처리

비용: 레코드 처리 시에만 지불
```

## 서버리스 비용 최적화 모범 사례

### 1. 적절한 서비스 선택
**전략**:
- 워크로드 특성 분석
- 서버리스 vs 전통적 방식 비교
- 비용과 성능 균형

### 2. 코드 최적화
**전략**:
- 실행 시간 최소화
- 메모리 사용 최적화
- 효율적인 알고리즘

### 3. 모니터링
**전략**:
- CloudWatch로 비용 추적
- 실행 시간 모니터링
- 비효율적인 함수 식별

### 4. 자동화
**전략**:
- 불필요한 함수 제거
- 사용하지 않는 리소스 정리
- 비용 알람 설정

## 실제 사용 예시

### 예시 1: 이미지 리사이징
```
사용자 업로드
  ↓ (S3 이벤트)
Lambda 함수 (이미지 리사이징)
  ↓
처리된 이미지 저장

비용:
- 월 10,000 업로드
- 평균 실행: 2초, 512MB
- 비용: $0.17/월

EC2 대안:
- t3.small 24/7: $15.18/월
→ Lambda가 98.9% 저렴
```

### 예시 2: 데이터 변환
```
S3에 데이터 업로드
  ↓ (S3 이벤트)
Lambda 함수 (데이터 변환)
  ↓
변환된 데이터 저장

비용:
- 월 1,000 파일
- 평균 실행: 5초, 1GB
- 비용: $0.08/월
```

### 예시 3: API 백엔드
```
API 요청
  ↓
API Gateway
  ↓
Lambda 함수 (비즈니스 로직)
  ↓
DynamoDB

비용:
- 월 100만 요청
- 평균 실행: 200ms, 256MB
- 비용: $0.20 (요청) + $0.09 (컴퓨팅) = $0.29/월
```

## 서버리스 vs 전통적 방식 선택

### 서버리스를 선택하는 경우
- 간헐적 워크로드
- 예측 불가능한 트래픽
- 이벤트 기반 처리
- 빠른 개발 필요

### 전통적 방식을 선택하는 경우
- 지속적인 워크로드
- 예측 가능한 트래픽
- 높은 성능 필요
- 장기 실행 작업

## 관련 서비스

### API Gateway
- 서버리스 API
- Lambda와 통합

### EventBridge
- 이벤트 기반 아키텍처
- Lambda 트리거

### Step Functions
- 서버리스 워크플로
- Lambda 오케스트레이션

## 참고 자료
- [Lambda 요금](https://aws.amazon.com/lambda/pricing/)
- [Fargate 요금](https://aws.amazon.com/fargate/pricing/)
- [서버리스 아키텍처](https://aws.amazon.com/serverless/)

