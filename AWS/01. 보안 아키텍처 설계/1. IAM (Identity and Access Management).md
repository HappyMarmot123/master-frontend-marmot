# IAM (Identity and Access Management)

## 개요

IAM은 AWS 리소스에 대한 액세스를 안전하게 제어하는 웹 서비스입니다. 누가(who), 무엇을(what), 어떻게(how) 액세스할 수 있는지를 정의하고 관리합니다.

### IAM이 필요한 이유

전통적인 온프레미스 환경에서는 각 서버에 개별적으로 사용자 계정을 만들고 권한을 관리해야 했습니다. AWS에서는 수백, 수천 개의 리소스가 있을 수 있기 때문에, 중앙 집중식으로 액세스를 관리하는 시스템이 필요합니다. IAM은 이를 제공합니다.

## 핵심 개념

### IAM 구성 요소

#### 1. 사용자 (User)

**정의**: AWS 서비스 및 리소스에 액세스하는 사람 또는 애플리케이션을 나타내는 엔티티

**유형**:

1. **루트 사용자 (Root User)**

   - AWS 계정을 생성할 때 자동으로 생성되는 계정
   - **모든 권한을 보유**: 계정의 모든 리소스에 대한 완전한 액세스
   - **계정 관리 전용**: 결제 정보 변경, 계정 삭제 등 계정 레벨 작업만 수행
   - **일상 작업 금지**: 루트 사용자로 일상적인 작업을 하면 안 됨
   - **MFA 필수**: 보안을 위해 MFA(Multi-Factor Authentication) 활성화 필수

2. **IAM 사용자 (IAM User)**
   - 루트 사용자 또는 관리 권한이 있는 IAM 사용자가 생성
   - **특정 권한 부여**: 필요한 권한만 부여 (최소 권한 원칙)
   - **자격 증명**:
     - 사용자 이름과 비밀번호 (콘솔 접근용)
     - 액세스 키 ID와 시크릿 액세스 키 (프로그래밍 방식 접근용)
   - **여러 사용자 생성 가능**: 계정당 무제한

**실제 사용 예시**:

```
회사에서 AWS를 사용하는 경우:
- 개발자 A: S3 읽기/쓰기 권한만
- 개발자 B: EC2 시작/중지 권한만
- 관리자: 모든 권한 (하지만 루트 사용자는 아님)
```

#### 2. 그룹 (Group)

**정의**: IAM 사용자들의 컬렉션

**특징**:

- **권한 일괄 관리**: 그룹에 정책을 연결하면 그룹 내 모든 사용자에게 권한 부여
- **사용자는 여러 그룹에 속할 수 있음**: 여러 그룹의 권한이 합쳐짐
- **그룹은 다른 그룹을 포함할 수 없음**: 중첩 그룹 불가
- **그룹 자체는 권한을 가질 수 없음**: 정책은 그룹에 연결되지만, 그룹이 직접 리소스에 액세스할 수는 없음

**작동 원리**:

```
개발자 그룹
├── 사용자 A (S3 읽기/쓰기, EC2 시작/중지)
├── 사용자 B (S3 읽기/쓰기, EC2 시작/중지)
└── 사용자 C (S3 읽기/쓰기, EC2 시작/중지)

→ 그룹에 정책을 한 번만 연결하면 모든 사용자에게 적용
```

**실제 사용 예시**:

- **개발자 그룹**: 개발 환경 리소스 접근 권한
- **운영자 그룹**: 프로덕션 환경 관리 권한
- **읽기 전용 그룹**: 모니터링 및 감사 목적

#### 3. 역할 (Role)

**정의**: 임시 자격 증명을 가진 엔티티로, 사용자, 서비스, 애플리케이션이 "가정(assume)"할 수 있는 권한 집합

**핵심 차이점 (사용자 vs 역할)**:

- **사용자**: 영구 자격 증명 (비밀번호, 액세스 키)
- **역할**: 임시 자격 증명 (역할을 "가정"할 때만 획득)

**역할 전환 (AssumeRole) 과정**:

```
1. 엔티티가 역할을 가정하고 싶다고 요청
2. IAM이 요청을 검증 (권한 확인)
3. STS (Security Token Service)가 임시 자격 증명 발급
   - 액세스 키 ID
   - 시크릿 액세스 키
   - 세션 토큰
4. 임시 자격 증명으로 AWS 서비스 접근
5. 자격 증명 만료 (기본 1시간, 최대 12시간)
```

**사용 사례**:

1. **EC2 인스턴스 역할**

   ```
   EC2 인스턴스가 S3에 접근해야 할 때:
   - 옵션 1: 액세스 키를 인스턴스에 저장 (보안 위험)
   - 옵션 2: IAM 역할을 인스턴스에 연결 (권장)
     → 인스턴스가 자동으로 역할을 가정
     → 임시 자격 증명으로 S3 접근
   ```

2. **Lambda 함수 역할**

   ```
   Lambda 함수가 DynamoDB에 접근해야 할 때:
   - Lambda 실행 역할 생성
   - 역할에 DynamoDB 읽기/쓰기 권한 부여
   - Lambda 함수에 역할 연결
   → 함수 실행 시 자동으로 역할 가정
   ```

3. **교차 계정 액세스**

   ```
   계정 A의 사용자가 계정 B의 리소스에 접근:
   - 계정 B에 역할 생성 (계정 A의 사용자 신뢰)
   - 계정 A의 사용자가 역할 가정
   - 임시 자격 증명으로 계정 B의 리소스 접근
   ```

4. **서비스 역할**
   ```
   AWS 서비스가 다른 AWS 서비스에 접근:
   - 예: EC2가 S3에 접근
   - 예: Lambda가 DynamoDB에 접근
   - 서비스 역할을 생성하여 AWS 서비스에 연결
   ```

#### 4. 정책 (Policy)

**정의**: 권한을 정의하는 JSON 형식의 문서

**정책 구조**:

```json
{
  "Version": "2012-10-17", // 정책 언어 버전
  "Statement": [
    // 권한 문장 배열
    {
      "Effect": "Allow", // Allow 또는 Deny
      "Action": [
        // 허용/거부할 작업
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::example-bucket/*", // 적용 대상 리소스
      "Condition": {
        // 선택적 조건
        "IpAddress": {
          "aws:SourceIp": "203.0.113.0/24"
        }
      }
    }
  ]
}
```

**정책 요소 설명**:

- **Version**: 정책 언어 버전 (항상 "2012-10-17" 사용)
- **Effect**:
  - `Allow`: 권한 허용
  - `Deny`: 권한 명시적 거부 (최우선)
- **Action**: 수행할 수 있는 작업
  - 형식: `서비스:작업` (예: `s3:GetObject`, `ec2:StartInstances`)
  - 와일드카드 사용 가능: `s3:*` (모든 S3 작업)
- **Resource**: 적용 대상 리소스
  - ARN (Amazon Resource Name) 형식 사용
  - 와일드카드 사용 가능: `*` (모든 리소스)
- **Condition**: 선택적 조건
  - IP 주소, 시간, 태그 등으로 제한 가능

**정책 유형**:

1. **관리형 정책 (Managed Policy)**

   - AWS에서 제공하거나 사용자가 생성한 재사용 가능한 정책
   - 여러 사용자, 그룹, 역할에 연결 가능
   - 버전 관리 지원
   - **장점**: 재사용성, 일관성, 유지보수 용이

2. **인라인 정책 (Inline Policy)**
   - 특정 사용자, 그룹, 역할에 직접 연결된 정책
   - 해당 엔티티에만 적용
   - **장점**: 간단한 권한, 엔티티별 맞춤 설정
   - **단점**: 재사용 불가, 유지보수 어려움

**정책 예시**:

```json
// S3 버킷 읽기 전용 정책
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["s3:GetObject", "s3:ListBucket"],
      "Resource": [
        "arn:aws:s3:::example-bucket",
        "arn:aws:s3:::example-bucket/*"
      ]
    }
  ]
}
```

## 정책 평가 로직

IAM이 권한 요청을 평가하는 순서와 규칙:

### 기본 원칙

1. **기본적으로 모든 요청 거부**: 명시적으로 허용하지 않으면 거부
2. **명시적 Allow**: 정책에서 Allow가 있으면 허용
3. **명시적 Deny**: 정책에서 Deny가 있으면 항상 거부 (최우선)

### 평가 순서

```
1. 명시적 Deny 확인
   → Deny가 있으면 즉시 거부 (다른 정책 확인 안 함)

2. 모든 정책에서 Allow 확인
   → 하나라도 Allow가 있으면 허용

3. Allow가 없으면 거부
```

### 실제 예시

```
사용자에게 연결된 정책:
- 정책 A: S3:* Allow
- 정책 B: s3:DeleteObject Deny

요청: s3:DeleteObject
→ 정책 B의 Deny가 최우선이므로 거부

요청: s3:GetObject
→ 정책 A의 Allow가 있으므로 허용
```

## 사용 사례

### 1. 사용자 기반 액세스

**시나리오**: 개발팀이 AWS 콘솔에 접근하여 리소스를 관리해야 함

**구현**:

1. 각 개발자에게 IAM 사용자 생성
2. 개발자 그룹 생성 및 그룹에 개발 환경 접근 권한 부여
3. 개발자를 그룹에 추가
4. MFA 활성화 (보안 강화)

**장점**:

- 개별 사용자 추적 가능
- 사용자별로 다른 권한 부여 가능
- CloudTrail로 사용자 활동 로깅

### 2. 역할 기반 액세스 (EC2)

**시나리오**: EC2 인스턴스에서 실행되는 애플리케이션이 S3에 접근해야 함

**구현**:

1. IAM 역할 생성 (S3 읽기/쓰기 권한)
2. 역할 신뢰 정책 설정 (EC2 서비스가 역할을 가정할 수 있도록)
3. EC2 인스턴스에 역할 연결
4. 애플리케이션은 AWS SDK를 통해 자동으로 임시 자격 증명 획득

**장점**:

- 액세스 키를 코드나 환경 변수에 저장할 필요 없음
- 자동으로 자격 증명 교체 (보안 강화)
- 인스턴스별로 다른 권한 부여 가능

### 3. 교차 계정 액세스

**시나리오**: 계정 A의 사용자가 계정 B의 S3 버킷에 접근해야 함

**구현**:

1. 계정 B에 역할 생성
2. 역할 신뢰 정책에 계정 A의 사용자 ARN 추가
3. 역할에 S3 접근 권한 부여
4. 계정 A의 사용자가 역할 가정
5. 임시 자격 증명으로 계정 B의 리소스 접근

**장점**:

- 계정 B에 사용자를 만들 필요 없음
- 임시 자격 증명 사용 (보안 강화)
- 외부 ID를 통한 추가 보안 (옵션)

## 중요 개념

### 1. 최소 권한 원칙 (Principle of Least Privilege)

**정의**: 사용자나 역할에게 작업을 수행하는 데 필요한 최소한의 권한만 부여하는 보안 원칙

**왜 중요한가?**:

- 권한이 과도하면 실수로 중요한 리소스를 삭제하거나 수정할 수 있음
- 보안 침해 시 피해 범위 최소화
- 규정 준수 요구사항 충족

**실행 방법**:

1. 처음에는 최소 권한으로 시작
2. 필요에 따라 점진적으로 권한 추가
3. 정기적으로 권한 검토 및 정리
4. 사용하지 않는 권한 제거

**예시**:

```
나쁜 예: 개발자에게 모든 권한 부여
→ 실수로 프로덕션 데이터베이스 삭제 가능

좋은 예: 개발자에게 개발 환경 리소스만 접근 권한 부여
→ 프로덕션 리소스에 접근 불가 (안전)
```

### 2. MFA (Multi-Factor Authentication)

**정의**: 두 가지 이상의 인증 요소를 요구하는 보안 메커니즘

**인증 요소**:

1. **알고 있는 것**: 비밀번호
2. **가지고 있는 것**: MFA 디바이스 (하드웨어 토큰, 스마트폰 앱)
3. **본인인 것**: 생체 인증 (지문, 얼굴)

**MFA 유형**:

- **하드웨어 MFA 디바이스**: 물리적 토큰 (예: YubiKey)
- **가상 MFA 디바이스**: 스마트폰 앱 (예: Google Authenticator, Authy)
- **SMS MFA**: 문자 메시지로 코드 전송 (보안 수준 낮음, 권장하지 않음)

**필수 사용 사례**:

- **루트 사용자**: 반드시 MFA 활성화
- **중요 권한을 가진 IAM 사용자**: 관리자 권한 등
- **프로덕션 환경 접근**: 프로덕션 리소스 관리 권한

**작동 원리**:

```
1. 사용자가 AWS 콘솔에 로그인 시도
2. 사용자 이름과 비밀번호 입력
3. MFA 코드 요청
4. MFA 디바이스에서 코드 확인
5. MFA 코드 입력
6. 인증 성공 → 접근 허용
```

### 3. 역할 vs 사용자 선택 기준

**역할을 사용해야 하는 경우**:

- AWS 서비스가 다른 AWS 서비스에 접근 (EC2 → S3, Lambda → DynamoDB)
- 교차 계정 액세스
- 임시 액세스가 필요한 경우
- 액세스 키를 저장하고 싶지 않은 경우

**사용자를 사용해야 하는 경우**:

- 사람이 AWS 콘솔에 접근
- 장기적인 프로그래밍 방식 접근 (하지만 역할 사용 권장)
- 개별 사용자 추적이 필요한 경우

**비교표**:

| 항목           | 사용자                     | 역할                    |
| -------------- | -------------------------- | ----------------------- |
| 자격 증명      | 영구 (비밀번호, 액세스 키) | 임시 (세션 토큰)        |
| 만료           | 없음                       | 기본 1시간, 최대 12시간 |
| 사용 대상      | 사람, 애플리케이션         | AWS 서비스, 교차 계정   |
| 액세스 키 저장 | 필요                       | 불필요 (자동 관리)      |
| 보안           | 낮음 (영구 자격 증명)      | 높음 (임시 자격 증명)   |

### 4. 정책 평가 로직 상세

IAM이 권한 요청을 평가할 때 다음 순서로 확인합니다:

1. **명시적 Deny 확인**

   - 모든 정책에서 Deny 문장 확인
   - 하나라도 Deny가 있으면 즉시 거부 (다른 정책 확인 안 함)
   - Deny는 최우선

2. **정책 수집**

   - 사용자/역할에 연결된 모든 정책 수집
   - 그룹에 연결된 정책도 포함
   - 리소스 기반 정책도 확인 (예: S3 버킷 정책)

3. **Allow 확인**

   - 수집된 모든 정책에서 Allow 문장 확인
   - 하나라도 Allow가 있으면 허용

4. **기본 거부**
   - Allow가 없으면 거부

**실제 예시**:

```
사용자: developer
그룹: developers (S3 읽기/쓰기 권한)
리소스 정책: S3 버킷 정책 (퍼블릭 읽기 허용)

요청: s3:GetObject (객체 읽기)
→ 그룹 정책에서 Allow 확인 → 허용

요청: s3:DeleteObject (객체 삭제)
→ 그룹 정책에 Allow 없음 → 거부
```

### 5. 역할 전환 (AssumeRole) 상세

**과정**:

```
1. 클라이언트가 STS AssumeRole API 호출
   - 역할 ARN 제공
   - 세션 이름 제공 (선택)
   - 외부 ID 제공 (선택, 보안 강화)

2. IAM이 요청 검증
   - 역할의 신뢰 정책 확인
   - 요청자가 역할을 가정할 권한이 있는지 확인

3. STS가 임시 자격 증명 발급
   - 액세스 키 ID
   - 시크릿 액세스 키
   - 세션 토큰
   - 만료 시간 (기본 1시간)

4. 클라이언트가 임시 자격 증명 사용
   - AWS 서비스 API 호출
   - 자격 증명이 만료되면 다시 AssumeRole 호출 필요

5. 자격 증명 만료
   - 기본: 1시간 후
   - 최대: 12시간 (역할 설정에서 변경 가능)
```

**외부 ID (External ID)**:

- 교차 계정 액세스 시 보안 강화를 위한 선택적 파라미터
- 역할 신뢰 정책에 외부 ID 조건 추가
- 역할을 가정할 때 외부 ID를 제공해야 함
- 악의적인 사용자가 역할을 가정하는 것을 방지

**예시**:

```json
// 역할 신뢰 정책
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:user/developer"
      },
      "Action": "sts:AssumeRole",
      "Condition": {
        "StringEquals": {
          "sts:ExternalId": "unique-external-id-12345"
        }
      }
    }
  ]
}
```

## 모범 사례

### 1. 루트 사용자 보호

루트 사용자는 계정의 모든 권한을 가지므로 특별히 보호해야 합니다:

- **MFA 활성화**: 반드시 MFA 설정
- **액세스 키 생성 금지**: 루트 사용자로 액세스 키를 만들지 않음
- **일상 작업 금지**: 루트 사용자로 일상적인 작업 수행 금지
- **사용 제한**: 계정 관리 작업(결제 정보 변경, 계정 삭제 등)만 수행
- **정기적 검토**: 루트 사용자 활동을 CloudTrail로 모니터링

### 2. 역할 사용 권장

가능한 한 역할을 사용하는 것이 보안상 유리합니다:

- **EC2 인스턴스**: IAM 역할 사용 (액세스 키 대신)
- **Lambda 함수**: 실행 역할 사용
- **교차 계정 액세스**: 역할 사용
- **임시 액세스**: 역할 사용

**이유**:

- 액세스 키를 코드나 환경 변수에 저장할 필요 없음
- 자동으로 자격 증명 교체 (만료 시 자동 갱신)
- 자격 증명 유출 위험 감소

### 3. 정책 관리

정책을 효율적으로 관리하는 방법:

- **관리형 정책 우선 사용**: 재사용성과 일관성
- **정책 버전 관리**: 정책 변경 시 이전 버전 유지
- **정기적인 권한 감사**: 사용하지 않는 권한 제거
- **최소 권한 원칙**: 필요한 권한만 부여
- **태그 기반 정책**: 리소스 태그를 활용한 조건부 액세스

### 4. 자격 증명 보안

자격 증명을 안전하게 관리하는 방법:

- **액세스 키 로테이션**: 정기적으로 액세스 키 교체
- **사용하지 않는 자격 증명 제거**: 퇴사자, 미사용 계정 정리
- **CloudTrail 모니터링**: 모든 IAM API 호출 로깅
- **비정상 활동 감지**: GuardDuty를 통한 위협 탐지
- **비밀번호 정책**: 강력한 비밀번호 요구사항 설정

### 5. 정기적인 감사

정기적으로 IAM 구성을 검토:

- **사용하지 않는 사용자 제거**: 90일 이상 미사용 계정 정리
- **권한 검토**: 사용자에게 부여된 권한이 여전히 필요한지 확인
- **정책 최적화**: 중복되거나 불필요한 정책 제거
- **액세스 분석**: Access Analyzer를 통한 액세스 패턴 분석

## 관련 서비스

### IAM Identity Center (이전 SSO)

- 엔터프라이즈 단일 로그인(SSO) 서비스
- 여러 AWS 계정과 비-AWS 애플리케이션에 대한 중앙 집중식 액세스 관리
- Active Directory, Okta 등 외부 ID 공급자와 통합

### STS (Security Token Service)

- 임시 보안 자격 증명 발급
- 역할 전환(AssumeRole) 처리
- 교차 계정 액세스 지원

### CloudTrail

- 모든 IAM API 호출 로깅
- 누가, 언제, 무엇을 했는지 추적
- 보안 감사 및 규정 준수

### IAM Access Analyzer

- 리소스에 대한 액세스 권한 분석
- 외부 엔티티에 대한 액세스 식별
- 권한 최적화 권장 사항 제공

### AWS Config

- IAM 리소스 구성 추적
- 구성 변경 기록
- 규정 준수 검사

## 실제 시나리오

### 시나리오 1: 개발팀 AWS 접근 설정

```
요구사항:
- 개발자 5명이 AWS 콘솔에 접근
- 개발 환경 리소스만 관리 가능
- 프로덕션 환경 접근 불가

구현:
1. 개발자 그룹 생성
2. 개발 환경 리소스 접근 정책 생성 및 그룹에 연결
3. 각 개발자에게 IAM 사용자 생성
4. 개발자를 그룹에 추가
5. MFA 활성화
```

### 시나리오 2: EC2에서 S3 접근

```
요구사항:
- EC2 인스턴스에서 실행되는 애플리케이션이 S3 버킷에 로그 저장
- 보안을 위해 액세스 키를 코드에 저장하지 않음

구현:
1. S3 쓰기 권한을 가진 IAM 역할 생성
2. 역할 신뢰 정책에 EC2 서비스 추가
3. EC2 인스턴스에 역할 연결
4. 애플리케이션은 AWS SDK를 통해 자동으로 자격 증명 획득
```

### 시나리오 3: 교차 계정 액세스

```
요구사항:
- 계정 A의 개발자가 계정 B의 개발 환경 리소스에 접근
- 계정 B에 사용자를 만들지 않음

구현:
1. 계정 B에 개발자 역할 생성
2. 역할 신뢰 정책에 계정 A의 개발자 ARN 추가
3. 역할에 개발 환경 리소스 접근 권한 부여
4. 계정 A의 개발자가 역할 가정
5. 임시 자격 증명으로 계정 B의 리소스 접근
```

## 참고 자료

- [IAM 공식 문서](https://docs.aws.amazon.com/iam/)
- [IAM 모범 사례](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html)
- [IAM 정책 예시](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_examples.html)
- [역할 전환 가이드](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html)
