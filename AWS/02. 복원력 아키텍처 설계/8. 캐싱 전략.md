# 캐싱 전략

## 개요
캐싱은 자주 사용되는 데이터를 빠른 저장소에 저장하여 성능을 향상시키고 백엔드 부하를 감소시키는 기술입니다. AWS에서는 여러 캐싱 솔루션을 제공합니다.

## 캐싱이란?

### 정의
**캐싱**: 자주 액세스하는 데이터를 빠른 저장소에 임시로 저장하여 후속 요청 시 빠르게 제공하는 기술

**작동 원리**:
```
첫 번째 요청:
클라이언트 → 백엔드 (느림) → 응답 → 캐시에 저장

두 번째 요청:
클라이언트 → 캐시 (빠름) → 응답
```

### 캐싱의 장점
1. **성능 향상**: 응답 시간 단축
2. **백엔드 부하 감소**: 데이터베이스나 API 호출 감소
3. **비용 절감**: 백엔드 리소스 사용량 감소
4. **확장성 향상**: 더 많은 요청 처리 가능

### 캐싱의 단점
1. **데이터 일관성**: 캐시된 데이터가 최신이 아닐 수 있음
2. **캐시 무효화**: 데이터 변경 시 캐시 업데이트 필요
3. **메모리 사용**: 캐시 저장소 메모리 필요

## 캐싱 계층

### 1. 클라이언트 측 캐싱
**정의**: 브라우저나 모바일 앱에서 데이터를 캐싱

**예시**:
- 브라우저 캐시
- HTTP 캐시 헤더 (Cache-Control, ETag)
- 모바일 앱 로컬 저장소

**장점**:
- 네트워크 요청 감소
- 서버 부하 없음

**단점**:
- 클라이언트별로 관리 필요
- 제어 어려움

### 2. CDN 캐싱 (CloudFront)
**정의**: 엣지 로케이션에서 정적 콘텐츠 캐싱

**캐싱 대상**:
- 정적 파일 (이미지, CSS, JavaScript)
- 동적 콘텐츠 (API 응답)

**장점**:
- 전 세계 사용자에게 빠른 응답
- 오리진 서버 부하 감소

**단점**:
- 캐시 무효화 시간 필요
- 비용 발생

### 3. 애플리케이션 레벨 캐싱 (ElastiCache)
**정의**: 애플리케이션 서버 근처에서 데이터 캐싱

**캐싱 대상**:
- 데이터베이스 쿼리 결과
- 세션 데이터
- 계산 결과

**장점**:
- 데이터베이스 부하 대폭 감소
- 빠른 응답 시간

**단점**:
- 메모리 비용
- 캐시 무효화 관리 필요

### 4. 데이터베이스 레벨 캐싱
**정의**: 데이터베이스 자체의 캐싱 기능

**예시**:
- RDS 쿼리 캐시
- DynamoDB DAX

**장점**:
- 자동 관리
- 투명한 캐싱

**단점**:
- 제어 제한적
- 데이터베이스 종속적

## AWS 캐싱 서비스

### 1. ElastiCache

#### ElastiCache란?
**정의**: 인메모리 캐싱 서비스

**지원 엔진**:
- **Redis**: 고급 기능, 복제, 영속성 지원
- **Memcached**: 단순하고 빠름, 수평 확장 용이

#### Redis vs Memcached

| 항목 | Redis | Memcached |
|------|-------|-----------|
| **데이터 타입** | 문자열, 리스트, 세트, 해시 등 | 문자열만 |
| **복제** | 지원 (Multi-AZ) | 미지원 |
| **영속성** | 지원 (RDB, AOF) | 미지원 |
| **트랜잭션** | 지원 | 미지원 |
| **Pub/Sub** | 지원 | 미지원 |
| **사용 사례** | 복잡한 데이터 구조, 고가용성 필요 | 단순 키-값 캐시 |

#### ElastiCache 사용 사례

**1. 데이터베이스 쿼리 결과 캐싱**
```
애플리케이션
  ↓ (캐시 확인)
ElastiCache
  ├── 캐시 히트 → 즉시 반환
  └── 캐시 미스 → RDS 쿼리 → 결과 캐싱 → 반환
```

**2. 세션 저장소**
```
사용자 로그인
  ↓
세션 데이터를 ElastiCache에 저장
  ↓
다음 요청 시 ElastiCache에서 세션 조회
```

**3. 실시간 순위표**
```
게임 점수 업데이트
  ↓
Redis Sorted Set에 저장
  ↓
실시간 순위 조회
```

#### ElastiCache 아키텍처

**단일 노드**:
```
애플리케이션 → ElastiCache (단일 노드)
```
- 개발/테스트 환경
- 낮은 비용

**복제 그룹 (Redis)**:
```
애플리케이션
  ├── ElastiCache Primary
  └── ElastiCache Replica (자동 복제)
```
- 고가용성
- 읽기 성능 향상

**클러스터 모드 (Redis)**:
```
애플리케이션
  ├── 샤드 1 (Primary + Replica)
  ├── 샤드 2 (Primary + Replica)
  └── 샤드 3 (Primary + Replica)
```
- 수평 확장
- 대용량 데이터

### 2. CloudFront

#### CloudFront란?
**정의**: 글로벌 콘텐츠 전송 네트워크 (CDN)

**캐싱 위치**: 엣지 로케이션 (전 세계 수백 개)

**캐싱 대상**:
- 정적 콘텐츠 (이미지, CSS, JavaScript)
- 동적 콘텐츠 (API 응답)

#### CloudFront 캐싱 작동 원리

**정적 콘텐츠**:
```
1. 사용자 요청 → 가장 가까운 엣지 로케이션
2. 엣지에서 캐시 확인
   - 캐시 히트 → 즉시 반환
   - 캐시 미스 → 오리진에서 가져와 캐싱 → 반환
```

**동적 콘텐츠**:
```
1. 사용자 요청 → 엣지 로케이션
2. 쿼리 스트링, 헤더 확인
3. 캐시 가능한 경우 캐싱
4. 캐시 불가능한 경우 오리진으로 전달
```

#### CloudFront 캐싱 설정

**TTL (Time To Live)**:
- 객체가 캐시에 저장되는 시간
- 기본: 24시간
- 커스텀: Cache-Control 헤더 또는 CloudFront 설정

**캐시 키**:
- 쿼리 스트링 포함 여부
- 헤더 포함 여부
- 쿠키 포함 여부

**캐시 무효화**:
- 특정 객체 또는 경로 무효화
- 즉시 반영 (비용 발생)

### 3. API Gateway 캐싱

#### API Gateway 캐싱이란?
**정의**: API Gateway에서 API 응답을 캐싱

**캐싱 설정**:
- 스테이지별 캐시 활성화
- TTL 설정
- 캐시 키 설정

**작동 원리**:
```
첫 번째 요청:
클라이언트 → API Gateway → Lambda → 응답 캐싱

두 번째 요청:
클라이언트 → API Gateway → 캐시에서 반환
```

**장점**:
- Lambda 호출 감소
- 비용 절감
- 응답 시간 단축

**주의사항**:
- 동적 데이터는 캐싱 주의
- 캐시 무효화 필요

## 캐싱 전략 패턴

### 1. Cache-Aside (Lazy Loading)
**정의**: 애플리케이션이 캐시를 직접 관리

**작동 원리**:
```
1. 애플리케이션이 캐시 확인
2. 캐시 히트 → 반환
3. 캐시 미스 → 데이터베이스 조회 → 캐시 저장 → 반환
```

**장점**:
- 간단한 구현
- 캐시 실패 시에도 작동

**단점**:
- 캐시 미스 시 지연
- 캐시 무효화 직접 관리

### 2. Write-Through
**정의**: 데이터 쓰기 시 캐시와 데이터베이스 모두 업데이트

**작동 원리**:
```
1. 데이터 쓰기
2. 데이터베이스 업데이트
3. 캐시 업데이트
4. 완료
```

**장점**:
- 캐시와 데이터베이스 일관성 보장
- 캐시 미스 없음

**단점**:
- 쓰기 지연 증가
- 캐시 실패 시 처리 필요

### 3. Write-Behind (Write-Back)
**정의**: 데이터를 먼저 캐시에 쓰고, 나중에 데이터베이스에 쓰기

**작동 원리**:
```
1. 데이터 쓰기
2. 캐시 업데이트 (즉시)
3. 비동기로 데이터베이스 업데이트
```

**장점**:
- 빠른 쓰기 성능
- 데이터베이스 부하 감소

**단점**:
- 데이터 손실 위험
- 복잡한 구현

### 4. Refresh-Ahead
**정의**: 캐시 만료 전에 자동으로 갱신

**작동 원리**:
```
1. 캐시 TTL이 임박
2. 백그라운드에서 데이터 갱신
3. 캐시 업데이트
```

**장점**:
- 캐시 미스 감소
- 일관된 성능

**단점**:
- 불필요한 갱신 가능
- 복잡한 구현

## 캐싱 모범 사례

### 1. 적절한 TTL 설정
- 자주 변경되는 데이터: 짧은 TTL
- 거의 변경되지 않는 데이터: 긴 TTL
- 실시간 데이터: 캐싱 비활성화

### 2. 캐시 키 설계
- 의미 있는 키 사용
- 쿼리 스트링, 헤더 고려
- 사용자별 캐시 분리 (필요 시)

### 3. 캐시 무효화
- 데이터 변경 시 캐시 무효화
- 태그 기반 무효화
- 버전 관리

### 4. 모니터링
- 캐시 히트율 모니터링
- 캐시 미스율 모니터링
- 성능 지표 추적

### 5. 다층 캐싱
- 클라이언트 캐시
- CDN 캐시
- 애플리케이션 캐시
- 데이터베이스 캐시

## 실제 사용 예시

### 예시 1: 웹 애플리케이션
```
사용자
  ↓
CloudFront (정적 파일 캐싱)
  ↓
ALB
  ↓
EC2 (애플리케이션)
  ├── ElastiCache (데이터베이스 쿼리 캐싱)
  └── RDS
```

### 예시 2: API 서비스
```
클라이언트
  ↓
API Gateway (응답 캐싱)
  ↓
Lambda
  ├── ElastiCache (세션 데이터)
  └── DynamoDB
```

### 예시 3: 전자상거래
```
사용자
  ↓
CloudFront (제품 이미지 캐싱)
  ↓
애플리케이션
  ├── ElastiCache (제품 정보 캐싱)
  └── RDS
```

## 비용 고려사항

### ElastiCache
- 인스턴스 비용: 인스턴스 유형 및 크기에 따라 다름
- 데이터 전송: 리전 간 전송 시 비용 발생

### CloudFront
- 요청: 100만 요청당 $0.085 (첫 10TB)
- 데이터 전송: GB당 $0.085 (첫 10TB)

### 비용 최적화
- 적절한 캐시 크기 선택
- 불필요한 캐시 제거
- 캐시 히트율 최적화

## 관련 서비스

### RDS
- ElastiCache로 쿼리 결과 캐싱
- RDS 부하 감소

### DynamoDB
- DAX (DynamoDB Accelerator)
- ElastiCache로 세션 저장

### Lambda
- API Gateway 캐싱
- ElastiCache 통합

## 참고 자료
- [ElastiCache 공식 문서](https://docs.aws.amazon.com/elasticache/)
- [CloudFront 공식 문서](https://docs.aws.amazon.com/cloudfront/)
- [캐싱 모범 사례](https://aws.amazon.com/caching/best-practices/)
