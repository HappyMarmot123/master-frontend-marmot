# 워크로드 디커플링

## 개요
워크로드 디커플링은 시스템 구성 요소 간의 의존성을 줄여 독립적으로 확장하고 운영할 수 있도록 하는 아키텍처 패턴입니다. 각 구성 요소가 독립적으로 작동하도록 설계합니다.

## 핵심 개념

### 디커플링이란?
**정의**: 시스템 구성 요소 간의 직접적인 의존성을 제거하는 것

**목적**:
- 독립적 확장
- 장애 격리
- 유연성 향상
- 개발 속도 향상

**전통적인 강한 결합**:
```
웹 서버 → 직접 호출 → 데이터베이스
(웹 서버가 데이터베이스에 직접 의존)
```

**디커플링된 아키텍처**:
```
웹 서버 → 메시지 큐 → 워커 → 데이터베이스
(웹 서버와 데이터베이스 간 직접 의존 없음)
```

## 디커플링 패턴

### 1. 비동기 메시징 패턴

#### SQS를 사용한 디커플링
**구조**:
```
프로듀서 (웹 서버)
  ↓ (메시지 전송)
SQS 큐
  ↓ (메시지 수신)
컨슈머 (워커)
  ↓ (처리)
데이터베이스
```

**장점**:
- 프로듀서와 컨슈머 독립적 확장
- 데이터베이스 장애 시 웹 서버 영향 없음
- 피크 시간 부하 완화

**예시**:
```
이미지 업로드 처리:
1. 사용자가 이미지 업로드
2. 웹 서버가 즉시 응답
3. 메시지를 SQS에 전송
4. 워커가 비동기로 이미지 처리
5. 결과 저장
```

#### SNS를 사용한 디커플링
**구조**:
```
이벤트 발생
  ↓
SNS 토픽
  ├── 구독자 1 (Lambda)
  ├── 구독자 2 (SQS)
  └── 구독자 3 (HTTP)
```

**장점**:
- 여러 시스템에 동시 알림
- 발행자와 구독자 완전 분리
- 확장성

### 2. 이벤트 기반 아키텍처

#### EventBridge를 사용한 디커플링
**구조**:
```
서비스 A
  ↓ (이벤트 발행)
EventBridge
  ├── 서비스 B (이벤트 구독)
  ├── 서비스 C (이벤트 구독)
  └── 서비스 D (이벤트 구독)
```

**특징**:
- 완전한 디커플링
- 서비스 간 직접 통신 없음
- 이벤트 기반 통신

**예시**:
```
주문 생성 이벤트
  ↓
EventBridge
  ├── 재고 서비스 (재고 차감)
  ├── 결제 서비스 (결제 처리)
  └── 배송 서비스 (배송 준비)
```

### 3. API Gateway를 사용한 디커플링

#### 마이크로서비스 통합
**구조**:
```
클라이언트
  ↓
API Gateway (단일 진입점)
  ├── 마이크로서비스 A
  ├── 마이크로서비스 B
  └── 마이크로서비스 C
```

**장점**:
- 클라이언트와 백엔드 분리
- 백엔드 변경 시 클라이언트 영향 없음
- 여러 서비스를 하나의 API로 통합

### 4. 스토리지를 사용한 디커플링

#### S3를 사용한 디커플링
**구조**:
```
서비스 A (데이터 생성)
  ↓ (S3에 저장)
S3 버킷
  ↓ (이벤트 알림)
서비스 B (데이터 처리)
```

**예시**:
```
이미지 업로드:
1. 사용자가 이미지 업로드 (S3)
2. S3 이벤트 발생
3. Lambda 함수 트리거
4. 이미지 리사이징
5. 결과 저장
```

## 디커플링의 이점

### 1. 독립적 확장
**전통적인 결합**:
```
웹 서버와 데이터베이스가 강하게 결합
→ 웹 서버 확장 시 데이터베이스도 함께 확장 필요
```

**디커플링 후**:
```
웹 서버와 데이터베이스 독립적
→ 웹 서버만 확장 가능
→ 데이터베이스는 별도로 확장
```

### 2. 장애 격리
**전통적인 결합**:
```
데이터베이스 장애
  ↓
웹 서버도 영향 받음
  ↓
전체 시스템 장애
```

**디커플링 후**:
```
데이터베이스 장애
  ↓
메시지 큐에 메시지 저장
  ↓
웹 서버는 계속 작동
  ↓
데이터베이스 복구 후 처리
```

### 3. 개발 속도 향상
**전통적인 결합**:
```
서비스 A 변경
  ↓
서비스 B도 함께 배포 필요
  ↓
느린 배포
```

**디커플링 후**:
```
서비스 A 변경
  ↓
서비스 A만 배포
  ↓
빠른 배포
```

## 실제 아키텍처 예시

### 예시 1: 전자상거래 시스템
```
사용자 주문
  ↓
API Gateway
  ↓
주문 서비스 (Lambda)
  ↓ (주문 생성 이벤트)
EventBridge
  ├── 재고 서비스 (재고 차감)
  ├── 결제 서비스 (결제 처리)
  └── 알림 서비스 (이메일 전송)
```

### 예시 2: 미디어 처리 파이프라인
```
사용자 업로드
  ↓
S3 (원본 파일)
  ↓ (S3 이벤트)
Lambda (메시지 전송)
  ↓
SQS 큐
  ↓
워커 (ECS)
  ├── 비디오 인코딩
  ├── 썸네일 생성
  └── 메타데이터 추출
  ↓
S3 (처리된 파일)
```

### 예시 3: 데이터 분석 파이프라인
```
데이터 수집
  ↓
Kinesis (스트리밍)
  ↓
Lambda (변환)
  ↓
S3 (데이터 레이크)
  ↓ (S3 이벤트)
EMR (배치 분석)
  ↓
S3 (결과)
  ↓
데이터 분석
```

## 디커플링 전략

### 1. 메시지 큐 도입
**목적**: 비동기 처리

**구현**:
- SQS로 작업 큐 생성
- 프로듀서는 메시지 전송 후 즉시 응답
- 컨슈머는 비동기로 처리

### 2. 이벤트 버스 도입
**목적**: 이벤트 기반 통신

**구현**:
- EventBridge 또는 SNS 사용
- 서비스 간 이벤트 기반 통신
- 완전한 디커플링

### 3. API Gateway 도입
**목적**: 클라이언트와 백엔드 분리

**구현**:
- API Gateway를 단일 진입점으로 사용
- 백엔드 서비스 변경 시 클라이언트 영향 없음

### 4. 스토리지 기반 통신
**목적**: 파일 기반 통신

**구현**:
- S3를 중간 저장소로 사용
- 이벤트 알림으로 다음 단계 트리거

## 모범 사례

### 1. 적절한 디커플링 수준
- 과도한 디커플링은 복잡도 증가
- 필요한 만큼만 디커플링

### 2. 메시지 순서 관리
- 순서가 중요한 경우 FIFO 큐 사용
- 순서가 중요하지 않은 경우 표준 큐

### 3. 에러 처리
- Dead Letter Queue 사용
- 재시도 정책 설정
- 모니터링 및 알람

### 4. 모니터링
- 메시지 큐 깊이 모니터링
- 처리 지연 시간 추적
- 처리량 추적

## 관련 서비스

### SQS
- 메시지 큐
- 비동기 처리

### SNS
- Pub/Sub
- 이벤트 알림

### EventBridge
- 이벤트 버스
- 이벤트 기반 아키텍처

### API Gateway
- API 관리
- 마이크로서비스 통합

### Step Functions
- 워크플로 오케스트레이션
- 복잡한 디커플링된 워크플로

## 참고 자료
- [디커플링 패턴](https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/decouple-components.html)
- [마이크로서비스 아키텍처](https://aws.amazon.com/microservices/)

