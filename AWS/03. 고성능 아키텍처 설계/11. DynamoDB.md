# DynamoDB

## 개요
Amazon DynamoDB는 완전 관리형 NoSQL 데이터베이스 서비스로, 밀리초 단위의 지연 시간과 무제한 확장성을 제공합니다. 서버리스 아키텍처와 고성능 애플리케이션에 적합합니다.

## 핵심 개념

### DynamoDB란?
**정의**: 완전 관리형 NoSQL 데이터베이스

**특징**:
- **서버리스**: 서버 관리 불필요
- **자동 확장**: 트래픽에 따라 자동 확장
- **높은 성능**: 밀리초 단위 지연 시간
- **높은 가용성**: 99.99% 가용성 SLA

**작동 원리**:
```
애플리케이션
  ↓ (API 호출)
DynamoDB
  ├── 테이블
  ├── 항목 (Item)
  └── 속성 (Attribute)
```

### NoSQL이란?
**정의**: Not Only SQL, 관계형 데이터베이스가 아닌 데이터베이스

**특징**:
- 스키마 없음 (유연한 스키마)
- 수평 확장 용이
- 높은 성능
- 다양한 데이터 모델

**RDBMS와의 차이**:
- **RDBMS**: 테이블, 행, 열, 관계
- **NoSQL**: 테이블, 항목, 속성, 관계 없음

## DynamoDB 데이터 모델

### 1. 테이블 (Table)
**정의**: 데이터를 저장하는 컨테이너

**특징**:
- 리전별로 생성
- 무제한 항목 저장 가능
- 자동 확장

### 2. 항목 (Item)
**정의**: 테이블의 데이터 단위 (RDBMS의 행과 유사)

**특징**:
- 최대 400KB
- 여러 속성 포함 가능
- 유연한 스키마

### 3. 속성 (Attribute)
**정의**: 항목의 데이터 필드 (RDBMS의 열과 유사)

**데이터 타입**:
- **Scalar**: String, Number, Binary, Boolean, Null
- **Document**: List, Map
- **Set**: String Set, Number Set, Binary Set

**예시**:
```json
{
  "UserId": "12345",           // 파티션 키
  "OrderId": "ORD-001",        // 정렬 키
  "OrderDate": "2024-01-01",
  "Items": [                    // List
    {
      "ProductId": "PROD-001",
      "Quantity": 2
    }
  ],
  "TotalAmount": 100.00
}
```

## DynamoDB 키

### 파티션 키 (Partition Key)
**정의**: 항목을 고유하게 식별하는 단일 속성

**특징**:
- 필수
- 항목을 파티션에 분산
- 고유해야 함

**예시**:
```
파티션 키: UserId
→ UserId 값에 따라 파티션 분산
```

### 복합 키 (Composite Key)
**정의**: 파티션 키 + 정렬 키

**특징**:
- 파티션 키: 파티션 결정
- 정렬 키: 파티션 내 정렬
- 파티션 키가 같으면 정렬 키로 정렬

**예시**:
```
파티션 키: UserId
정렬 키: OrderDate

→ 같은 사용자의 주문을 날짜순으로 정렬
```

## DynamoDB 용량 모드

### 1. 프로비저닝된 용량 (Provisioned Capacity)
**정의**: 읽기/쓰기 용량을 미리 프로비저닝

**특징**:
- 읽기 용량 단위 (RCU) 설정
- 쓰기 용량 단위 (WCU) 설정
- 예측 가능한 비용
- Auto Scaling 가능

**용량 단위**:
- **RCU**: 초당 읽기 용량 단위
  - 최종 일관성: 4KB 항목 1개 읽기
  - 강한 일관성: 4KB 항목 0.5개 읽기
- **WCU**: 초당 쓰기 용량 단위
  - 1KB 항목 1개 쓰기

**Auto Scaling**:
- 트래픽에 따라 자동 조정
- 최소/최대 용량 설정
- CloudWatch 지표 기반

### 2. 온디맨드 (On-Demand)
**정의**: 사용한 만큼만 지불하는 용량 모드

**특징**:
- 용량 프로비저닝 불필요
- 자동 확장
- 예측 불가능한 트래픽에 적합
- 비용: 요청당 지불

**사용 사례**:
- 예측 불가능한 트래픽
- 개발/테스트 환경
- 스파이크 트래픽

**비용**:
- 읽기: 100만 요청당 $0.25
- 쓰기: 100만 요청당 $1.25

## DynamoDB 인덱스

### 1. 글로벌 보조 인덱스 (GSI)
**정의**: 다른 파티션 키와 정렬 키를 가진 인덱스

**특징**:
- 다른 파티션 키 사용 가능
- 테이블과 독립적으로 프로비저닝
- 쿼리 성능 향상

**사용 사례**:
- 다른 속성으로 쿼리
- 역방향 쿼리
- 다른 정렬 순서

**예시**:
```
기본 테이블:
- 파티션 키: UserId
- 정렬 키: OrderDate

GSI:
- 파티션 키: ProductId
- 정렬 키: OrderDate

→ 제품별 주문 조회 가능
```

### 2. 로컬 보조 인덱스 (LSI)
**정의**: 같은 파티션 키, 다른 정렬 키를 가진 인덱스

**특징**:
- 같은 파티션 키 사용
- 파티션 내에서만 작동
- 테이블과 같은 용량 공유

**사용 사례**:
- 같은 파티션 키, 다른 정렬 순서
- 다양한 쿼리 패턴

**예시**:
```
기본 테이블:
- 파티션 키: UserId
- 정렬 키: OrderDate

LSI:
- 파티션 키: UserId (동일)
- 정렬 키: TotalAmount

→ 같은 사용자의 주문을 금액순으로 조회
```

## DynamoDB 작업

### 읽기 작업

#### GetItem
**정의**: 단일 항목 조회

**특징**:
- 파티션 키 필수
- 정렬 키 필수 (복합 키인 경우)
- 빠른 조회 (O(1))

#### Query
**정의**: 파티션 키로 여러 항목 조회

**특징**:
- 파티션 키 필수
- 정렬 키 조건 가능
- 효율적인 조회

**예시**:
```
파티션 키: UserId = "12345"
정렬 키: OrderDate BETWEEN "2024-01-01" AND "2024-12-31"

→ 사용자 12345의 2024년 주문 조회
```

#### Scan
**정의**: 전체 테이블 스캔

**특징**:
- 모든 항목 검사
- 비효율적 (전체 테이블 읽기)
- 가능한 한 피해야 함

**사용 사례**:
- 전체 데이터 내보내기
- 데이터 마이그레이션
- 특수한 경우만 사용

### 쓰기 작업

#### PutItem
**정의**: 항목 생성 또는 업데이트

**특징**:
- 항목이 없으면 생성
- 항목이 있으면 교체
- 조건부 쓰기 가능

#### UpdateItem
**정의**: 항목의 속성 업데이트

**특징**:
- 부분 업데이트 가능
- Atomic 연산 지원
- 조건부 업데이트 가능

#### DeleteItem
**정의**: 항목 삭제

**특징**:
- 조건부 삭제 가능
- 복원 불가

## DynamoDB 일관성 모델

### 최종 일관성 (Eventually Consistent)
**정의**: 읽기 시 최신 데이터가 아닐 수 있음

**특징**:
- 기본 읽기 모드
- 더 높은 성능
- 더 낮은 비용 (RCU 절반)

**사용 사례**:
- 최신 데이터가 필수 아닌 경우
- 읽기 성능 우선

### 강한 일관성 (Strongly Consistent)
**정의**: 읽기 시 최신 데이터 보장

**특징**:
- 최신 데이터 보장
- 더 높은 비용 (RCU 2배)
- 약간 낮은 성능

**사용 사례**:
- 최신 데이터 필수
- 금융 거래 등

## DynamoDB vs RDS

### 비교표

| 항목 | DynamoDB | RDS |
|------|----------|-----|
| **타입** | NoSQL | 관계형 (SQL) |
| **스키마** | 유연 | 고정 |
| **확장성** | 자동, 무제한 | 수동, 제한적 |
| **성능** | 밀리초 | 수십 밀리초 |
| **관계** | 없음 | 있음 (JOIN) |
| **비용** | 사용량 기반 | 인스턴스 기반 |
| **사용 사례** | 서버리스, 확장성 | 관계형 데이터, 복잡한 쿼리 |

### 선택 기준

#### DynamoDB를 선택하는 경우
- 서버리스 아키텍처
- 높은 확장성 필요
- 예측 불가능한 트래픽
- 단순한 데이터 모델
- 낮은 지연 시간 필요

#### RDS를 선택하는 경우
- 관계형 데이터
- 복잡한 쿼리 (JOIN 등)
- 트랜잭션 필요
- 기존 SQL 애플리케이션

## DynamoDB 고가용성

### 자동 복제
**특징**:
- 여러 AZ에 자동 복제
- 99.99% 가용성 SLA
- 자동 장애 복구

### 글로벌 테이블
**정의**: 여러 리전에 테이블 복제

**특징**:
- 리전 간 자동 복제
- 각 리전에서 읽기/쓰기 가능
- 낮은 지연 시간 (로컬 리전 사용)

**구조**:
```
글로벌 테이블
  ├── 리전 A (서울) - 읽기/쓰기
  ├── 리전 B (도쿄) - 읽기/쓰기
  └── 리전 C (버지니아) - 읽기/쓰기

→ 모든 리전에서 읽기/쓰기 가능
→ 자동으로 리전 간 복제
```

## DynamoDB Streams

### DynamoDB Streams란?
**정의**: 테이블 변경 사항을 실시간으로 캡처하는 기능

**특징**:
- 항목 수정, 삭제, 추가 시 이벤트 생성
- 실시간 처리
- Lambda와 통합

**사용 사례**:
- 실시간 데이터 처리
- 이벤트 기반 아키텍처
- 데이터 복제
- 감사 로깅

**작동 원리**:
```
DynamoDB 테이블 변경
  ↓
DynamoDB Streams
  ↓
Lambda 함수 트리거
  ↓
이벤트 처리
```

## 모범 사례

### 1. 파티션 키 설계
- 고르게 분산되는 키 선택
- 핫 파티션 방지
- 쿼리 패턴 고려

### 2. 인덱스 최적화
- 필요한 인덱스만 생성
- GSI vs LSI 선택
- 프로젝션 최적화

### 3. 용량 모드 선택
- 예측 가능한 트래픽: 프로비저닝
- 예측 불가능한 트래픽: 온디맨드

### 4. 비용 최적화
- 적절한 용량 설정
- Auto Scaling 활용
- 불필요한 인덱스 제거

## 관련 서비스

### Lambda
- DynamoDB Streams 처리
- 서버리스 애플리케이션

### API Gateway
- RESTful API
- DynamoDB와 통합

### DAX
- DynamoDB Accelerator
- 마이크로초 단위 지연 시간

## 참고 자료
- [DynamoDB 공식 문서](https://docs.aws.amazon.com/dynamodb/)
- [DynamoDB 모범 사례](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)

